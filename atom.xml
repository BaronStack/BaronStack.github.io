<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>那一刻 风情万种</title>
  
  <subtitle>我喜欢看你笑的样子</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-02-22T12:19:41.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>那一刻 风情万种</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>C++面试问题准备：辨认大小端以及系统位数</title>
    <link href="http://yoursite.com/2018/02/17/C-%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E5%87%86%E5%A4%87%EF%BC%9A%E8%BE%A8%E8%AE%A4%E5%A4%A7%E5%B0%8F%E7%AB%AF%E4%BB%A5%E5%8F%8A%E7%B3%BB%E7%BB%9F%E4%BD%8D%E6%95%B0/"/>
    <id>http://yoursite.com/2018/02/17/C-面试问题准备：辨认大小端以及系统位数/</id>
    <published>2018-02-17T08:33:17.000Z</published>
    <updated>2018-02-22T12:19:41.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是大小端-big-endian和small-endian"><a href="#什么是大小端-big-endian和small-endian" class="headerlink" title="什么是大小端(big-endian和small-endian)"></a>什么是大小端(big-endian和small-endian)</h2><p>即最高有效位(most significant)在低地址位就是大端，最低有效位(least significant)在低地址就是小端。<br>大概意思就是：我们取数据a = 0x12ff，那么最高有效位指的就是数字的0x12数据，最低有效位指的是0xff。<br><a id="more"></a></p><blockquote><p>即如果数据的最高有效位的数据0x12存放在内存中的低地址，那么该计算机存储的方式就是大端存储。相反就是小端存储。</p></blockquote><h2 id="如何用程序分辨大小端"><a href="#如何用程序分辨大小端" class="headerlink" title="如何用程序分辨大小端"></a>如何用程序分辨大小端</h2><p>根据上面大小端的定义，我们可以写出如下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> num1 = <span class="number">0x12FF</span>;</span><br><span class="line"><span class="keyword">char</span> * address = (<span class="keyword">char</span> *)&amp;num1;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"low bytes is %x , high bytes is %x"</span>,*address &amp; <span class="number">0xFF</span>,  *(address + <span class="number">1</span>) &amp; <span class="number">0xFF</span> );</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line">low bytes is ff , high bytes is <span class="number">12</span></span><br></pre></td></tr></table></figure><p>即数据<code>num1 = 0x12FF</code>的最高有效位<code>0x12</code>存储在存放该数据内存块较低的位置，该程序可以做为验证计算机系统存储数据是大端还是小端。</p><h2 id="如何分辨计算机系统是32位还是64位"><a href="#如何分辨计算机系统是32位还是64位" class="headerlink" title="如何分辨计算机系统是32位还是64位"></a>如何分辨计算机系统是32位还是64位</h2><p>在32位系统中<code>int</code> 和 <code>long int</code>是4 字节，而64位系统中则变为8字</p><p>所以在以上代码中添加如下一行程序即可查看系统位数</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">0x80000000</span>;</span><br><span class="line"><span class="keyword">printf</span>(<span class="string">"\nos is%ld\t%ld\n"</span>,a,sizeof(<span class="keyword">int</span>));</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是大小端-big-endian和small-endian&quot;&gt;&lt;a href=&quot;#什么是大小端-big-endian和small-endian&quot; class=&quot;headerlink&quot; title=&quot;什么是大小端(big-endian和small-endian)&quot;&gt;&lt;/a&gt;什么是大小端(big-endian和small-endian)&lt;/h2&gt;&lt;p&gt;即最高有效位(most significant)在低地址位就是大端，最低有效位(least significant)在低地址就是小端。&lt;br&gt;大概意思就是：我们取数据a = 0x12ff，那么最高有效位指的就是数字的0x12数据，最低有效位指的是0xff。&lt;br&gt;
    
    </summary>
    
      <category term="面试" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
      <category term="OS" scheme="http://yoursite.com/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>C++面试问题准备：i++是否原子操作，为什么</title>
    <link href="http://yoursite.com/2018/02/17/C-%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E5%87%86%E5%A4%87%EF%BC%9Ai-%E6%98%AF%E5%90%A6%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88/"/>
    <id>http://yoursite.com/2018/02/17/C-面试问题准备：i-是否原子操作，为什么/</id>
    <published>2018-02-17T06:48:38.000Z</published>
    <updated>2018-02-17T07:18:54.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是操作系统原子操作"><a href="#什么是操作系统原子操作" class="headerlink" title="什么是操作系统原子操作"></a>什么是操作系统原子操作</h2><p><strong>原子操作是不可分割的，在执行完毕之前不会被任何其他事物或者事件中断，分为以下两种情况：</strong></p><ul><li>在单线程中， 能够在单条指令中完成的操作都可以认为是” 原子操作”，因为中断只能发生于指令之间</li><li>在多线程中，不能被其它进程（线程）打断的操作就叫原子操作 <a id="more"></a></li></ul><h2 id="i-分为三个阶段"><a href="#i-分为三个阶段" class="headerlink" title="i++分为三个阶段"></a>i++分为三个阶段</h2><ol><li>内存到寄存器</li><li>寄存器自增</li><li>写回内存</li></ol><p>一般的编译器会将i++翻译为</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="built_in">eax</span>,  <span class="built_in">dword</span> <span class="built_in">ptr</span>[i]</span><br><span class="line"><span class="keyword">inc</span> <span class="built_in">eax</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">dword</span> <span class="built_in">ptr</span>[i], <span class="built_in">eax</span></span><br></pre></td></tr></table></figure><p>但是在没有加锁的情况下不会产生互斥，所以这样肯定不是原子操作。除非编译器能够将第一第二步操作翻译为<code>lock inc dword ptr[i]</code>，那么该锁会锁住总线，从而保证无论多核还是单核CPU都只会自增一次。</p><blockquote><p>所以针对问题<strong>i++在两个线程里边分别执行100次，能得到的最大值和最小值分别是多少？</strong>的答案便是2-200<br>当两个线程每次执行完++之后不写入内存，最后一个较小的线程将值写入内存为2；相反，当两个线程每次读入寄存器并执行完操作之后都写入内存，且线程交叉执行，最后的结果就是200</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是操作系统原子操作&quot;&gt;&lt;a href=&quot;#什么是操作系统原子操作&quot; class=&quot;headerlink&quot; title=&quot;什么是操作系统原子操作&quot;&gt;&lt;/a&gt;什么是操作系统原子操作&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;原子操作是不可分割的，在执行完毕之前不会被任何其他事物或者事件中断，分为以下两种情况：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在单线程中， 能够在单条指令中完成的操作都可以认为是” 原子操作”，因为中断只能发生于指令之间&lt;/li&gt;
&lt;li&gt;在多线程中，不能被其它进程（线程）打断的操作就叫原子操作
    
    </summary>
    
      <category term="面试" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>2018-02-16</title>
    <link href="http://yoursite.com/2018/02/16/2018-02-16/"/>
    <id>http://yoursite.com/2018/02/16/2018-02-16/</id>
    <published>2018-02-16T15:05:27.000Z</published>
    <updated>2018-02-16T15:11:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天是大年初一，昨天收到很多祝福，发送了很多祝福，哈哈 还是糖永永同学的祝福让我印象深刻:<font color="#DC143C">巴啦啦小魔仙蹦沙卡拉卡二哈跳狗年事业旺旺旺旺旺旺!</font></p><p>哈哈 我想只有她能想出这样的祝福了～ 开心的。。。<a id="more"></a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天是大年初一，昨天收到很多祝福，发送了很多祝福，哈哈 还是糖永永同学的祝福让我印象深刻:&lt;font color=&quot;#DC143C&quot;&gt;巴啦啦小魔仙蹦沙卡拉卡二哈跳狗年事业旺旺旺旺旺旺!&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;哈哈 我想只有她能想出这样的祝福了～ 开心的。。。
    
    </summary>
    
      <category term="日记" scheme="http://yoursite.com/categories/life/"/>
    
    
  </entry>
  
  <entry>
    <title>2018-02-14</title>
    <link href="http://yoursite.com/2018/02/14/2018-02-14/"/>
    <id>http://yoursite.com/2018/02/14/2018-02-14/</id>
    <published>2018-02-14T06:12:16.000Z</published>
    <updated>2018-02-14T06:33:25.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天是情人节，我喜欢上糖永永的第34天，我用了一周的时间搜集了她朋友圈2017年所有有意义的照片为她做了一个电子相册，前后总共改了7次，做出来一个较为满意的结果，<a href="https://pan.baidu.com/s/1bqSVwQF" target="_blank" rel="noopener">TYY</a> 百度云密码:hhuw。<a id="more"></a>在今天凌晨12：06分发给她。我能感受得到她内心的激动与翻涌，她很开心，但是又很复杂。她对自己没有信心了，上一段感情让她收到了很大的伤害，她内心纠结要不要再将自己的安全感交由另一个男生。</p><p>我看到她这个样子真的是十分心痛，感情不是一个人的事情，如果只有单方向的付出，最后一道防线崩溃后内心所受的伤害就很难愈合。她到底被伤害成什么样子了才能如此痛苦难受，面对我的小礼物，从最开始的好奇、开心、激动、内心复杂、难过。她很犹豫到底该不该接受这样的喜欢～～～因为她对自己实在没有信心！所以我就鼓励她让她先不要想着接受，先用时间了解，等感觉时机成熟再作出选择。</p><p>对于我来说我又何尝对自己有信心，但是我知道喜欢她，她很独特，在我的内心已经是独一无二了，很少有心动的感觉，所以即使没有信心，我也会努力追逐！我希望能用自己的方式让她得到她想要的，无需担心会失去的依赖感。她说她是钻石心，不怕伤害，但是伤害了就碎了！我会努力去了解她，了解她在生活点点滴滴中所拥有的个性，内心深处的向往：爱情、亲情、友情、梦想。然后用自己的方式去帮助她去让自己变得更自信，内心更快乐，而不是表现出来的快乐！</p><p>突然好想她哦～<br>假期怎么这么长！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天是情人节，我喜欢上糖永永的第34天，我用了一周的时间搜集了她朋友圈2017年所有有意义的照片为她做了一个电子相册，前后总共改了7次，做出来一个较为满意的结果，&lt;a href=&quot;https://pan.baidu.com/s/1bqSVwQF&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;TYY&lt;/a&gt; 百度云密码:hhuw。
    
    </summary>
    
      <category term="日记" scheme="http://yoursite.com/categories/life/"/>
    
    
  </entry>
  
  <entry>
    <title>markdown字体、字号、字体颜色设置</title>
    <link href="http://yoursite.com/2018/02/11/markdown%E5%AD%97%E4%BD%93%E3%80%81%E5%AD%97%E5%8F%B7%E3%80%81%E5%AD%97%E4%BD%93%E9%A2%9C%E8%89%B2%E8%AE%BE%E7%BD%AE/"/>
    <id>http://yoursite.com/2018/02/11/markdown字体、字号、字体颜色设置/</id>
    <published>2018-02-11T13:06:37.000Z</published>
    <updated>2018-02-14T06:55:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>Markdown 是一种轻量级标记语言。<a id="more"></a>创始人为約翰·格魯伯（John Gruber）。它允许人们“使用易读易写的纯文本格式编写文档，然后转换成有效的XHTML（或者HTML）文档”。这种语言吸收了很多在电子邮件中已有的纯文本标记的特性。</p><p>关于MarkDown的基础语法可以参考它的官方文档<a href="https://www.appinn.com/markdown/" target="_blank" rel="noopener">MarkDown语法说明（中文版）</a><!--more--></p><p>这里说一下在用markdown写文档的时候如何设置字体颜色，字体大小以及字体形态。</p><p>在文本中添加\<font color="#ffffff" \="">文本\，这个就可以设置自己文本的颜色，关于具体文本颜色可以参考下图</font></p><p>设置字号同样\<font size="7\">文本\，这里一般浏览器默认的字号大小是3</font></p><p>设置字体形态同样\<font face="Adobe 黑体" \="">文本\，可以在face之后添加自己想要的形态.</font></p><blockquote><p>以上三者可以相互结合添加，对markdown中的文本进行设置</p></blockquote><p><img src="/images/fontColor.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Markdown 是一种轻量级标记语言。
    
    </summary>
    
      <category term="随笔" scheme="http://yoursite.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
  <entry>
    <title>C++面试问题准备：STL-iterator</title>
    <link href="http://yoursite.com/2018/02/11/C-%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E5%87%86%E5%A4%87%EF%BC%9ASTL-iterator/"/>
    <id>http://yoursite.com/2018/02/11/C-面试问题准备：STL-iterator/</id>
    <published>2018-02-11T12:53:12.000Z</published>
    <updated>2018-02-17T05:18:50.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这两天在家里没有好好读书，要反思一下。今天看《STL源码剖析》到了迭代器iterator这里</p></blockquote><h2 id="什么是迭代器"><a href="#什么是迭代器" class="headerlink" title="什么是迭代器"></a>什么是迭代器</h2><p>在《Design Patterns》中对迭代器模式的描述如下：<font color="#DC143C">提供一种方法，使之能够依序寻访某个聚合物（容器）所含的各个元素，而又无需暴露该聚合物内部表现方式</font> <a id="more"></a></p><blockquote><p>这里小小的回忆下我们复习过的面向对象五大原则，显然该设计模式满足单一职责原则(<strong>对于迭代器来说只有元素地址能够引起它的变化</strong>)以及接口隔离(<strong>迭代器的设计就是为了访问数据元素，即访问接口</strong>)原则。详细请看<a href="https://baronstack.github.io/#/posts/C-面试问题准备：面向对象的基本原则" target="_blank" rel="noopener">面向对象基本原则</a></p></blockquote><p>观察如下代码：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">template &lt;<span class="built_in">class</span> InputIterator,<span class="built_in">class</span> T&gt;</span><br><span class="line">InputIterator find (InputIterator <span class="keyword">first</span>,InputIterator <span class="keyword">last</span>,const T&amp; value) &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">first</span> != <span class="keyword">last</span> &amp;&amp; *<span class="keyword">first</span> != value)</span><br><span class="line">        ++ <span class="keyword">first</span>;</span><br><span class="line"><span class="built_in">    return</span> <span class="keyword">first</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一段find()函数的源码，显然我们能够发现，给予不同的迭代器，find函数便能够对不同的容器进行查找操作。</p><p>在本书STL中，对本书迭代器的描述是:<font color="#DC143C">迭代器是一种行为类似指针的对象。</font>而指针的各种行为中最为常见也最重要的便是内容提领和成员访问。因此迭代器最重要的工作就是<font color="#DC143C">对operator*和operator-&gt;进行重载</font>。这里对内容提领和成员访问的描述可以先参考原生态指针auto_ptr的简化代码：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;class T&gt;</span><br><span class="line">class auto_ptr &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">explicit</span> auto_ptr(T *p = <span class="number">0</span>) : pointee(p) () <span class="comment">//explicit构造函数是用来防止隐式转换的,使得代码更加清晰明确</span></span><br><span class="line">        <span class="keyword">template</span> &lt;class U&gt;</span><br><span class="line">        auto_ptr(auto_ptr&lt;U&gt;&amp; rhs) : pointee(rhs.<span class="built_in">release</span>()) &#123;&#125;</span><br><span class="line">        ~auto_ptr() ( <span class="keyword">delete</span> pointee; )</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">template</span>&lt;class U&gt;</span><br><span class="line">        auto_ptr&lt;T&gt; &amp; <span class="keyword">operator</span>=(auto_ptr&lt;U&gt; &amp; rhs) &#123;</span><br><span class="line">            <span class="built_in">if</span> (<span class="keyword">this</span> != &amp;rhs) </span><br><span class="line">                reset(rhs.<span class="built_in">release</span>());</span><br><span class="line">            <span class="built_in">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        T&amp; <span class="keyword">operator</span>*() <span class="keyword">const</span> &#123; <span class="built_in">return</span> *pointee; &#125;</span><br><span class="line">        T* <span class="keyword">operator</span>-&gt; () <span class="keyword">const</span> &#123; <span class="built_in">return</span> pointee; &#125;</span><br><span class="line">        T* <span class="built_in">get</span> <span class="keyword">const</span> &#123; <span class="built_in">return</span> pointee; &#125;</span><br><span class="line">        <span class="comment">//..</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        T *pointee;</span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> func() &#123;</span><br><span class="line">    auto_ptr&lt;<span class="keyword">string</span>&gt; ps(<span class="keyword">new</span> <span class="keyword">string</span>(<span class="string">"jjhou"</span>));<span class="comment">//auto_ptr括号内放置的是"原生指针所指对象的型别"，而非原生指针的型别</span></span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; *ps &lt;&lt; endl; <span class="comment">//output:jjhou</span></span><br><span class="line">    cout &lt;&lt; ps -&gt; <span class="built_in">size</span>() &lt;&lt; endl; <span class="comment">//output:5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="迭代器的相应型别"><a href="#迭代器的相应型别" class="headerlink" title="迭代器的相应型别"></a>迭代器的相应型别</h2><p>在算法中运用迭代器很可能会用到其相应型别，即：迭代器所指之物便是其中之一。<br>如果我们在算法中想要声明一个变量，以”迭代器所指对象的型别”为型别，改怎么办？毕竟C++只支持sizeof(),并不支持typeof()!即便是动用RTTI性质中的typeid(),获得的也只是型别名称，不能拿来做变量声明之用。<br>解决办法是利用<code>function template</code>的参数推导机制：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">I</span>,<span class="title">class</span> <span class="title">Y</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">func_impl</span>(<span class="title">I</span> <span class="title">iter</span>, <span class="title">T</span> <span class="title">t</span>) &#123;</span></span><br><span class="line">    T tmp;<span class="comment">//这里解决了问题，T就是所指之物的型别，本例为int</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">I</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span></span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">func</span>(<span class="title">I</span> <span class="title">iter</span>) &#123;</span></span><br><span class="line">    func_impl(iter,*iter);<span class="comment">//func的全部工作移往func_imp1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    func(&amp;i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>我们以func()为对外接口，却把实际操作全部置于func_impl()之中。由于func_impl()是一个function template，一旦被调用，编译器会自动进行template参数推导。于是导出型别T，顺利解决问题</strong></p><p>常用的迭代器相应型别有五种，且并非任何情况下任何一种都可利用上述的template参数推导机制来取得。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;这两天在家里没有好好读书，要反思一下。今天看《STL源码剖析》到了迭代器iterator这里&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;什么是迭代器&quot;&gt;&lt;a href=&quot;#什么是迭代器&quot; class=&quot;headerlink&quot; title=&quot;什么是迭代器&quot;&gt;&lt;/a&gt;什么是迭代器&lt;/h2&gt;&lt;p&gt;在《Design Patterns》中对迭代器模式的描述如下：&lt;font color=&quot;#DC143C&quot;&gt;提供一种方法，使之能够依序寻访某个聚合物（容器）所含的各个元素，而又无需暴露该聚合物内部表现方式&lt;/font&gt;
    
    </summary>
    
      <category term="面试" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>2018-02-10</title>
    <link href="http://yoursite.com/2018/02/10/2018-02-10/"/>
    <id>http://yoursite.com/2018/02/10/2018-02-10/</id>
    <published>2018-02-10T14:38:47.000Z</published>
    <updated>2018-02-10T14:55:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>昨天晚上，确切的说是今天凌晨1：00钟她给我发来微信告诉我一件事情，她觉得每次和我聊天都会提到小胖子（她的前男友）对我来说很不公平。<a id="more"></a></p><p>做为当事人的我虽然正处于追求她的过程中，在和她聊天的时候冷不丁得提到她和小胖子的故事我的内心很难受，我不知道自己该做一些什么才能占有她内心的那些位置从而代替小胖子，但是她每次一提起他，我就感觉到了一丝甜蜜，一丝不舍，一丝难以忘怀。我聊不下去了，强忍着空白的大脑发出一条看似没有什么情绪的信息结束了对话。</p><p>然后我感觉到了她应该感觉到了我的情绪的变化，她发了一条朋友圈，她对自己很自责。直到凌晨1：00，她给我发了一条信息，提到了上文说的不公平。我内心瞬间澎湃汹涌，我知道她在乎我了，她愿意在乎我的情绪，愿意将自己最真实的内心分享给我。我们从天空的星座聊到夏日野外的交响乐，听她甜美的声音，莫名得无比得开心！和她聊天有一种从来没有过的轻松，一种自然的幽默感，虽然了解还不够深刻，但是我仍然感觉对她的了解一点点得增多。知道了她所要表达的思想，这对我来说很是鼓舞。喜欢她，就应该包容她，因为她也在用心得想要了解我，让自己接受我。</p><p>情人节的礼物又改了三遍，文字搭配好费劲，想要让她看明白同时更加开心，真的得好好付出！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;昨天晚上，确切的说是今天凌晨1：00钟她给我发来微信告诉我一件事情，她觉得每次和我聊天都会提到小胖子（她的前男友）对我来说很不公平。
    
    </summary>
    
      <category term="日记" scheme="http://yoursite.com/categories/life/"/>
    
    
  </entry>
  
  <entry>
    <title>C++开发面试问题准备：剑指 offer--二叉树的镜像和顺时针打印矩阵</title>
    <link href="http://yoursite.com/2018/02/08/C-%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E5%87%86%E5%A4%87%EF%BC%9A%E5%89%91%E6%8C%87-offer-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F%E5%92%8C%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5/"/>
    <id>http://yoursite.com/2018/02/08/C-面试问题准备：剑指-offer-二叉树的镜像和顺时针打印矩阵/</id>
    <published>2018-02-08T09:31:05.000Z</published>
    <updated>2018-02-08T11:24:22.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="二叉树的镜像"><a href="#二叉树的镜像" class="headerlink" title="二叉树的镜像"></a>二叉树的镜像</h2><blockquote><p>题目描述：完成一个函数，输入一个二叉树，该函数输出它的镜像</p></blockquote><p>如图：</p><p><img src="/images/treeMirror.jpg" alt="二叉树镜像">    <a id="more"></a></p><p>我们需要总结自己的解题步骤，尝试一下，将该二叉树的根结点的左右子节点进行交换，得到了如下图的结果</p><p>这个时候发现还不是镜像，因为两个根结点子节点之后还有节点，那么也需要交换该子节点的位置。</p><p>综上可得顺序如下：</p><p><img src="/images/tree2.jpg" alt="二叉树镜像"></p><p>那么我们便可以总结求一棵树的镜像的过程：<strong><font color="#DC143C">先序遍历这棵树的每个结点，如果遍历到的结点有子结点，就交换子结点。</font></strong></p><p>代码如下：<br><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">struct treeNode &#123;</span><br><span class="line">    int value;</span><br><span class="line">    struct treeNode* <span class="built_in">left</span>;</span><br><span class="line">    struct treeNode* <span class="built_in">right</span>;</span><br><span class="line">&#125;</span><br><span class="line">//递归解法</span><br><span class="line">void mirrorRecursively(treeNode * pNode) &#123;</span><br><span class="line">    <span class="keyword">if</span> (pNode == NULL |<span class="type">| (pNode</span> -&gt; <span class="built_in">left</span> == NULL &amp;&amp; pNode -&gt; <span class="built_in">right</span> == NULL))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    treeNode *temp = pNode -&gt; <span class="built_in">left</span>;</span><br><span class="line">    pNode -&gt; <span class="built_in">left</span> = pNode -&gt; <span class="built_in">right</span>;</span><br><span class="line">    pNode -&gt; <span class="built_in">right</span> = temp;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (pNode -&gt; <span class="built_in">left</span>)</span><br><span class="line">        mirrorRecursively(pNode -&gt; <span class="built_in">left</span>);</span><br><span class="line">    <span class="keyword">if</span> (pNode -&gt; <span class="built_in">right</span>)</span><br><span class="line">        mirrorRecursively(pNode -&gt; <span class="built_in">right</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//非递归解法,利用栈实现遍历</span><br><span class="line">void mirrorNonRecursively(treeNode * pNode) &#123;</span><br><span class="line">    <span class="keyword">if</span> (pNode == NULL |<span class="type">| (pNode</span> -&gt; <span class="built_in">left</span> == NULL &amp;&amp; pNode -&gt; <span class="built_in">right</span> == NULL))</span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">    stack &lt;treeNode *&gt; s;</span><br><span class="line">     while(pNode |<span class="type">| !s</span>.empty()) &#123;</span><br><span class="line">        while(pNode) &#123;</span><br><span class="line">            s.push(pNode);</span><br><span class="line">            pNode = pNode -&gt; <span class="built_in">left</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pNode = s.<span class="built_in">top</span>();</span><br><span class="line">        s.pop();</span><br><span class="line">        //先从叶子结点进行交换</span><br><span class="line">        <span class="keyword">if</span> (pNode -&gt; <span class="built_in">right</span> |<span class="type">| pNode</span> -&gt; <span class="built_in">left</span>) &#123;</span><br><span class="line">             treeNode *temp = pNode -&gt; <span class="built_in">left</span>;</span><br><span class="line">             pNode -&gt; <span class="built_in">left</span> = pNode -&gt; <span class="built_in">right</span>;</span><br><span class="line">             pNode -&gt; <span class="built_in">right</span> = temp;</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="顺时针打印矩阵"><a href="#顺时针打印矩阵" class="headerlink" title="顺时针打印矩阵"></a>顺时针打印矩阵</h2><blockquote><p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。</p></blockquote><p>如下矩阵：</p><p><img src="/images/matrix.jpg" alt=""></p><p>则一次打印出来的顺序为：1，2，3，4，8，12，16，15，14，13，9，5，6，7，11，10</p><p>我们可以找到打印的规律，将矩阵想象成若干个圈，可以用循环来打印，每次打印矩阵的一个圈就可以。如下图：</p><p><img src="/images/matrix2.jpg" alt=""></p><p>这个时候我们分析循环结束的条件，打印第一圈左上角的坐标为（0,0)，第二圈左上角的坐标为（1,1），依次类推第n圈坐标为（n,n）。我们可以取左上角坐标为（start，start）为一圈的分析目标。</p><p>我们能够发现对于一个5 X 5的矩阵而言，最后一圈只有一个数字，坐标为（2，2）。我们发现5 &gt; 2 <em> 2.对于一个6 X 6的矩阵而言，最后一圈有四个数字，左上角坐标仍为（2，2），显然满足6 &gt; 2 </em> 2.同样对于一个7 X 7的矩阵而言，最后一圈有一个数字，坐标为(3,3)，满足7 &gt; 3 * 2.</p><p>于是我们可以得出结论，让循环继续的条件是rows &gt; startX <em> 2且columns &gt; startY </em> 2.</p><p>则可以用以下代码循环打印一圈矩阵：</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void printMatrix(<span class="built_in">int</span> ** numbers, <span class="built_in">int</span> <span class="built_in">rows</span>, <span class="built_in">int</span> <span class="built_in">columns</span>) &#123;</span><br><span class="line">    <span class="built_in">if</span> (numbers == NULL || <span class="built_in">columns</span> &lt;= <span class="number">0</span> || <span class="built_in">rows</span> &lt;= <span class="number">0</span>)</span><br><span class="line">        return ;</span><br><span class="line">    <span class="built_in">int</span> start = <span class="number">0</span>;</span><br><span class="line">    while(start * <span class="number">2</span> &lt; <span class="built_in">rows</span> &amp;&amp; start * <span class="number">2</span> &lt; <span class="built_in">columns</span>) &#123;</span><br><span class="line">        printMatrixInCircle(numbers, <span class="built_in">rows</span>,<span class="built_in">columns</span>,start);</span><br><span class="line">        ++ start;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来考虑如何打印一圈的矩阵，我们可以将打印分为四部分，即四种打印情况：从左到右，从上到下，从右到左，从下到上。如图：</p><p><img src="/images/matrix1.jpg" alt=""></p><p>第一步打印肯定有，即从左到右。要想拥有第二步打印，即从上到下，那么必须满足终止行号大于起始行号。要想拥有第三步，从右到左打印，那么必须满足两个条件：终止行号大于起始行号、终止列号大于起始列号。要想拥有第四步，从下到上打印，当前矩阵至少有三行两列，需要满足：终止列号大于起始列号、终止行号大于（起始行号-1）。</p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printMatrixInCircle</span><span class="params">(<span class="keyword">int</span> ** numbers,<span class="keyword">int</span> rows,<span class="keyword">int</span> columns,<span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> endX = rows - <span class="number">1</span> - start;<span class="comment">//终止行号</span></span><br><span class="line">    <span class="keyword">int</span> endY = columns - <span class="number">1</span> - start;<span class="comment">//终止列号</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//从左到右</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = start;i &lt;= endY; ++ i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>,numbers[start][i]);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//从上到下</span></span><br><span class="line">    <span class="keyword">if</span> (start &lt; endX)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start;i &lt;= endX; ++ i)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d"</span>,numbers[i][endY]);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//从右到左</span></span><br><span class="line">    <span class="keyword">if</span> (start &lt; endX &amp;&amp; start &lt; endY)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = endY;i &gt;= start; -- i)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d"</span>,numbers[endX][i]);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//从下到上</span></span><br><span class="line">    <span class="keyword">if</span> (start &lt; endX - <span class="number">1</span> &amp;&amp; start &lt; endY)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = endX; i &gt;= start; -- i)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d"</span>,numbers[i][start]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体测试实现这里就不多说了，相信大家读懂思路之后代码就是顺手拈来！</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;二叉树的镜像&quot;&gt;&lt;a href=&quot;#二叉树的镜像&quot; class=&quot;headerlink&quot; title=&quot;二叉树的镜像&quot;&gt;&lt;/a&gt;二叉树的镜像&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;题目描述：完成一个函数，输入一个二叉树，该函数输出它的镜像&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/treeMirror.jpg&quot; alt=&quot;二叉树镜像&quot;&gt;
    
    </summary>
    
      <category term="面试" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++开发面试问题准备：源程序编译过程以及静态链接和动态链接的区别</title>
    <link href="http://yoursite.com/2018/02/07/C-%E5%BC%80%E5%8F%91%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E5%87%86%E5%A4%87%EF%BC%9A%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5%E5%92%8C%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5/"/>
    <id>http://yoursite.com/2018/02/07/C-开发面试问题准备：静态链接和动态链接/</id>
    <published>2018-02-07T04:44:33.000Z</published>
    <updated>2018-02-07T09:36:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>在Linux下我们用GCC对源码进行编译，编译的过程中有一个步骤是链接。这里我们先了解一下编译的过程，我在xmind中画的一个图如下，对软件不够熟悉，所以画得比较丑。</p><p><img src="/images/Compile&amp;&amp;Linking.png" alt="编译过程"></p><p>大体分为一下几个步骤：</p><ul><li>预处理（Preprocess）</li><li>编译(Complication)</li><li>汇编(Assembly)</li><li>链接(Linking)</li><li>执行(Execute)<a id="more"></a><h2 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a><strong>预处理</strong></h2></li></ul><p>首先源码文件（.c/.cpp）和相关头文件(.h)被预处理器与编译成(.i)文件，大家可以在终端下输入：</p><p><code>gcc -E hello.cpp -o hello.i</code></p><p><code>hello.i</code>就是预编译之后的源码文件。</p><p>预处理主要是进行一下几个过程：</p><ul><li>将所有的<code>#define</code>删除，并在程序中展开调用该宏的代码</li><li>处理所有的条件编译指令（该指令的作用：<strong>防止头文件的重复包含和编译，即编译的时候只编译<code>#if</code>与<code>#endif</code>之间的代码</strong>），如#if ,#ifdef</li><li>处理<code>#include</code>包含指令，将被包含的文件插入到该预编译指令的位置，该过程是递归进行的，被包含的文件可能还包含其他文件。</li><li>删除所有的注释\\和\<em>…\</em>\</li><li>添加行号和文件标识，如#2 “hello.c” 2,以便于编译时编译器产生调试用的行号信息及用于编译时产生编译错误或警告时能够显示行号信息</li><li>保留所有的#pragma编译器指令，因为编译器须要使用它们</li></ul><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a><strong>编译</strong></h2><p>编译的过程就是编译器进行一系列的词法分析下、语法分析、语义分析及优化后生成的汇编代码。可以在终端输入以下代码进行编译：</p><p><code>gcc –S hello.i –o hello.s</code></p><p>或者从源文件直接生成汇编代码</p><p><code>gcc –S hello.c –o hello.s</code></p><p>编译主要进行的以下几个过程内容为：</p><ul><li>词法分析：<font color="#DC143C"> 输入源程序，对构成源程序的字符串进行扫描和分解，识别出一个个的单词（亦称单词符号或简称符号），如基本字（begin、end、if、for、while），标识符、常数、运算符和界符（标点符号、左右括号）</font></li><li>语法分析：<font color="#DC143C"> 在词法分析的基础上，根据语言的语法规则，把单词符号串分解成各类语法单位（语法范畴），如“短语”、“句子”、“程序段”和“程序”等。通过语法分析，确定整个输入串是否构成语法上正确的“程序”。</font></li><li>语义分析（加中间代码生成）：<font color="#DC143C"> 对每种语法范畴进行语义i安插，例如，变量是否定义、类型是否正确等等。如果语义正确，则进行另一方面工作，即进行中间代码的解释。这一阶段所依循的是语言的语义规则。通常使用属性文法描述语义规则</font></li><li>汇编代码生成（一般在这之前还有一个优化的过程：依赖程序的等价变换规则，主要进行：公关子表达式的提取、循环优化、删除无用代码等）：<font color="#DC143C">把中间代码（或经优化处理之后）变换成特定机器上的低级语言代码,一般就是变成汇编代码</font></li></ul><h2 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a><strong>汇编</strong></h2><p>汇编就是将汇编代码转变成机器可以执行的命令，生成目标文件（.o），汇编器as根据汇编指令和机器指令的对照表一一翻译即可完成。可以在终端输入以下代码进行汇编文件的生成：</p><p><code>gcc –c hello.s –o hello.o</code></p><p>或者由源文件生成汇编代码：</p><p><code>gcc –c hello.c –o hello.o</code></p><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a><strong>链接</strong></h2><p>链接就是链接器ld将各个目标文件组装在一起，解决符号依赖，库依赖关系，并生成可执行文件。可以在终端输入以下命令进行链接：</p><p><code>ld –static crt1.o crti.o crtbeginT.o hello.o –start-group –lgcc –lgcc_eh –lc-end-group crtend.o crtn.o</code></p><blockquote><p>关于动态链接和静态链接的区别如下：</p></blockquote><p><strong><font color="#00FFFF">静态链接：</font></strong></p><font color="#00FFFF">在生成可执行文件的时候(链接阶段)，把所有需要的函数的二进制代码都包含到可执行文件中去。因此，链接器需要知道参与链接的目标文件需要哪些函数，同时也要知道每个目标文件都能提供什么函数，这样链接器才能知道是不是每个目标文件所需要的函数都能正确地链接。如果某个目标文件需要的函数在参与链接的目标文件中找不到的话，链接器就报错了。目标文件中有两个重要的接口来提供这些信息：一个是符号表，另外一个是重定位表</font><font color="#DC143C">核心思想：将不同的可重定位模块打包成一个文件，在链接的时候会自动从这个文件中抽取出用到的模块</font><ul><li>优点：在程序发布的时候就不需要的依赖库，也就是不再需要带着库一块发布，程序可以独立执行</li><li>缺点：<ol><li>程序体积会相对大一些</li><li>如果静态库有更新的话，所有可执行文件都得重新链接才能用上新的静态库,不够灵活</li></ol></li></ul><p><strong><font color="#00FFFF">动态链接：</font></strong></p><font color="#00FFFF">在编译的时候不直接拷贝可执行代码，而是通过记录一系列符号和参数，在程序运行或加载时将这些信息传递给操作系统，操作系统负责将需要的动态库加载到内存中，然后程序在运行到指定的代码时，去共享执行内存中已经加载的动态库可执行代码，最终达到运行时连接的目的</font><font color="#DC143C">核心思想是：代码共享和延迟绑定</font><ul><li>优点：多个程序可以共享同一段代码，而不需要在磁盘上存储多个拷贝</li><li>缺点：由于是运行时加载，可能会影响程序的前期执行性能</li></ul><p><strong><font color="#00FFFF">库：</font></strong><br>一些功能代码经过编译连接后的可执行形式</p><ul><li>静态lib将导出声明和实现都放在lib中。编译后所有代码都嵌入到宿主程序。</li><li>动态lib相当于一个h文件，是对实现部分（.dll文件）的导出部分的声明。编译后只是将导出声明部分编译到宿主程序中，运行时候需要相应的dll文件支持。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在Linux下我们用GCC对源码进行编译，编译的过程中有一个步骤是链接。这里我们先了解一下编译的过程，我在xmind中画的一个图如下，对软件不够熟悉，所以画得比较丑。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/Compile&amp;amp;&amp;amp;Linking.png&quot; alt=&quot;编译过程&quot;&gt;&lt;/p&gt;
&lt;p&gt;大体分为一下几个步骤：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;预处理（Preprocess）&lt;/li&gt;
&lt;li&gt;编译(Complication)&lt;/li&gt;
&lt;li&gt;汇编(Assembly)&lt;/li&gt;
&lt;li&gt;链接(Linking)&lt;/li&gt;
&lt;li&gt;执行(Execute)
    
    </summary>
    
      <category term="面试" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>2018-02-06</title>
    <link href="http://yoursite.com/2018/02/07/2018-02-06/"/>
    <id>http://yoursite.com/2018/02/07/2018-02-06/</id>
    <published>2018-02-07T00:53:21.000Z</published>
    <updated>2018-02-07T09:52:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近在制作一个小的电子相册，是关于我知道有限的糖永永的回忆，想要送给她做情人节礼物。知道她喜欢皮卡丘，很喜欢小王子，但我觉得如果送给她的礼物没有我加入的成分就不够真诚，就可俗了。</p><p>第一步（素材准备）：从她给我发的照片以及她的朋友圈中分析让她印象深刻的回忆，然后以时间为标签保存下来，真的是素材太少了 <a id="more"></a></p><p>第二步（AE模版准备）：这里可以去网站<a href="http://www.newcger.com" target="_blank" rel="noopener">新CG儿</a>找自己想要原型。翻看了有近500个模版，真的是感觉没有一个适合她的，她喜欢脑洞比较大的，且又柔和得表达方式。最后实在没办法就选择了一个较为柔和又有点脑洞的模版，哎，谁怪自己能力不够，只能依赖别人。这是我最后确定的模版<a href="https://pan.baidu.com/s/1eTccflC" target="_blank" rel="noopener">自由飞翔的照片</a>  密码:quj0。</p><p>第二步（制作环境准备）：很多人倒在了这一步上</p><ul><li><p>电脑环境 （AE是adobe的大型特效制作软件，自身有很多的插件，所以非常耗费内存）最好i5以上CPU，840以上显卡，空余缓存50G以上。当然我用的是MPR，但是还是卸载了一大批软件才将它成功装上，不然会一直显示缓存不足，无法正常运行该软件</p></li><li><p>软件环境：这里推荐一些我搜集的破解软件包以及破解方式。MAC用户建议直接去博客<a href="http://www.sdifen.com" target="_blank" rel="noopener">史提芬周的博客</a>中找一找，他会提供软件包以及破解方式，不过版本都是2017。windows 用户可以下载<a href="https://pan.baidu.com/s/1hugXXOg" target="_blank" rel="noopener">adobe软件for Windows</a>提取密码:qtjo。其中有破解包，下载运行就可以，虽然软件版本是2015CC的，可以用，我因为非本专业所以找的时候没有这么用心。安装好之后如果是中文版，在我导入所用的模版之后会出现slider属性缺失，这是一个很严重的问题，即模版里面用到的效果没有办法在你的软件上使用。最后经过GOOGLE以及百度的帮助发现是版本的问题，我选择安装的时候是中文版，但是模版制作是在英文版环境下制作的，所以会有部分属性不匹配。我选择最简洁的方式，卸载重装，反复了5次，最后总算不显示问题了。</p></li></ul><p>装好之后的界面是这样子的：</p><p><img src="/images/buffer/roukou.png" alt="启动界面"></p><p><img src="/images/buffer/jiemian.png" alt="配置好的制作界面"></p><p>即什么错误也没有显示</p><ul><li>具体的置放素材的位置如下：</li></ul><p><img src="/images/buffer/step1.png" alt="step1"></p><p><img src="/images/buffer/step2.png" alt="step2"></p><p><img src="/images/buffer/step3.png" alt="step3"></p><p><img src="/images/buffer/step4.png" alt="step4"></p><p>相信上面的英文都不难理解，当然过程中是根据个人模版应用情况更改，我还需要尽可能按照时间发展的顺序来进行照片排版。还有很多细节上的显示问题需要更改，希望到时候她看到这个相册能够开心一点呀，我就知足了。这是最后结果展示<a href="https://pan.baidu.com/s/1qZff4tu" target="_blank" rel="noopener">TYYPhoto</a>密码:20ex</p><p>不过最近我得抓紧提升自己基础了，开学之后就要抓紧找工作，这是当务之急，一定要和她在一个城市。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在制作一个小的电子相册，是关于我知道有限的糖永永的回忆，想要送给她做情人节礼物。知道她喜欢皮卡丘，很喜欢小王子，但我觉得如果送给她的礼物没有我加入的成分就不够真诚，就可俗了。&lt;/p&gt;
&lt;p&gt;第一步（素材准备）：从她给我发的照片以及她的朋友圈中分析让她印象深刻的回忆，然后以时间为标签保存下来，真的是素材太少了
    
    </summary>
    
      <category term="日记" scheme="http://yoursite.com/categories/life/"/>
    
    
  </entry>
  
  <entry>
    <title>C++面试问题准备：面向对象的基本原则</title>
    <link href="http://yoursite.com/2018/02/04/C-%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E5%87%86%E5%A4%87%EF%BC%9A%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E5%88%99/"/>
    <id>http://yoursite.com/2018/02/04/C-面试问题准备：面向对象的基本原则/</id>
    <published>2018-02-04T13:47:31.000Z</published>
    <updated>2018-02-06T15:15:01.000Z</updated>
    
    <content type="html"><![CDATA[<p>关于面向对象的五个基本原则：</p><ul><li>单一职责原则</li><li>开放封闭原则</li><li>Liskov替换原则</li><li>依赖导致原则</li><li>接口隔离原则<a id="more"></a></li></ul><h3 id="单一职责原则（Single-Resposibility-Principle）"><a href="#单一职责原则（Single-Resposibility-Principle）" class="headerlink" title="单一职责原则（Single-Resposibility Principle）"></a>单一职责原则（Single-Resposibility Principle）</h3><ul><li>一个类应该仅有一个引起它变化的原因(最简单，最容易理解却最不容易做到的一个设计原则)</li></ul><p>单一职责原则可以看做是低耦合、高内聚在面向原则上的引申，以提高内聚性来减少引起变化的原因</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//加法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Add</span> : <span class="title">JiSuanQi</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Add</span>(<span class="params"><span class="keyword">int</span> n1,<span class="keyword">int</span> n2</span>) : <span class="title">base</span>(<span class="params">n1,n2</span>)</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">double</span> <span class="title">JiSuan</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.Number1 + <span class="keyword">this</span>.Number2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//减法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Sub</span> : <span class="title">JiSuanQi</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Sub</span>(<span class="params"><span class="keyword">int</span> n1,<span class="keyword">int</span> n2</span>) : <span class="title">base</span>(<span class="params">n1,n2</span>)</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">double</span> <span class="title">JiSuan</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.Number1 - <span class="keyword">this</span>.Number2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>职员类例子：比如在职员类里，将工程师、销售人员、销售经理这些情况都放在职员类里考虑，其结果将会非常混乱，在这个假设下，职员类里的每个方法都要if else判断是哪种情况，从类结构上来说将会十分臃肿，并且上述三种的职员类型，不论哪一种发生需求变化，都会改变职员类！这个是大家所不愿意看到的！</p><h3 id="开放封闭原则（Open-Closed-principle）"><a href="#开放封闭原则（Open-Closed-principle）" class="headerlink" title="开放封闭原则（Open-Closed principle）"></a>开放封闭原则（Open-Closed principle）</h3><ul><li>软件实体应该是可扩展的，而不可修改的。也就是，对扩展开放，对修改封闭的。因为修改程序可能会造成错误，不能修改，但是可以添加新的功能</li></ul><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类似于上面的计算器，对于要添加的功能就添加一个类，然后只修改下面的switch就可以了</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> JiSuanQi <span class="title">GetJiSuanObject</span>(<span class="params"><span class="keyword">int</span> n1,<span class="keyword">string</span> czf,<span class="keyword">int</span> n2</span>) </span>&#123;</span><br><span class="line">    JiSuanQi jsq = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">switch</span>(czf) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"+"</span> :</span><br><span class="line">                jsq = <span class="keyword">new</span> Add(n1,n2);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"-"</span> :</span><br><span class="line">                jsq = <span class="keyword">new</span> Sub(n1,n2);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"/"</span> :</span><br><span class="line">                jsq = <span class="keyword">new</span> div(n1,n2);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> jsq;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Liskov替换原则（Liskov-Substituion-Principle）"><a href="#Liskov替换原则（Liskov-Substituion-Principle）" class="headerlink" title="Liskov替换原则（Liskov-Substituion Principle）"></a>Liskov替换原则（Liskov-Substituion Principle）</h3><ul><li>子类必须能够替换其基类</li></ul><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//上例中子类能够替换父类，而父类不能替换子类</span></span><br><span class="line">JisuanQi jsp=<span class="keyword">new</span> <span class="type">Add</span>(n1,n2);</span><br></pre></td></tr></table></figure><p>这一思想体现为对继承机制的约束规范，只有子类能够替换基类时，才能保证系统在运行期内识别子类，这是保证继承复用的基础</p><blockquote><p>如果子类不能完整实现父类的方法，或者父类的某些方法在子类中已经发生”畸变”，则建议断开父子继承关系，采用依赖、聚集、组合等关系代替继承。正如上面的基类JisuanQi，若我们要实现一个功能为模拟大数运算，则该类就无法继承计算器类，那么只能采用组合了</p></blockquote><p><strong>最佳实践：在项目中采用liskov替换原则时尽量避免子类的”个性”，一旦子类有”个性”，这个子类和父类之间的关系就很难调和了，把子类当作父类使用，子类的”个性”被抹杀；把子类单独作为一个业务来使用，则会让代码间的耦合关系变得破朔迷离。</strong></p><h3 id="依赖倒置原则（Dependecy-Inversion-Principle）"><a href="#依赖倒置原则（Dependecy-Inversion-Principle）" class="headerlink" title="依赖倒置原则（Dependecy-Inversion Principle）"></a>依赖倒置原则（Dependecy-Inversion Principle）</h3><ul><li>高层模块不应该依赖于底层模块，两者都应该依赖其<strong>抽象</strong></li><li>抽象不应该依赖细节</li><li>细节应该依赖抽象</li></ul><blockquote><p>即可以理解为面向接口编程</p></blockquote><p>采用依赖倒置原则可以减少类间的耦合性，提高系统的稳定性，减少并发引起的风险，提高代码的可读性和可维护性</p><h3 id="接口隔离原则（Interface-Segregation-Principle）"><a href="#接口隔离原则（Interface-Segregation-Principle）" class="headerlink" title="接口隔离原则（Interface-Segregation Principle）"></a>接口隔离原则（Interface-Segregation Principle）</h3><ul><li>使用多个小的专门的接口，而不要使用一个大的总接口</li></ul><p>就是每一个接口都执行一个专门的功能，用什么调什么。这样可以提高代码的灵活性，还可以降低类间的耦合性。提高稳定性。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关于面向对象的五个基本原则：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;单一职责原则&lt;/li&gt;
&lt;li&gt;开放封闭原则&lt;/li&gt;
&lt;li&gt;Liskov替换原则&lt;/li&gt;
&lt;li&gt;依赖导致原则&lt;/li&gt;
&lt;li&gt;接口隔离原则
    
    </summary>
    
      <category term="面试" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>2018-02-03</title>
    <link href="http://yoursite.com/2018/02/03/2018-02-03/"/>
    <id>http://yoursite.com/2018/02/03/2018-02-03/</id>
    <published>2018-02-03T14:58:20.000Z</published>
    <updated>2018-02-03T16:08:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天是个好日子，凌晨的时候陕西省的考研成绩陆续都出来啦，而我看到身边的同学都对自己的成绩很满意，内心真的替他们开心。一张舍友12：00还在奋笔疾书的照片：</p><p><img src="/images/tianci.jpg" alt=""><a id="more"></a></p><p>然而当我怀着忐忑的心情去问糖永永同学的成绩的时候，她没有回复。我有点慌，隔了20分钟，发现她还是没有回复！ 当时的情况是成绩已经出来了，依据我对她有限的了解她应该会去查成绩，而且会很开心又很忐忑得查，而且如果成绩好的话她肯定会主动告诉我并且大肆宣扬！可是没有消息，没有朋友圈，那她到底考得不好成什么样子了！</p><p>我有点不知所措，我不知道她在面对重大挫折的时候会是一种什么样子的心态，所以没有办法采取合适的安慰措施。天哪，瞬间感觉整个人都不好了，想给她打个语音电话，但是我嘴笨，万一她听不进去岂不是更加难过了～fucked</p><p>对了，可以去请教别人呀，现在同学应该睡了，认识的关系不错的女生也不是很多，只能去百度，知乎，微信读书得一些书友（情感类书籍读得多的）大肆提问。结合他们的看法最后自己想了一下，只能稳住她的情绪了。她还是没有回复～～～怀着沮丧的心情睡着了，不过又有点小庆幸（万一她还没查成绩呢，几率好小啊）</p><p>晚上做了一堆奇奇怪怪的梦，一条小鲤鱼，不对，应该是两条（其中有一条是糖同学，另一条不知道是谁），红白相间，在清澈的水里一直游，最后从一个什么东西给跳过去了。紧接着发现我自己在考研的考场，好像处于旁观者，在看大家答题，有一些人答着答着就哭了。紧接着我又来到了。。。（确切的说想不起来了）</p><p>早上6：00醒来一次，看了一次手机，她没回复，这下凉了，感觉她没这么脆弱呀，突然又感觉我对她一点也不了解了，又无比沮丧得睡着了。但是当我9：30再次醒来的时候，谢天谢地，我看到她无奈得信息，原来她还没查成绩，我感觉整个世界都亮了，就说嘛，许愿祈祷了那么多次神灵不会这么玩我的吧。但是瞬间有感觉自己怎么这么紧张，这么搞笑呀～ 我很好奇如果我自己考研查成绩有没有这么紧张呢，哎～～～～～～～～～  明天18：00见了</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天是个好日子，凌晨的时候陕西省的考研成绩陆续都出来啦，而我看到身边的同学都对自己的成绩很满意，内心真的替他们开心。一张舍友12：00还在奋笔疾书的照片：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/tianci.jpg&quot; alt=&quot;&quot;&gt;
    
    </summary>
    
      <category term="日记" scheme="http://yoursite.com/categories/life/"/>
    
    
  </entry>
  
  <entry>
    <title>2018-02-01</title>
    <link href="http://yoursite.com/2018/02/01/2018-02-01/"/>
    <id>http://yoursite.com/2018/02/01/2018-02-01/</id>
    <published>2018-02-01T11:33:08.000Z</published>
    <updated>2018-02-02T05:36:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天提着接近40公斤（25公斤的哑铃）的行李箱艰难回到了家，重点是在火车上一个无意识的打招呼，竟发现身边的年轻大哥是长安大学土木工程专业的研究生学长。<a id="more"></a>然后就与他相谈甚欢，从大学的点点滴滴到走上社会的艰难挫折，从行业发展到现在自身行业的举步维艰，学长给我讲了很多大学应该做的事情以及需要提升的能力。真的发现我们需要走的路还很长，每一步选择或多或少会对你的未来产生影响。不过还是像我的人生定位一样，珍惜所有，绝对专注，活在当下。</p><p>晚上和妹妹看了《小王子》电影，感触颇多，快乐其实很简单，只是随着年龄的增长我们选择去忘记而已，为了迎合社会的需求选择放弃内心的那份纯真。终于知道了为什么小永永同学对小王子是如此痴迷呢！</p><p>从明天开始就要进行素描学习，很期待一个月后自己的作品呢～</p><p>此外随着成绩出来时间的临近，真的很紧张，相信她的成绩一定很高呢，我的许的愿望一定能成功的！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天提着接近40公斤（25公斤的哑铃）的行李箱艰难回到了家，重点是在火车上一个无意识的打招呼，竟发现身边的年轻大哥是长安大学土木工程专业的研究生学长。
    
    </summary>
    
      <category term="日记" scheme="http://yoursite.com/categories/life/"/>
    
    
  </entry>
  
  <entry>
    <title>2018-01-31</title>
    <link href="http://yoursite.com/2018/01/31/2018-01-31/"/>
    <id>http://yoursite.com/2018/01/31/2018-01-31/</id>
    <published>2018-01-31T13:57:56.000Z</published>
    <updated>2018-01-31T14:27:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天是2018年1月的最后一天，而今天有一场月全食。其实有的时候人最幸福的事情就是有一个可以共享快乐的人，看着月亮一点一点被地球的太阳折射投影覆盖，变成一轮红月亮，过程真的很神奇，这里是一个关于此次超级蓝月和月全食的描述文章<a href="http://www.shangc.net/news/2018/0131/00222673.html" target="_blank" rel="noopener">月全食</a>.<a id="more"></a>虽然她看不到有点可惜呀,不过当看到银白色的月光完全被覆盖的时候，我双手合十，用尽全身念力吸引宇宙能量的到来。</p><p>听说在这样的时刻许愿特别灵，而她看不到，给我了一个特权来帮她许愿。嗯嗯，哈哈，那我就许了第一个呢～</p><ul><li>希望糖永永同学能够取得一个满意的超级超级好的好成绩</li></ul><p>第二个～</p><ul><li>希望能够永远看着这个姑娘永远开开心心呢^_^</li></ul><p><img src="/images/yongyong/farPhoto.jpg" alt=""></p><p><img src="/images/yongyong/close.jpg" alt=""></p><p><img src="/images/yongyong/closePhoto.jpg" alt=""></p><p>她今天包饺子，然后给我看她的成果：</p><p><img src="/images/yongyong/jiaozi.jpg" alt=""></p><p>呐，我看了第一眼，吓我一跳，这饺子吃起来肯定特别累，隔着屏幕还是想尝一尝，她说特好吃。虽然外貌长得有点肥大，应该理解，毕竟从下午五点多就开始准备了，她包饺子的次数不多。不过说实话，我感觉我包的饺子肯定比她的好看，嘿嘿～ </p><p>明天就要回家啦，带回去了两个哑铃，我的素描装备，还有几本专业书，有点重，不过还好！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天是2018年1月的最后一天，而今天有一场月全食。其实有的时候人最幸福的事情就是有一个可以共享快乐的人，看着月亮一点一点被地球的太阳折射投影覆盖，变成一轮红月亮，过程真的很神奇，这里是一个关于此次超级蓝月和月全食的描述文章&lt;a href=&quot;http://www.shangc.net/news/2018/0131/00222673.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;月全食&lt;/a&gt;.
    
    </summary>
    
      <category term="日记" scheme="http://yoursite.com/categories/life/"/>
    
    
  </entry>
  
  <entry>
    <title>C++面试问题准备：const和static关键字</title>
    <link href="http://yoursite.com/2018/01/31/C-%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E5%87%86%E5%A4%87%EF%BC%9Aconst%E5%92%8Cstatic%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <id>http://yoursite.com/2018/01/31/C-面试问题准备：const和static关键字/</id>
    <published>2018-01-31T01:51:41.000Z</published>
    <updated>2018-02-11T12:54:16.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="常量-（const）"><a href="#常量-（const）" class="headerlink" title="常量 （const）"></a>常量 （const）</h2><ul><li><p>const类型值不能被修改，这里指的是const修饰的内容不能被修改，且const修饰的常量在超出其作用域之后会被释放 <a id="more"></a></p></li><li><p>在类中：const数据成员只在某个对象生存期是常量，而类可以创建很多的对象，所以不同对象类的const数据成员是可以不同的.</p></li><li><p>在类中：const数据成员的初始化只能在类的构造函数的初始化列表中进行。因为类的对象没有被创建时，编译器是不知道const数据成员的值是什么。</p></li></ul><blockquote><p>这里针对常量指针(int *const p)、指针常量(const int * p)、指向常量的常量指针(const int * const p)之间的区别做一个描述</p></blockquote><p>阐述一个概念</p><p><strong>顶层const</strong> :表示指针本身是一个常量（我们知道指针代表的一个地址，即此时这个地址是const，不能改变）</p><p><strong>底层const</strong> :表示指针的指向是一个常量（此时我们知道指针代表的地址所指的内容是常量）</p><p>综上：</p><h4 id="const-int-p"><a href="#const-int-p" class="headerlink" title="const int* p"></a><strong>const int* p</strong></h4><p> 可以通过*来看p的修饰成分，此时<em>的右边没有限定成分，那p就是一个普通的指针。而\</em>的左边是<code>const int</code>，那么此时p的指向是一个常量，此时的const 是底层const.可以不用初始化</p><p> 同时我们可以通过改变其地址来改变其所指的内容，但是不能直接更改其所指的内容。</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt; </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> d = <span class="number">200</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>* p = &amp;i;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *p &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">p = &amp;d; <span class="comment">//只能通过修改p的指向来更改p的内容</span></span><br><span class="line">*p = d;<span class="comment">//error!read-only variable is not assignable</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *p &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line"><span class="number">100</span></span><br><span class="line"><span class="number">200</span></span><br></pre></td></tr></table></figure><h4 id="int-const-p"><a href="#int-const-p" class="headerlink" title="int* const p"></a><strong>int* const p</strong></h4><p>此时*号的左边是const,那么说明该指针p是一个常量指针，即p的指向的地址是不能变的，但是我们可以更改其地址的内容。此时const是顶层const,而顶层 const必须初始化（总不可能让常量指针变量存储的是一个空内容）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> d = <span class="number">200</span>;</span><br><span class="line"><span class="keyword">int</span>* <span class="keyword">const</span> p = &amp;i;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *p &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">*p = d;<span class="comment">//直接更改其指向地址的内容</span></span><br><span class="line"><span class="comment">// p = &amp;d;//不能更改其指向的地址 ERROR:ariable 'p' declared const here</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *p &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">output :</span><br><span class="line"><span class="number">100</span></span><br><span class="line"><span class="number">200</span></span><br></pre></td></tr></table></figure><h4 id="const-int-const-p"><a href="#const-int-const-p" class="headerlink" title="const int* const p"></a><strong>const int* const p</strong></h4><p>*左边和右边都有const ,那么这个常量指针指向的是一个常量，所以语法是前两者的结合，显然地址和值都无法更改，真正做到了常量！</p><h2 id="静态变量-static"><a href="#静态变量-static" class="headerlink" title="静态变量(static)"></a>静态变量(static)</h2><ul><li><p>在类中：static变量是属于类的，不属于某个对象，它在整个程序的运行过程中只有一个副本，因此不能在定义对象时 对变量进行初始化，就是不能用构造函数进行初始化。初始化时在类外：数据类型 类名::静态数据成员名=值；static 成员函数作为类作用域的全局函数，不能访问类的非静态成员，没有this指针，不能被声明为virtual</p></li><li><p>全局静态变量：作用域内的所有函数都可以调用，一般可以用来做多线程程序的控制。</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> i  = <span class="number">100</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    i ++;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">output :</span><br><span class="line"><span class="number">100</span></span><br><span class="line"><span class="number">101</span></span><br></pre></td></tr></table></figure><ul><li>局部静态变量：同样该变量的内存在编译时只被分配一次，到整个程序结束的时候释放</li></ul><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line">using namespace std<span class="comment">;</span></span><br><span class="line"><span class="built_in">int</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">int</span> i  = <span class="number">100</span><span class="comment">;</span></span><br><span class="line">    i ++<span class="comment">;</span></span><br><span class="line">    <span class="keyword">return</span> i<span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">int</span> main ()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> a = <span class="function"><span class="keyword">func</span><span class="params">()</span>;</span></span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl<span class="comment">;</span></span><br><span class="line">    a = <span class="function"><span class="keyword">func</span><span class="params">()</span>;</span></span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl<span class="comment">;</span></span><br><span class="line">    a = <span class="function"><span class="keyword">func</span><span class="params">()</span>;</span></span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl<span class="comment">;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span><span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line">output :</span><br><span class="line"><span class="number">101</span></span><br><span class="line"><span class="number">102</span></span><br><span class="line"><span class="number">103</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;常量-（const）&quot;&gt;&lt;a href=&quot;#常量-（const）&quot; class=&quot;headerlink&quot; title=&quot;常量 （const）&quot;&gt;&lt;/a&gt;常量 （const）&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;const类型值不能被修改，这里指的是const修饰的内容不能被修改，且const修饰的常量在超出其作用域之后会被释放
    
    </summary>
    
      <category term="C++" scheme="http://yoursite.com/categories/C/"/>
    
      <category term="面试" scheme="http://yoursite.com/categories/C/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++ 面试问题准备：内存分配的方式</title>
    <link href="http://yoursite.com/2018/01/30/C-%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E5%87%86%E5%A4%87%EF%BC%9A%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%9A%84%E6%96%B9%E5%BC%8F/"/>
    <id>http://yoursite.com/2018/01/30/C-面试问题准备：内存分配的方式/</id>
    <published>2018-01-30T12:16:57.000Z</published>
    <updated>2018-01-30T13:36:01.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="C-中常见内存分配及其存储区域有以下几种"><a href="#C-中常见内存分配及其存储区域有以下几种" class="headerlink" title="C++ 中常见内存分配及其存储区域有以下几种"></a>C++ 中常见内存分配及其存储区域有以下几种</h3><ul><li>堆分配</li><li>栈分配</li><li>自由存储区</li><li>静态存储区</li><li>常量存储区<a id="more"></a></li></ul><p>这里首先描述以下除了堆和栈的三种存储方式：</p><h4 id="自由存储区"><a href="#自由存储区" class="headerlink" title="自由存储区"></a>自由存储区</h4><p>这个存储区是单独为C++ 中<code>new</code>运算符提出来的，该存储区是<code>new</code>和<code>delete</code>动态分配和释放对象的抽象概念。在《STL 源码剖析中》自由存储区是利用allocate空间配置器进行STL操作对象的空间分配，通过allocate ,deallocate,construct,destroy进行空间的分配和释放。详细可以参考文章<a href="http://vigortyy.com/2018/01/27/C-开发面试准备：STL-allocator/" target="_blank" rel="noopener">STL allocator</a></p><blockquote><p>别将自由存储区与堆分配等价，堆是由操作系统进行维护的一片内存区域</p></blockquote><h4 id="静态存储区"><a href="#静态存储区" class="headerlink" title="静态存储区"></a>静态存储区</h4><p>全局变量和静态变量的存储是放在同一块区域，初始化的静态变量和全局变量在一块，未初始化的在另一块，程序运行结束后由系统自动释放。</p><h4 id="常量存储区"><a href="#常量存储区" class="headerlink" title="常量存储区"></a>常量存储区</h4><p>这是一块比较特殊的存储区，是固化在执行文件上的数据，里面存放的是常量，不允许被修改。</p><p><strong>接下来我们看看堆和栈的区别</strong></p><ol><li><p>内存分配：</p><p> 堆：一般由程序员分配释放，若程序员不释放，程序结束后会由操作系统进行释放（这里主要是指局部变量使用堆分配的方式）。它的分配方式类似与链表，常用的关键字是：malloc,free</p><p> 栈：由系统自动飞配，结束后系统自动释放（局部变量）</p></li><li><p>申请方式：</p><p> 堆：需要程序员自己申请，并指明大小。</p><p> 栈：系统自动分配</p></li><li><p>大小限制：</p><p> 堆：是向高地址扩展的数据结构，是不连续的内存区域。这是由于系统是用链表来存储的空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大</p><p> 栈：在Windows下, 栈是向低地址扩展的数据结构，是一块连续的内存的区域。栈的大小是固定的（是一个编译时就确定的常数），如果申请的空间超过栈的剩余空间时，将提示overflow。因此，能从栈获得的空间较小。</p></li><li><p>效率方面：</p><p> 堆：分配空间需要使用malloc以及用free释放，这个过程需要调用操作系统的函数，由操作系统通过一定的内存分配算法分配空间，最后才由汇编器翻译为指令执行，效率较低。但是会造成大量的内存碎片，如果不合理进行释放，会导致系统运行缓慢甚至崩溃</p><p> 栈：栈是机器系统的数据结构，由与在操作系统中有栈操作的指令，所以执行起来较快。</p></li><li><p>存放内容方面：</p><p> 堆：一般情况堆顶使用一个字节的空间来存放堆的大小，而堆中具体存放内容是由程序员来完成的</p><p> 栈：栈存放的内容，一般来说是函数地址和相关参数。</p><blockquote><p>这里关于在栈中，函数调用过程栈帧的变化大家可以参考这篇文章<a href="http://blog.csdn.net/qq_29403077/article/details/53205010" target="_blank" rel="noopener">函数调用过程栈帧变化详解</a>.<strong>总之就是将控制进行跳转，同时对于控制中用到的变量以及函数地址分配相应的栈空间。</strong></p></blockquote></li></ol><p>这里是一些外国人的博客对于堆栈的描述</p><p><a href="http://www.learncpp.com/cpp-tutorial/79-the-stack-and-the-heap/" target="_blank" rel="noopener">The stack and the heap</a></p><p><a href="https://salilkapur.wordpress.com/2013/04/11/stack-memory-vs-heap-memory-in-cc/" target="_blank" rel="noopener">STACK MEMORY VS HEAP MEMORY IN C/C++</a></p><p>个人感觉写的比较浅，当然常用到的主要区别都写到了</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;C-中常见内存分配及其存储区域有以下几种&quot;&gt;&lt;a href=&quot;#C-中常见内存分配及其存储区域有以下几种&quot; class=&quot;headerlink&quot; title=&quot;C++ 中常见内存分配及其存储区域有以下几种&quot;&gt;&lt;/a&gt;C++ 中常见内存分配及其存储区域有以下几种&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;堆分配&lt;/li&gt;
&lt;li&gt;栈分配&lt;/li&gt;
&lt;li&gt;自由存储区&lt;/li&gt;
&lt;li&gt;静态存储区&lt;/li&gt;
&lt;li&gt;常量存储区
    
    </summary>
    
      <category term="面试" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>2018-01-29</title>
    <link href="http://yoursite.com/2018/01/29/2018-01-29/"/>
    <id>http://yoursite.com/2018/01/29/2018-01-29/</id>
    <published>2018-01-29T12:14:13.000Z</published>
    <updated>2018-01-29T12:28:59.000Z</updated>
    
    <content type="html"><![CDATA[<p>天哪，这也太难了吧！—-为我的脑细胞默哀30秒<a id="more"></a></p><p>今天早上看了一早上的LSTM，对RNN结构终于有了点了解了（该模型也就是对序列化数据进行训练，训练过程是根据上一个的状态来对下一个状态产生影响，通过一系列的状态训练，得到它们结果的相关性，但是普通的RNN模型因为梯度爆炸（descent exploding）无法预测非上下文相关的数据，所以LSTM就出来啦），但是在看莫烦写代码的时候我就很痛苦，虽然是按照RNN模型的三个层来写的，但是就是看不懂中间的状态层的处理。看视频教程睡着了好几次，醒来继续看，然后又睡着了。这还没有上升到内部实现和程序设计上，现在还仅仅是平台应用都这么困难，以后可咋办呀！</p><p>下午又看了一下午的STL源码剖析，说实话，有点体会到了C++的复杂，泛型编程想要掌握真心不容易，模版机制用得也不是很熟练，看代码看得云里雾里。有一些地方侯捷老师讲得是真详细，而且看到了STL的实现代码真得已经上升到了艺术境界，不论是鲁棒性，安全性，可读性（这个是我的原因读不懂，就不说了）真心没得说。难是难了，但是不能就这么放弃，前辈们绞尽脑汁为我们创造的便利不能这么丢掉，一定要一点一点啃下来，到时候相信自己对C++整个语言以及编程思维都会有一个质的提升。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;天哪，这也太难了吧！—-为我的脑细胞默哀30秒
    
    </summary>
    
      <category term="日记" scheme="http://yoursite.com/categories/life/"/>
    
    
  </entry>
  
  <entry>
    <title>东方月初：你的梦想我帮你承担</title>
    <link href="http://yoursite.com/2018/01/28/%E4%B8%9C%E6%96%B9%E6%9C%88%E5%88%9D%EF%BC%9A%E4%BD%A0%E7%9A%84%E6%A2%A6%E6%83%B3%E6%88%91%E5%B8%AE%E4%BD%A0%E6%89%BF%E6%8B%85/"/>
    <id>http://yoursite.com/2018/01/28/东方月初：你的梦想我帮你承担/</id>
    <published>2018-01-28T04:16:20.000Z</published>
    <updated>2018-01-28T06:32:44.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="那一刻，你的背影如此高大"><a href="#那一刻，你的背影如此高大" class="headerlink" title="那一刻，你的背影如此高大"></a>那一刻，你的背影如此高大</h2><p><img src="/images/yongyong/beiying1.png" alt=""></p><p>我叫东方月初，是东方灵族的人， <a id="more"></a>因为我们血脉的原因导致我们家族的嫡系永远被人争抢，只为我们天生灵力且身怀灭妖神火。</p><p>而我很小的时候因为家族被灭成为了孤儿，整日在人类的贪婪之间东躲西藏。直到那天遇见了你。。。。。我被一气道盟追杀到了涂山，当时我身受重伤，我也道涂山是狐妖的地盘，是不允许人类踏足。我心怀忐忑，实在没法逃脱这些混蛋的追捕，只能选择到这里了。</p><p>在即将被他们抓走的那一刻，一个背影从我头上飘过，优雅、安静、那么高大。霎那间，整个世界都安静了，眼睛里只有你的背影。</p><h2 id="那一刻，我的眼泪里融化进了心里"><a href="#那一刻，我的眼泪里融化进了心里" class="headerlink" title="那一刻，我的眼泪里融化进了心里"></a>那一刻，我的眼泪里融化进了心里</h2><p><img src="/images/yongyong/liulei.png" alt=""></p><p>之后我死皮赖脸待在涂山，也很感谢你愿意收留我，原来你是涂山的妖王涂山红红，很开心认识了涂山的其他伙伴，还有雅雅姐和容容姐。结果没多长时间，一气道盟的人又来涂山，其中还有名震天下的金面火神，还是为了我的血脉。金面火神这个混蛋为了得到东方神脉，杀掉了他的师父也就是我们族长，自称正道，在人间混迹，道貌岸然的家伙！</p><p>经历了一番大战，你看到了他们对我血脉的渴望。他们甚至为了得到我要灭掉涂山，而你不仅没有将我交出去，还为了保护我做了一出戏：”从此世间再无，东方月初”。我是一个孤儿，母亲有限的爱早已随时间忘却，所以我从来没有体会过有人这样对我好，从来没有体会过那种被人无私保护的感觉。那一刻，我的眼泪融化进了心里，我爱上了你！</p><h2 id="那一刻，我的离开只为你的梦想"><a href="#那一刻，我的离开只为你的梦想" class="headerlink" title="那一刻，我的离开只为你的梦想"></a>那一刻，我的离开只为你的梦想</h2><p><img src="/images/yongyong/likai.png" alt=""></p><p>因为你的保护将东方月初从天下抹去，从此我可以在涂山快乐的生活了。想起来，那段时光应该是我一生中最为快乐的呢。当然我给自己定了一个小目标，哈哈，我要追你，反正就是喜欢你，不管在哪里都会想到你呢。所以用自己的方式想尽一切办法来让你开心，当然也是为了报答那份恩情。知道你怕灭妖神火，我用自己稀释了的血让你洗手，三个月后你终于不用担心纯质阳炎对你的伤害啦。</p><p>那一天情人节，我想给你一个惊喜，我要让你看到涂山最美的场景。让整个涂山的花都为你盛开，想到你看到这个场景的时候肯定被我感动得涕泗横流就很开心啊。直到我听到了你的对那个已经死去的人类的肺腑之言，后来也知道了你是给我说的。你因为对人类的偏见误杀了一个善良的人类，那种愧疚封闭了你的内心，你选择用自己的一生去实现一个理想：让人和妖在这个世界和平相处！而你也告诉了我，你在实现这个理想期间不会向任何人再展现自己内心的柔软。</p><p>听到这段话沉默了很久，我内心有点失落，可是我不愿意看到你因为愧疚，因为那份恩情就把自己画一个圈圈了起来，既然你不愿意跳出来，那我陪你一起钻进去。所以我选择离开，只有站在人类世界权利的最高峰我才能够有足够大的话语权，才能更好得帮助你，那么先从一气道盟开始吧！</p><p><img src="/images/yongyong/yongyuan.png" alt=""></p><h2 id="那一刻，我笑了"><a href="#那一刻，我笑了" class="headerlink" title="那一刻，我笑了"></a>那一刻，我笑了</h2><p><img src="/images/yongyong/xiangsishu.png" alt=""></p><p>从此我们陷入世俗的漩涡，但我知道我们都为了同一个梦想时时刻刻在努力。所以我们最后在别人眼里的自相残杀，其实只是更好得掩盖我们最后的目的。时光流逝，我希望用自己的方式打开你内心的那个心结，没有什么理由，没有什么目的，只是想看到你发自心底的笑。终于，我用自己顽强的意志与不懈的努力走进了你的内心，看到了你内心融化，我笑了，很开心。相思树下我们用虚空之泪做为转世续缘的定情信物，那个洁白流光如皓月般明亮的水珠将成为我们一生的回忆。</p><p><strong>相思树下，我们来世再见！</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;那一刻，你的背影如此高大&quot;&gt;&lt;a href=&quot;#那一刻，你的背影如此高大&quot; class=&quot;headerlink&quot; title=&quot;那一刻，你的背影如此高大&quot;&gt;&lt;/a&gt;那一刻，你的背影如此高大&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/images/yongyong/beiying1.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;我叫东方月初，是东方灵族的人，
    
    </summary>
    
      <category term="随笔" scheme="http://yoursite.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
  <entry>
    <title>C++面试问题准备：STL--allocator</title>
    <link href="http://yoursite.com/2018/01/27/C-%E5%BC%80%E5%8F%91%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87%EF%BC%9ASTL-allocator/"/>
    <id>http://yoursite.com/2018/01/27/C-开发面试准备：STL-allocator/</id>
    <published>2018-01-27T15:02:40.000Z</published>
    <updated>2018-02-11T12:54:16.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>最近在读侯捷老师的《STL源码剖析》，写写总结。他的STL主要是SGI 版本的，也就是我们常用的GCC编译器支持 <a id="more"></a></p></blockquote><h4 id="什么是allocator"><a href="#什么是allocator" class="headerlink" title="什么是allocator"></a>什么是allocator</h4><p>相信对C++感兴趣的伙伴肯定对STL这个模版库情有独钟，但是当站在STL的角度来看这些容器的实现那么第一个需要知道的就是allocator</p><p>allocator是空间适配器，即为STL容器产生的各种对象（所有的数值）分配存储空间的接口。</p><p>注意这里的存储空间指的并不一定是内存，还可以有硬盘哦！当然本章主要介绍的是allocator为STL配置内存空间。如果大家对allocator获取硬盘空间的方式感兴趣的话可以浏览该源码<a href="http://www.drdobbs.com/disk-based-container-objects/" target="_blank" rel="noopener">Disk-Based Container Objects</a>(这里需要翻墙，我是真没看懂，基础有点差)</p><h4 id="allocator-如何分配空间"><a href="#allocator-如何分配空间" class="headerlink" title="allocator 如何分配空间"></a>allocator 如何分配空间</h4><p>关于allocator 在STL中的规范接口大家可以参考文档<a href="http://zh.cppreference.com/w/cpp/memory/allocator" target="_blank" rel="noopener">allocator</a></p><p>其中SGI的默认allocator的源码可以参考<a href="https://afsws.rpi.edu/dept/acm/packages2/egcs/1.1.2/common/include/g++/defalloc.h" target="_blank" rel="noopener">defalloc.h</a></p><p>其中关于内存分配以及释放的源码如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">T</span>* <span class="title">allocate</span>(<span class="title">ptrdiff_t</span> <span class="title">size</span>, <span class="title">T</span>*) &#123;</span></span><br><span class="line">    set_new_handler(<span class="number">0</span>);</span><br><span class="line">    T* tmp = (T*)(::<span class="keyword">operator</span> <span class="keyword">new</span>((<span class="keyword">size_t</span>)(size * <span class="keyword">sizeof</span>(T)))); <span class="comment">//由全局操作符::operator new分配指定类型T大小的内存</span></span><br><span class="line">    <span class="keyword">if</span> (tmp == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">cerr</span> &lt;&lt; <span class="string">"out of memory"</span> &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">deallocate</span>(<span class="title">T</span>* <span class="title">buffer</span>) &#123;</span></span><br><span class="line">    ::<span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(buffer)</span></span>; <span class="comment">//由全局操作符::operator delete来释放类T的对象的内存</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们根据自己平时代码习惯，对内存的分配以及释放是以下的方式：<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class <span class="type">Foo</span><span class="meta">&#123;...&#125;</span></span><br><span class="line"><span class="type">Foo</span>* a = new <span class="type">Foo</span>;</span><br><span class="line">delete a;</span><br></pre></td></tr></table></figure></p><p>底层的new 分配方式是</p><ol><li>调用::operator new 配置内存</li><li>调用Foo::Foo()构造对象内容</li></ol><p>底层的delete分配方式是</p><ol><li>调用Foo::~Foo() 析构对象</li><li>调用::operator delete 释放内存</li></ol><blockquote><p>说到new ,简单说一下C++中new 和 malloc的区别<br><br><strong>1.new是C++的一种内存分配的关键字，malloc是C语言特有的内存非配函数，也可以为C++使用</strong><br><br><strong>2.new分配内存的大小由编译器来指定，即SGI 的GCC指定，开发者不需要考虑分配的大小计算。而malloc则需要显示计算大小</strong><br><br><strong>3.new会先调用operator new函数，申请足够的内存（通常底层使用malloc实现）。然后调用类型的构造函数，初始化成员变量，最后返回自定义类型指针。delete先调用析构函数，然后调用operator delete函数释放内存（通常底层使用free实现）</strong><br><br><strong>4.new 分配失败会返回bac_alloc异常，可由以上源码看出。而malloc分配失败会返回NULL</strong><br><br><strong>5.new可以被重载，malloc不允许</strong><br><br><strong>6.new分配的内存在自由存储区上，malloc分配的空间是在堆上，而堆是操作系统维护的一块特殊内存。</strong></p></blockquote><p>在SGI STL中默认的allocator，但是因为封装过于简单，没有考虑效率的强化，因为之后会说道trivial destructor(保证析构时候是执行释放内存的操作，而非无关痛痒的析构)，所以一般SGI会将以上的两个操作分开。</p><p>为了实现这个功能，STL标准规范 将以上总共四个操作分别封装在<code>alloc::allocate()</code>执行内存分配，<code>alloc::deallocate()</code> 执行内存释放，<code>::construct()</code>执行对象构造，<code>::destroy()</code>执行对象析构。</p><p>以上四个函数分别在以下两个文件：</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stl_alloc.h&gt;</span> //负责空间的分配和释放</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stl_construt.h&gt;</span> //负责对象的构造和析构，construc 和destroy是全局函数，所以调用的时候用::construct()</span></span><br></pre></td></tr></table></figure><h5 id="关于构造与析构的过程"><a href="#关于构造与析构的过程" class="headerlink" title="关于构造与析构的过程"></a>关于构造与析构的过程</h5><p>关于<a href="http://gcc.gnu.org/onlinedocs/gcc-4.9.0/libstdc++/api/a01502_source.html" target="_blank" rel="noopener">stl_construct.h的源码</a></p><p>在<code>&lt;stl_construct.h&gt;</code>中的构造的过程如下 </p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;new.h&gt;</span></span></span><br><span class="line"><span class="keyword">template</span> &lt;class T1,class T2&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> construct(T1 *p,<span class="keyword">const</span> T2&amp; value) &#123;</span><br><span class="line">    <span class="keyword">new</span> (p) T1(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重点是进行对象析构的操作</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对单指针对象进行析构</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="title">void_Destroy</span><span class="params">(_Tp* __pointer)</span></span>&#123;</span><br><span class="line">    __pointer-&gt;~_Tp(); &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//对两个指针进行析构，即参数接受两个迭代器，此时我们需要判断迭代器之间元素的数值型别，即是否执行有意义的析构，即释放会释放内存</span></span><br><span class="line"><span class="comment">//主要析构函数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">ForwardIterator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">destroy</span>(<span class="title">ForwardIterator</span> <span class="title">first</span>,<span class="title">ForwardIterator</span> <span class="title">last</span>) &#123;</span></span><br><span class="line">    _destroy(first,last,value_type(first))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断元素的数值型别 注意，这里的has_trivial_destructor可以对析构函数的执行是否有意义进行判断，采取不同的执行方式来提升析构效率</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">ForwardIterator</span>,<span class="title">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> _<span class="title">destroy</span>(<span class="title">ForwardIterator</span> <span class="title">first</span>,<span class="title">ForwardIterator</span> <span class="title">last</span>,<span class="title">T</span>*) &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> _type_traits&lt;T&gt;::has_trivial_destructor trivial_destructor;</span><br><span class="line">    _destroy_aux(first,last,trivial_destructor);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果元素的数值型别有non-trivial destructor</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">ForwardIterator</span>&gt;</span></span><br><span class="line"><span class="class">_<span class="title">destroy_aux</span>(<span class="title">ForwardIterator</span> <span class="title">first</span>,<span class="title">ForwardIterator</span> <span class="title">last</span>,_<span class="title">false_type</span>) &#123;</span> </span><br><span class="line">    <span class="keyword">for</span> (; first &lt; last; ++first)</span><br><span class="line">        destroy(&amp;*first); <span class="comment">//调用一个指针的析构函数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果元素的数值型别有trivial destructor （即此时执行的该对象的析构函数是无意义的，不释放任何内存）</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">ForwardIterator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> _<span class="title">destroy_aux</span>(<span class="title">ForwardIterator</span>,<span class="title">ForwardIterator</span>,_<span class="title">true_type</span>)&#123;</span>&#125; <span class="comment">//该函数什么也不做，不执行析构操作</span></span><br></pre></td></tr></table></figure><p>综上我们就很容易看出SGI STL的开发者们是真生得站在系统效率的角度上进行的开发，一切只为了安全快捷。</p><blockquote><p>大量的inline函数使得我们系统执行的效率更快，在函数体运行的时候inline函数会在函数体内展开，而不需要在去由编译器去保存函数内容以及实参到内存，从而降低系统效率。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;最近在读侯捷老师的《STL源码剖析》，写写总结。他的STL主要是SGI 版本的，也就是我们常用的GCC编译器支持
    
    </summary>
    
      <category term="C++" scheme="http://yoursite.com/categories/C/"/>
    
      <category term="面试" scheme="http://yoursite.com/categories/C/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++开发面试问题</title>
    <link href="http://yoursite.com/2018/01/26/C-%E5%BC%80%E5%8F%91%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2018/01/26/C-开发面试问题/</id>
    <published>2018-01-26T14:47:27.000Z</published>
    <updated>2018-01-30T12:17:30.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="语言基础"><a href="#语言基础" class="headerlink" title="语言基础"></a>语言基础</h4><ul><li>OOP（封装、继承、多态） + V func 的实现，V table 的原理</li><li>const static的各种情况，分清const pointer 和pointer to const以及两者合体的形式<a id="more"></a></li><li>内存泄漏 三条规则。注意exception safe和smart pointer（提到思想：谁拥有这个指针）的解决方式</li><li>STL 至少了解allocator，常用的一些容器以及其实现原理</li><li>rail 了解一下，用来做什么</li></ul><h4 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h4><ul><li>进程管理 <ol><li>什么是进程</li><li>什么是context switch（上下文相关），干什么会触发它</li><li>cost是什么</li><li>虚拟内存和物理内存是什么</li><li>进程竞争的条件</li></ol></li><li>文件系统<ol><li>MVC 了解</li><li>堆栈的区别，给一个程序，要能够画出内存里程序运行的经过</li><li>并发编程，了解.管道的概念</li><li>cpu cache的运作，为什么很多数据结构或算法很好，运行却很慢</li><li>动态链接和静态链接的优缺点</li><li>编译的过程，从complie到linking. 做的事情</li><li>如何避免环形依赖</li></ol></li></ul><h4 id="编程习惯"><a href="#编程习惯" class="headerlink" title="编程习惯"></a>编程习惯</h4><ul><li>敏捷开发要了解，至少知道过程中有那些阶段code review,以及测试流程</li><li>如何manage大型C++code,怎么分模块合理得继承，怎么分模块测试</li><li>template以及metaprogramming了解</li><li>现场写程序能加const就加const,小程序全inline,能传ref就传ref,开头一定要有哨兵#ifndef #define #endif</li><li>出手要有namespace</li><li>STL能用就用，tranform的使用以及自己会写comparator</li></ul><h4 id="基础数据结构以及算法—-《剑指-offer》《编程之美》《程序员面试指南》内容搞懂足够面对BAT"><a href="#基础数据结构以及算法—-《剑指-offer》《编程之美》《程序员面试指南》内容搞懂足够面对BAT" class="headerlink" title="基础数据结构以及算法—-《剑指 offer》《编程之美》《程序员面试指南》内容搞懂足够面对BAT"></a>基础数据结构以及算法—-《剑指 offer》《编程之美》《程序员面试指南》内容搞懂足够面对BAT</h4>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;语言基础&quot;&gt;&lt;a href=&quot;#语言基础&quot; class=&quot;headerlink&quot; title=&quot;语言基础&quot;&gt;&lt;/a&gt;语言基础&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;OOP（封装、继承、多态） + V func 的实现，V table 的原理&lt;/li&gt;
&lt;li&gt;const static的各种情况，分清const pointer 和pointer to const以及两者合体的形式
    
    </summary>
    
      <category term="面试" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
</feed>
