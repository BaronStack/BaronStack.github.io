<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>那一刻 风情万种</title>
  
  <subtitle>我喜欢看你笑的样子</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-04-05T12:55:13.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>那一刻 风情万种</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2018-04-05</title>
    <link href="http://yoursite.com/2018/04/05/2018-04-05/"/>
    <id>http://yoursite.com/2018/04/05/2018-04-05/</id>
    <published>2018-04-05T12:31:22.000Z</published>
    <updated>2018-04-05T12:55:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>昨天和今天利用空闲时间了解了一下阴寒体质的原因以、危害以及如何改善阴寒体质。<a id="more"></a><br>有这样的想法的原因是前几天和糖同学去进行了一次拔罐，结果她的身体给我的反应相当大，就是我拔完后身体没有什么大的明显的变化，感觉也挺舒服的。但是她缺全身酸痛，甚至睡觉的时候都不能用背挨着床，这样的情况持续了整整近10天。再加上平时看到她手很冷，全身发凉，偶尔也会感觉身体乏力。我就觉得她的身体有问题，网上搜集科挺多的资料，发现她的体内积累了太多的寒气，俗话说”<font color="#DC143C">痛则不通</font>“，就是产生她现在身体出现情况的原因。</p><p>从她的饮食上以及生活习惯上的问题导致她体内产生的热量不足以供应她身体部分器官的正常运作，长期以往，身体器官老是处于热量供应不足的状态，就会出现她现在的情况：腰部（肾痛），腹部（消化不良），脾寒（身体沉重，容易疲劳）  </p><p>长期下去只会让自己在原有状态的基础上更加严重，为了让我们包子用年轻的身体带着年轻的灵魂蹦哒，我做了一个小表格搜集了饮食上的一些合适的东西。</p><p><img src="/images/包子的饮食.pdf" alt="">  </p><p>生活习惯方面的我会给她再多得总结总结，争取让她在自己喜欢的基础上身体得到改善。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;昨天和今天利用空闲时间了解了一下阴寒体质的原因以、危害以及如何改善阴寒体质。
    
    </summary>
    
      <category term="日记" scheme="http://yoursite.com/categories/life/"/>
    
    
  </entry>
  
  <entry>
    <title>Mac下安装IDLE</title>
    <link href="http://yoursite.com/2018/04/04/Mac%E4%B8%8B%E5%AE%89%E8%A3%85IDLE/"/>
    <id>http://yoursite.com/2018/04/04/Mac下安装IDLE/</id>
    <published>2018-04-04T08:48:21.000Z</published>
    <updated>2018-04-04T09:24:18.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong><font color="#DC143C" size="6"><a href="[https://baike.baidu.com/item/Idle/3823402?fr=aladdin]">IDLE</a></font></strong> 是一个纯 Python 下自带的简洁的集成开发环境(IDE)，是非商业的python开发环境。如果初学者想要去写python程序，那么使用IDLE是一个很不错的选择。它不需要配置多么复杂的环境，下载好python之后就自动安装。</p><p>这是python官网对IDLE的描述,以及IDLE的源码，<a href="https://docs.python.org/3/library/idle.html" target="_blank" rel="noopener">IDLE SourceCode</a> <a id="more"></a></p><p>Mac下安装IDLE很简单，直接去<a href="http://python.org" target="_blank" rel="noopener">python官网</a>下载对应版本的python</p><p><img src="/images/python/pythonOrg.png" alt=""></p><p>下载好之后安装会出现这样的系列软件包<br><img src="/images/python/pythonIDLE.png" alt=""></p><p>接着我们打开IDLE，因为IDLE界面的Tkinter图形库需要依赖Tcl/TK,和python版本不相符，那么会出现这样的问题<br><img src="/images/python/problem.png" alt=""></p><p>这个时候我们无法在该脚本上输入汉字，python解释器会报错，这个时候我们可以去python官网寻找最新的<a href="https://www.python.org/download/mac/tcltk/" target="_blank" rel="noopener">ActiveTcl Downloads</a><br><img src="/images/python/release.png" alt=""></p><p>下载默认安装流程结束后，重新启动IDLE，会看到warning消失<br><img src="/images/python/idle.png" alt=""></p><p>我们新建一个python文件，写好程序之后<br><img src="/images/python/py.png" alt=""></p><p>点击运行(可以自行设置快捷键，因为它默认的是用F5去运行)，查看到结果如下<br><img src="/images/python/runResult.png" alt=""></p><p>这样我们就可以愉快得开始使用IDLE进行python学习了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;&lt;font color=&quot;#DC143C&quot; size=&quot;6&quot;&gt;&lt;a href=&quot;[https://baike.baidu.com/item/Idle/3823402?fr=aladdin]&quot;&gt;IDLE&lt;/a&gt;&lt;/font&gt;&lt;/strong&gt; 是一个纯 Python 下自带的简洁的集成开发环境(IDE)，是非商业的python开发环境。如果初学者想要去写python程序，那么使用IDLE是一个很不错的选择。它不需要配置多么复杂的环境，下载好python之后就自动安装。&lt;/p&gt;
&lt;p&gt;这是python官网对IDLE的描述,以及IDLE的源码，&lt;a href=&quot;https://docs.python.org/3/library/idle.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;IDLE SourceCode&lt;/a&gt;
    
    </summary>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>2018-04-04</title>
    <link href="http://yoursite.com/2018/04/04/2018-04-04/"/>
    <id>http://yoursite.com/2018/04/04/2018-04-04/</id>
    <published>2018-04-04T01:37:02.000Z</published>
    <updated>2018-04-04T02:15:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>算了一下大概有十多天没有好好写日记了，然而这十多天的经历却让我感觉恍如隔世，当然主要是感情上的经历。我陪她一块解决了她论文查重不通过的问题，然后和她一起去校医院换药，去校医院清理伤口。。。也算是陪着她度过了一段让她有点痛苦的时光。其实我觉得她遇到的问题很容易解决，但是作为女孩，在自己遇到之前没有遇到过的问题的时候总会有超出自己承受能力的时候，那么这个时候对她来说就会痛苦。再加上她之前在解决一些问题的时候总是自己一个人，而且使用的方法也不对，这个过程就让她很难受。<a id="more"></a><br>而我陪在她身边给她出谋划策，告诉她这种问题的如何优雅得解决，反正这个过程让我和她的关系是更进一步了。<br>之后我们一块去北京，她要给学校提交一份表格以及进行体检。当然我的目的主要是陪陪她，但是为了不让她有心理负担，我告诉她我要去公司那里和HR商定五月份实习的事情。然后就是一段风花雪月的北京之旅，之前想的是在北京呆一天，结果因为各种莫名其妙的原因在北京呆了整整四天。<br>在北京的小幸运真的好多好多，去之前在火车站遇到了一个年轻的奶奶，她对我们的一番教导让我受益匪浅，在人生之路遇到对的人真的太难了，且行且珍惜。早上在北京胡同里逛的时候随意一抬头进入一个小吃店就遇到了北京最有名的小吃”卤煮火烧”，中午在安和桥那里逛的时候随意进入了一个店就是北京的饺子名店”喜家德”，随意点了一个土豆丝就是该店的特色招牌，吃烤冷面竟然吃出了双黄，骑单车让她坐前面篮子框里享受北京夜晚的美妙，进入一个店吃小吃，竟然是满族的特色，还吃了一份”奶黄猪包”，去一个店里买火车上要吃的零食，结束后去抽奖，竟然抽出了一等奖，7990的翡翠我们只用了”520”就买下了。<br>她说我们回去去买彩票吧，我心里想的是才不要呢，好运这东西用完了就没了，这是一种奇妙的玄学，一切都是随意而为，我们还要留着以后，说不定这份好运可以让我们在某一天里生活开心幸福。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;算了一下大概有十多天没有好好写日记了，然而这十多天的经历却让我感觉恍如隔世，当然主要是感情上的经历。我陪她一块解决了她论文查重不通过的问题，然后和她一起去校医院换药，去校医院清理伤口。。。也算是陪着她度过了一段让她有点痛苦的时光。其实我觉得她遇到的问题很容易解决，但是作为女孩，在自己遇到之前没有遇到过的问题的时候总会有超出自己承受能力的时候，那么这个时候对她来说就会痛苦。再加上她之前在解决一些问题的时候总是自己一个人，而且使用的方法也不对，这个过程就让她很难受。
    
    </summary>
    
      <category term="日记" scheme="http://yoursite.com/categories/life/"/>
    
    
  </entry>
  
  <entry>
    <title>2018-03-23</title>
    <link href="http://yoursite.com/2018/03/24/2018-03-23/"/>
    <id>http://yoursite.com/2018/03/24/2018-03-23/</id>
    <published>2018-03-23T17:13:44.000Z</published>
    <updated>2018-03-23T17:31:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天陪她去医院做了一个血常规，虽然人比较较多，但是仍然让她在中午12：00前吃到了饭。之后我们去了市图书馆，帮她借了几本书，其中有一本讲的是男人的进化史，她一看到这本书眼睛都直了，说一定要好好看看。还说我目前只处于初始猿人阶段，还叫我张猩猩，张狒狒，因为我老对她傻笑。 <a id="more"></a> </p><p>不过也确实，我一看到她就很开心。她问了我好几次我喜欢她什么，我告诉她，每次我都是脑袋一片空白，不知从何说起，可能这就是爱情荷尔蒙的分泌会让脑袋反应比较慢。不过我是知道的：  </p><p>我喜欢她笑起来眯成一条缝的眼睛中漏出来的闪闪光芒，我喜欢她陷入回忆迷茫时嘟起来的小嘴吧，我喜欢她那种为别人着想痛苦都自己承受的胸怀，我喜欢她坚强独立的自尊，我喜欢她时刻转动的小脑袋充满活力与乐趣，我喜欢她时而笨笨的傻傻的，时而聪明理智，时而傻甜感性。会有一点小色，但内心又是一本正经。  </p><p>啊哈哈哈，我发现我还真是超级喜欢她，感激和她呆在一起永远也不会腻烦。  </p><p>不过今天她没有戴小胖子的手表，我知道她想要在我面前表达什么，虽然她的会不时抬起左手看看表，但是我还是有点难受，回来之后立即从网上挑选，但是我发现我好像没有办法代替小胖子的手表，因为她说了小胖子为了不让她的手被磨到，选择了陶瓷的表链，又给她刻上了她的字，真的很漂亮。  </p><p>我听着心里很酸，因为看着网上的手表，我不知道我能选择什么样子的，我不知道我用什么样的方式才会让她对我送她的手表喜欢。纠结惆怅中！！！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天陪她去医院做了一个血常规，虽然人比较较多，但是仍然让她在中午12：00前吃到了饭。之后我们去了市图书馆，帮她借了几本书，其中有一本讲的是男人的进化史，她一看到这本书眼睛都直了，说一定要好好看看。还说我目前只处于初始猿人阶段，还叫我张猩猩，张狒狒，因为我老对她傻笑。
    
    </summary>
    
      <category term="日记" scheme="http://yoursite.com/categories/life/"/>
    
    
  </entry>
  
  <entry>
    <title>2018-03-22</title>
    <link href="http://yoursite.com/2018/03/22/2018-03-22/"/>
    <id>http://yoursite.com/2018/03/22/2018-03-22/</id>
    <published>2018-03-22T13:16:21.000Z</published>
    <updated>2018-03-22T13:29:59.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天去参加了海康威视的签约，拿到了(10K + 1K)*15的薪资，在北京，当时我觉得自己有点傻，应该可以正确更高的，因为我是知道我在面试过程中的表现，所以对自己薪资还是不够满意。<a id="more"></a><br>最后又想了一下，刚毕业，相对于秋招时候的工作来说还是有很大的进步。只要自己在海康表现足够好，就一定有更多的机会去提升自己。小唐同学给我送了一个小鸡腿作为奖励，哈哈哈哈<br>重点是海康在北京的地点也是海淀区，哈哈，和她距离比较近。看看截图哦：  </p><p><img src="/images/path.png" alt=""></p><p>看了一下，哎呀，开心死我了，我们工作的地点距离她们学校居然只有600多米，啊哈哈哈哈哈哈哈哈哈哈哈哈，难道这就是所谓的缘分嘛，我并不知道在海康在北京的具体地点。。。。。。开心开心</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天去参加了海康威视的签约，拿到了(10K + 1K)*15的薪资，在北京，当时我觉得自己有点傻，应该可以正确更高的，因为我是知道我在面试过程中的表现，所以对自己薪资还是不够满意。
    
    </summary>
    
      <category term="日记" scheme="http://yoursite.com/categories/life/"/>
    
    
  </entry>
  
  <entry>
    <title>2018-03-21</title>
    <link href="http://yoursite.com/2018/03/22/2018-03-21/"/>
    <id>http://yoursite.com/2018/03/22/2018-03-21/</id>
    <published>2018-03-22T12:42:17.000Z</published>
    <updated>2018-03-22T13:31:59.000Z</updated>
    
    <content type="html"><![CDATA[<p>即喜欢糖永永的第70天！！！  </p><p>今天发生了一件快要让我崩溃的事情，糖永永同学不理我了。起因是昨天晚上她抱着我问我：以后我回云南，你也回吗？我当时也不知道脑袋在想什么，然后表现出来一点点犹豫，结果，瞬间她远离我3米，极度冷漠，向着宿舍的方向走去。<a id="more"></a></p><p>我当时还是一脸懵逼，我赶紧给她解释，可是她一句话也不说，直接走进了宿舍。我默默得站在了宿舍楼下，脑袋快要炸了。  </p><p>晚上会去看到她发的一首歌，她好像又把自己的内心藏起来了，这次好像是彻底藏起来了。听着歌词里”你再也不会梦或痛或心动了”，听着听着我的眼泪掉下来了。我。。。我并不是说不愿意给她结果，我只想要做一个慎重有结果的承诺，可她总会往坏处去想。  </p><p>第一次听着歌流了如此之多的眼泪，我内心对她的痛感觉如此之深刻。我只想说我肯定会给你一个结果的，可你总会将自己包裹起来，不去好好交流。  </p><p>给她发了很多信息，她不回，打电话也不接。在这期间感觉整个世界都是昏暗无光，老师打了电话说让去见一个公司老总，我用下午有面试的理由搪塞过去了。我不想去，躺在床上，心里老是想起她所承受的痛，想着她又将自己封闭，我就觉得我的世界真的快要塌了，突然发现我已经习惯性得想要呆在她身边，想要有她陪伴，即使她内心喜欢的还是小胖子我也无所谓。  </p><p>不行，一定要去找她，我不能就这样放手。给她打了电话问她在哪，听到她的声音瞬间的心痛又浮上心里，我的眼泪刷刷得向下流（我靠，写的时候才发现这是第一次在一个女生面前哭得如此凄惨，fuck），总之，听到她的声音我就特别想见她。  </p><p>哭着鼻子了解到她不在学校，我不能就这么放弃，不知道她什么时候回学校，估摸着她会回学校的时间，于是我就到她们宿舍楼下等了3个小时，失落得回到学校，走在路上发现一切的努力好像都没有意义了，一切的获得好像也没有意义了，什么北京，什么海康威视，都让我提不起兴趣，世界在昏暗得转动，我的内心如死去一般，因为我感觉我要失去她了。  </p><p>回到宿舍，突然收到她的微信，原来她手机没电了，然后说让我帮她报名。天哪，我的小心脏瞬间满血复活，我巴不得自己长出一对翅膀直接飞到她们学校去。这样的开心比获得年薪20W的工作更来的刺激，因为我喜欢的姑娘对我还是有点理睬的。  </p><p>之后就是在她们学校向她表明衷心，即使她的心还有一部分在别人身上依然阻挡不了我对她的喜欢。哎，接下来我们的动作就比较羞羞了，开心的一天！！！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;即喜欢糖永永的第70天！！！  &lt;/p&gt;
&lt;p&gt;今天发生了一件快要让我崩溃的事情，糖永永同学不理我了。起因是昨天晚上她抱着我问我：以后我回云南，你也回吗？我当时也不知道脑袋在想什么，然后表现出来一点点犹豫，结果，瞬间她远离我3米，极度冷漠，向着宿舍的方向走去。
    
    </summary>
    
      <category term="日记" scheme="http://yoursite.com/categories/life/"/>
    
    
  </entry>
  
  <entry>
    <title>西山居：开发工程师二面</title>
    <link href="http://yoursite.com/2018/03/20/%E8%A5%BF%E5%B1%B1%E5%B1%85%EF%BC%9A%E5%BC%80%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88%E4%BA%8C%E9%9D%A2/"/>
    <id>http://yoursite.com/2018/03/20/西山居：开发工程师二面/</id>
    <published>2018-03-20T09:18:02.000Z</published>
    <updated>2018-03-22T13:33:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>在海康威视HR面结束后收到了西山居来自珠海的二面，感觉有点尴尬，因为我知道当时我的一面过程是一塌糊涂，根本没有抱有二面的希望，又收到了二面通知。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在海康威视HR面结束后收到了西山居来自珠海的二面，感觉有点尴尬，因为我知道当时我的一面过程是一塌糊涂，根本没有抱有二面的希望，又收到了二面通知。&lt;/p&gt;

      
    
    </summary>
    
      <category term="面试" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
  </entry>
  
  <entry>
    <title>深信服：C++开发工程师面经</title>
    <link href="http://yoursite.com/2018/03/20/%E6%B7%B1%E4%BF%A1%E6%9C%8D%EF%BC%9AC-%E5%BC%80%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88%E9%9D%A2%E7%BB%8F/"/>
    <id>http://yoursite.com/2018/03/20/深信服：C-开发工程师面经/</id>
    <published>2018-03-20T05:05:00.000Z</published>
    <updated>2018-03-20T09:13:34.000Z</updated>
    
    <content type="html"><![CDATA[<p>本来以为深信服笔试应挂了，结果在第二天吃饭的时候竟然收到了深信服的面试通知，很是惊喜，但是经历的西山居的追根问底之后就发现自己在专业学习过程中还是存在很多的问题。<a id="more"></a><br>深信服的几个笔试编程题目做的不是很好：链表排序、棋盘遍历（简单深搜的应用）、哈夫曼编码的创建过程、求所有的出栈顺序。<br>面试我的是一个很温和的面试官，看起来也是技术大佬。<br>上来先让我做了一个自我介绍，自我介绍的过程中就是将我的项目功能、架构、用到的技术、遇到的问题都一一讲解。又涉及到了网络通信这里（感觉几乎所有的面试官都对网络通信这里情有独钟），面试官追根问底  </p><ol><li>select和epoll有什么区别，为什么选择使用select而不是epoll。如果让你实现epoll，你该会如何实现 </li><li>阻塞和非阻塞、同步和异步有什么区别  </li></ol><p>接下来他就拿出一张表，从上面挑选问题问我  </p><ol><li>C语言中如何查看文件大小 （fseek()）</li><li>二进制文件和文本文件的区别</li><li>C++中拷贝构造函数为什么先要加一个const,为什么传进去的参数是引用，为什么不能是指针</li><li>C++相比于C语言有什么优势</li><li>什么是僵尸进程，为什么会产生僵尸进程，如何避免僵尸进程</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本来以为深信服笔试应挂了，结果在第二天吃饭的时候竟然收到了深信服的面试通知，很是惊喜，但是经历的西山居的追根问底之后就发现自己在专业学习过程中还是存在很多的问题。
    
    </summary>
    
      <category term="面试" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
  </entry>
  
  <entry>
    <title>2018-03-19</title>
    <link href="http://yoursite.com/2018/03/19/2018-03-19/"/>
    <id>http://yoursite.com/2018/03/19/2018-03-19/</id>
    <published>2018-03-19T00:08:32.000Z</published>
    <updated>2018-03-20T09:13:34.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近大脑一直处于高度紧张状态，可能是由于过多的面试以及面试之后对不懂问题的极速学习让脑袋反应有点慢。不过还好有她的陪伴，给予了我莫大的鼓励与支持。<a id="more"></a><br>我告诉她，我其实是因为你才选择去北京，因为我知道你说过你不想异地。当然按照我的要求，北京生活的话得工资好一点，再一个就是进入一个对我来说我很喜欢的公司才行，这样可以在钱上不讲究，也可以在工作上不讲究。所以最近所面试的一些公司相对来说还是不错的，也是让我真正体会到了所谓技术面试是什么样子的。遇到了很多问题，也发现了自己在专业学习上的盲点，真的是受益匪浅。<br>不过每天忙完之后能够和小猪同学见一见，哎呀，还真是幸福感爆棚呢。<br>有很多同学很羡慕我的大学生活，不过仔细回想起来还真是做过好多事情呢，唯一的遗憾就是在专业学习上花费的时间太少，导致最后所花费的时间去学习一些基础性的东西实在是时间不够用。不过有失必有得，我去学习口语，去摄影摄像剪辑，去健身，去游览祖国的大好河山，这个过程也让我体会到了一种不同于学校的感受。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近大脑一直处于高度紧张状态，可能是由于过多的面试以及面试之后对不懂问题的极速学习让脑袋反应有点慢。不过还好有她的陪伴，给予了我莫大的鼓励与支持。
    
    </summary>
    
      <category term="日记" scheme="http://yoursite.com/categories/life/"/>
    
    
  </entry>
  
  <entry>
    <title>2018-03-16</title>
    <link href="http://yoursite.com/2018/03/17/2018-03-16/"/>
    <id>http://yoursite.com/2018/03/17/2018-03-16/</id>
    <published>2018-03-16T16:49:26.000Z</published>
    <updated>2018-03-20T09:13:34.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天，我和”小唐老师”一起吃了一大桌烧烤，看见她满脸堆笑容，我好开心啊！<a id="more"></a><br>之后我们一起进行了饭后百步走活动，嗯，这个百得在乘一个百。风吹着我和她的头发，我的手抓着她的手，看着她一直笑！这个时候所有的不愉快，所有因为白天自己在专业面试上被打击的不愉快都烟消云散。<br>风儿继续吹着，我们沿着人行道走在昏黄的灯光下，很静，路边那些”一夜尽是长安花”在昏黄灯光下看起来有一种安静的美。原来长安郊区的夜是这个样子的，广场上闪烁的灯光，灯光下映衬的不知名的白色花朵，以及嫩柳扬起的发支都让我感受到一种发自内心的安静。<br>我们依偎在亭子下的小长椅上，我偷偷吻了她，她看起来有点不高兴，但是我忍着脸皮厚被她打了几下，哈哈！看着她枕着我的手臂”目前已经变成她的专用枕头了”，静静得闭目养神。这样就挺好（原谅我最近专注于专业笔试面试，没有去看看看文学类的书，词穷了）！不过，说实话，今天看到的她真的好美好美！<br>每次疲惫的时候只要想起她我就充满动力，我大概知道了她以后想要什么样子的生活，也知道她以后可能会回到老家，我会想尽一切办法和她在一起。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天，我和”小唐老师”一起吃了一大桌烧烤，看见她满脸堆笑容，我好开心啊！
    
    </summary>
    
      <category term="日记" scheme="http://yoursite.com/categories/life/"/>
    
    
  </entry>
  
  <entry>
    <title>西山居：开发工程师面经</title>
    <link href="http://yoursite.com/2018/03/16/%E8%A5%BF%E5%B1%B1%E5%B1%85%EF%BC%9A%E5%BC%80%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88%E9%9D%A2%E7%BB%8F/"/>
    <id>http://yoursite.com/2018/03/16/西山居：开发工程师面经/</id>
    <published>2018-03-16T03:20:41.000Z</published>
    <updated>2018-03-16T04:05:25.000Z</updated>
    
    <content type="html"><![CDATA[<p>当我写下这篇博客的时候其实已经知道我此次面试已经没戏了，但是我还是想要反思自我实力以及对网上所谓西山居面经的吐槽（网上的面经太简单了）。  </p><p>昨晚收到面试通知，我是C／C++方向，之后就一直在具体准备，先是网上的面经，就是一些较为基础的问题： <a id="more"></a> </p><ol><li>堆和栈的区别</li><li>静态库和动态库的区别，什么时候动态链接库需要的内存会超过静态库</li><li>Linux动态库的后缀名是什么</li><li>windows的任务调度机制</li><li>模版的实现原理，以及类型是在编译期绑定还是在运行期绑定</li><li>double的精度问题，0.1能精确表示吗</li><li>给一个ip地址，/22，写出子网掩码和广播地址</li><li>c++中的虚函数表</li><li>说说四次挥手的过程，为什么握手要三次，挥手要四次</li><li>linux的终端的工作方式</li><li>shell脚本里面用过哪些命令</li><li>在公司内网ping www.baidu.com的过程，使用了哪些网络协议</li><li>map里面如何删除一个元素</li><li>你写的程序cpu占用很高怎么办</li><li>程序崩溃了一般的debug步骤</li></ol><p>接下来就是我被问到的问题，面试官一看就是一个搞技术的，一上来就是各种技术问题！自我介绍的时候我有介绍到我做的项目是linux QT下的，主要涉及网络通信。</p><ol><li>QT的跨平台机制是怎么实现的，为什么它可以在Linux、MAC、Windows下运行</li><li>什么是阻塞，非阻塞、select()和epoll的区别</li><li>多线程和多进程的区别，各自的优缺点</li><li>Linux下查找指定文件名的文件（find），查找文件中指定的独立字符串(想不出来，好像是grep的某个同类命令)</li><li>awk和sed了解吗(没有好好准备)</li><li>vi非编辑模式下替换字符</li><li>C++ 的跨平台机制，为什么它可以在windows、Linux下运行</li><li>Java的跨平台机制，Java和C/C++的区别</li><li>python下创建一个0-9的数组</li><li>mysql 和mongodb的区别</li><li>MySQL，Oracle，Access的区别</li><li>NoSQL和关系型数据库的区别</li><li>我写了我了解过tensor flow,问了常用的激励函数(relu,sigmoid)，各自的优缺点</li><li>RNN和LSTM的区别</li><li>git如何创建一个分支,git的stash（git的核心）</li><li>C／C++标准出来的新特性说说</li><li>两个智能指针的用法</li><li>static关键字的作用</li><li>函数栈是在什么时候创建的，具体的过程</li><li>你所了解的服务器技术</li><li>QQ服务器是怎么运作的</li><li>端游中数据的交互</li></ol><p>总结：我大概只能想到这么多了。面试官是根据个人简历去问的，自我介绍的时候发掘你项目中用到的技术，然后根据你的技能点去问你熟悉的东。其中很多我答的都不好甚至没有答上来，面试官就说你对低层实现不够了解，对自己发展方向不够清晰，说是C++服务器方向，但是大多做的东西都是C端，而且一些常见的服务器技术都不去了解，Linux命令不够熟悉（很长时间没有练了，一直在总结问题）。<br>总之还是个人基础不够扎实，所以以后学习大概模拟一个方向：搞清楚软件的运行原理，然后由大及小，遇到细节上的问题也是穷尽原理，这样学到的东西才有体系，才有深度。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当我写下这篇博客的时候其实已经知道我此次面试已经没戏了，但是我还是想要反思自我实力以及对网上所谓西山居面经的吐槽（网上的面经太简单了）。  &lt;/p&gt;
&lt;p&gt;昨晚收到面试通知，我是C／C++方向，之后就一直在具体准备，先是网上的面经，就是一些较为基础的问题：
    
    </summary>
    
      <category term="面试" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux常用信号</title>
    <link href="http://yoursite.com/2018/03/15/Linux%E5%B8%B8%E7%94%A8%E4%BF%A1%E5%8F%B7/"/>
    <id>http://yoursite.com/2018/03/15/Linux常用信号/</id>
    <published>2018-03-15T03:43:58.000Z</published>
    <updated>2018-03-16T04:05:25.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="常用Linux信号"><a href="#常用Linux信号" class="headerlink" title="常用Linux信号"></a>常用Linux信号</h2><p><img src="/images/kill.png" alt=""></p><blockquote><p>Linux系统下有很多信号，按照可靠性可以分为可靠信号和非可靠信号，按时间分为实时信号和非实时信号。</p></blockquote><p>Linux有三种方式来处理收到的信号：</p><ul><li>忽略信号：即对信号不作处理（除了SIGKILL和SIGSTOP）</li><li>捕捉信号：定义信号处理函数，当信号发生时，执行相应的处理函数</li><li>执行缺省操作，Linux对每种信号都规定了默认操作</li></ul><p>常用信号如下：</p><ol><li><strong><font color="#DC143C">SIGHUP</font></strong> 和控制台操作相关，当控制台被关闭的时候系统会向拥有控制台sessionID的进程发送HUP信号，默认HUP信号执行的action是exit,如果远程登启动某个服务进程，并在程序运行时关闭某个链接的会话导致服务进程退出，所以服务程序一般都会用nohup工具启动（该命令就是让系统忽略该信号），或者写一个daemon<a href="">守护进程</a>(利用setsid进行)。</li><li><strong><font color="#DC143C">SIGINT</font></strong> 终止进程，通常我们的ctrl+c就发送这个消息</li><li><strong><font color="#DC143C">SIGQUIT</font></strong> 和SIGINT类似, 但由QUIT字符(通常是Ctrl- / )来控制. 进程收到该消息退出时会产生core文件。</li><li><strong><font color="#DC143C">SIGKILL</font></strong> 消息编号为9，我们经常用kill -9来杀死进程,发送的就是这个消息，程序收到这个消息立即终止，这个消息不能被捕获，封锁或忽略，所以是杀死进程的终极武器。</li><li><strong><font color="#DC143C">SIGTERM</font></strong> 不带参数时kill默认发送的信号，默认是杀死进程</li><li><strong><font color="#DC143C">SIGSTOP</font></strong> 停止进程的执行，同SIGKILL一样不可以被应用程序所处理，注意它和terminate以及interrupt的区别:该进程还未结束, 只是暂停执行</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;常用Linux信号&quot;&gt;&lt;a href=&quot;#常用Linux信号&quot; class=&quot;headerlink&quot; title=&quot;常用Linux信号&quot;&gt;&lt;/a&gt;常用Linux信号&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/images/kill.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;b
      
    
    </summary>
    
      <category term="面试" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>系统调用与函数调用</title>
    <link href="http://yoursite.com/2018/03/15/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E4%B8%8E%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8/"/>
    <id>http://yoursite.com/2018/03/15/系统调用与函数调用/</id>
    <published>2018-03-15T02:33:24.000Z</published>
    <updated>2018-03-15T03:40:31.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Linux下对文件的操作有两种方式：系统调用（system call）和库函数调用（Library Functions）</p></blockquote><h3 id="系统调用（system-call）"><a href="#系统调用（system-call）" class="headerlink" title="系统调用（system call）"></a>系统调用（system call）</h3><blockquote><p>指运行在<font color="#DC143C">用户空间</font>的<font color="#DC143C">应用程序</font>向<font color="#DC143C">操作系统内核</font>请求某些服务的过程。系统调用提供了用户程序与操作系统之间的接口。一般来说系统调用都是在内核态执行，由于系统调用不考虑平台差异性，它是由内核直接提供，因而移植性较差（几乎没有移植性）。<a id="more"></a></p></blockquote><p>这里简单介绍一下Linux系统下常见的系统调用：</p><ul><li><p>getpid,getppid—获取进程识别号</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">pid_t</span> getpid(<span class="keyword">void</span>);<span class="comment">// 获取进程标识号，它可以作为当前进程的唯一标识</span></span><br><span class="line"><span class="keyword">pid_t</span> getppid(<span class="keyword">void</span>);<span class="comment">//获取当前进程的父进程标识号</span></span><br></pre></td></tr></table></figure></li><li><p>fork创建子进程</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">pid_t</span> fork(<span class="keyword">void</span>); <span class="comment">//通过完全复制当前进程创建一个子进程</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">如果创建子进程成功，在父进程中返回子进程的进程标示符，在子进程中返回0。</span></span><br><span class="line"><span class="comment">如果失败，在父进程中返回-1，子进程不会被创建，errno被设置。</span></span><br><span class="line"><span class="comment">因为在fork()的调用处，整个父进程空间会原模原样地复制到子进程中，包括指令，</span></span><br><span class="line"><span class="comment">变量值，程序调用栈，环境变量，缓冲区，等等。所以，子进程和父进程是不能通过</span></span><br><span class="line"><span class="comment">程序内的变量（即使是全局变量）通信的，对于这两个进程来说，它们有各自的进程空间，</span></span><br><span class="line"><span class="comment">互不影响。但父进程和子进程可以通过管道，共享内存，等方式实现通信。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li><li><p>sleep时进程睡眠指定的秒数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">sleep</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> seconds)</span></span>;<span class="comment">//到达指定时间后返回0，若有信号中断，则返回剩余的秒数</span></span><br></pre></td></tr></table></figure></li><li><p>wait,waitpid等待子进程终止</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="keyword">pid_t</span> wait(<span class="keyword">int</span> *status);</span><br><span class="line"><span class="keyword">pid_t</span> waitpid(<span class="keyword">pid_t</span> pid, <span class="keyword">int</span> *status, <span class="keyword">int</span> options);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">等待子进程的状态发生变化：子进程终止，子进程被信号停止，子进程被信号恢复。</span></span><br><span class="line"><span class="comment">wait等待一个子进程终止，waitpid等待pid指定的子进程状态改变。默认waitpid仅等待子进程终止，</span></span><br><span class="line"><span class="comment">可以通过options来改变行为,waitpid执行成功返回状态改变子进程的进程号；</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>具体详细的系统调用可以参考<font color="#DC143C"><a href="http://blog.csdn.net/gwq5210/article/details/41345339" target="_blank" rel="noopener">Linux下系统调用</a></font></strong></p><h3 id="库函数（Library-Functions）"><a href="#库函数（Library-Functions）" class="headerlink" title="库函数（Library Functions）"></a>库函数（Library Functions）</h3><blockquote><p>由用户或组织自己开发的，具有一定功能的函数集合，一般具有较好平台移植性，通过库文件（静态库或动态库）向程序员提供功能性调用。程序员无需关心平台差异，由库来屏蔽平台差异性。</p></blockquote><p>库函数一般分为两类：C语言标准规定的库函数和编译器特定的库函数。可以理解库函数为系统调用的一层封装（大部分），比如：如printf的实现最终还是调用了putc()和user.h中的write()这样的系统调用，而另一些则不会使用系统调用，比如strlen，strcat，memcpy等  </p><blockquote><p>既然使用库函数调用也有系统调用的开销，那为什么不直接使用系统调用呢?<br>因为读写文件通常是大量的数据（这种大量是相对于底层驱动的系统调用所需要的数据单位而言），使用库函数可以大大减少系统调用的次数。<strong><font color="#DC143C">缓冲区技术的出现，在用户空间和内核空间，对文件的操作都是用了缓冲区技术，当内核缓冲区写满之后才将内核缓冲区中的数据写入文件对应的硬件媒介中，而不是每写一次，就要执行一次系统调用，再切换到用户空间写如磁盘。对CPU处理效率消耗比较大</font></strong></p></blockquote><h3 id="系统调用和库函数的区别"><a href="#系统调用和库函数的区别" class="headerlink" title="系统调用和库函数的区别"></a>系统调用和库函数的区别</h3><p><img src="/images/syscall.png" alt=""></p><h3 id="联系"><a href="#联系" class="headerlink" title="联系"></a>联系</h3><blockquote><p>内核功能与操作系统特性紧密相关的服务，由系统调用提供<br>具有共通特性的功能一般需要较好的平台移植性，故而由库函数提供</p></blockquote><p>库函数与系统调用在功能上相互补充，如进程间通信资源的管理，进程控制等功能与平台特性和内核息息相关，必须由系统调用来实现<br>文件 I/O操作等各平台都具有的共通功能一般采用库函数，也便于跨平台移植<br>库函数与系统调用也有交集，如 库函数中的I/O操作的内部实现依然需要调用系统的I/O方能实现</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Linux下对文件的操作有两种方式：系统调用（system call）和库函数调用（Library Functions）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;系统调用（system-call）&quot;&gt;&lt;a href=&quot;#系统调用（system-call）&quot; class=&quot;headerlink&quot; title=&quot;系统调用（system call）&quot;&gt;&lt;/a&gt;系统调用（system call）&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;指运行在&lt;font color=&quot;#DC143C&quot;&gt;用户空间&lt;/font&gt;的&lt;font color=&quot;#DC143C&quot;&gt;应用程序&lt;/font&gt;向&lt;font color=&quot;#DC143C&quot;&gt;操作系统内核&lt;/font&gt;请求某些服务的过程。系统调用提供了用户程序与操作系统之间的接口。一般来说系统调用都是在内核态执行，由于系统调用不考虑平台差异性，它是由内核直接提供，因而移植性较差（几乎没有移植性）。
    
    </summary>
    
      <category term="面试" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="OS" scheme="http://yoursite.com/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>项目问题总结</title>
    <link href="http://yoursite.com/2018/03/13/%E9%A1%B9%E7%9B%AE%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2018/03/13/项目问题总结/</id>
    <published>2018-03-13T15:29:42.000Z</published>
    <updated>2018-03-14T09:52:15.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题一：主机间通信断开链接后重新连接失败，显示接受（C端）端口被占用"><a href="#问题一：主机间通信断开链接后重新连接失败，显示接受（C端）端口被占用" class="headerlink" title="问题一：主机间通信断开链接后重新连接失败，显示接受（C端）端口被占用"></a>问题一：主机间通信断开链接后重新连接失败，显示接受（C端）端口被占用</h2><h3 id="分析："><a href="#分析：" class="headerlink" title="分析："></a><font color="#DC143C">分析：</font></h3><p>主机之间建立的链接属于TCP链接，断开的时候会发生TCP四次挥手，过程中C端会进入TIME_WAIT状态，有时S端主动断开链接的时候也会导致S端进入TIME_WAIT状态。即我们断开TCP链接的时候并没有完全断开，此时S端还处于TIME_WAIT，导致通信端口被占用，无法创建新的链接。<a id="more"></a></p><p><img src="/images/time_wait.png" alt=""></p><h3 id="为什么会有TIME-WAIT状态的原因："><a href="#为什么会有TIME-WAIT状态的原因：" class="headerlink" title="为什么会有TIME_WAIT状态的原因："></a><font color="#DC143C">为什么会有TIME_WAIT状态的原因：</font></h3><ul><li>可靠的终止TCP链接</li></ul><blockquote><p>若处于time_wait的客户端发送给服务器确认报文段丢失的话，服务器将在此重新发送FIN报文段，那么客户端必须处于一个可接收的状态就是time_wait而不是close状态</p><ul><li>保证让迟来的TCP报文段有足够的时间被识别并丢弃</li></ul><p>linux 中一个TCP端口不能打开两次或两次以上，当客户端处于time_wait状态时我们将无法使用此端口建立新连接，如果不存在time_wait状态，新连接可能会收到旧连接的数据。time_wait持续的时间是2MSL，保证旧的数据可以丢弃，因为网络中的数据最大存在MSL</p></blockquote><h3 id="解决TIME-WAIT的状态占用："><a href="#解决TIME-WAIT的状态占用：" class="headerlink" title="解决TIME_WAIT的状态占用："></a><font color="#DC143C">解决TIME_WAIT的状态占用：</font></h3><ul><li>通过socket的选项SO_REUSEADDR来强制进程立即使用处于time_wait状态的连接占用的端口，即使sock处于time_wait状态，与之绑定的socket地址也可以立即被重用 </li><li>修改内核参数/proc/sys/net/ipv4/tcp_tw/recycle来快速回收被关闭的socket,从而是tcp连接根本不进入time_wait状态，进而允许应用程序立即重用本地的socket地址。详细修改方式可以参考文章<a href="https://www.cnblogs.com/balaamwe/archive/2011/12/07/2279282.html" target="_blank" rel="noopener">如何优雅得关闭socket</a></li></ul><h2 id="问题二：多个C端同时向数据库写／取数据，如何防止数据被覆盖"><a href="#问题二：多个C端同时向数据库写／取数据，如何防止数据被覆盖" class="headerlink" title="问题二：多个C端同时向数据库写／取数据，如何防止数据被覆盖"></a>问题二：多个C端同时向数据库写／取数据，如何防止数据被覆盖</h2><h4 id="MySQL的并发控制与加锁分析"><a href="#MySQL的并发控制与加锁分析" class="headerlink" title="MySQL的并发控制与加锁分析"></a>MySQL的并发控制与加锁分析</h4>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;问题一：主机间通信断开链接后重新连接失败，显示接受（C端）端口被占用&quot;&gt;&lt;a href=&quot;#问题一：主机间通信断开链接后重新连接失败，显示接受（C端）端口被占用&quot; class=&quot;headerlink&quot; title=&quot;问题一：主机间通信断开链接后重新连接失败，显示接受（C端）端口被占用&quot;&gt;&lt;/a&gt;问题一：主机间通信断开链接后重新连接失败，显示接受（C端）端口被占用&lt;/h2&gt;&lt;h3 id=&quot;分析：&quot;&gt;&lt;a href=&quot;#分析：&quot; class=&quot;headerlink&quot; title=&quot;分析：&quot;&gt;&lt;/a&gt;&lt;font color=&quot;#DC143C&quot;&gt;分析：&lt;/font&gt;&lt;/h3&gt;&lt;p&gt;主机之间建立的链接属于TCP链接，断开的时候会发生TCP四次挥手，过程中C端会进入TIME_WAIT状态，有时S端主动断开链接的时候也会导致S端进入TIME_WAIT状态。即我们断开TCP链接的时候并没有完全断开，此时S端还处于TIME_WAIT，导致通信端口被占用，无法创建新的链接。
    
    </summary>
    
      <category term="面试" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
  </entry>
  
  <entry>
    <title>Base64编码方式及实现代码</title>
    <link href="http://yoursite.com/2018/03/13/C-%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E5%87%86%E5%A4%87%EF%BC%9ABase64%E7%BC%96%E7%A0%81%E6%96%B9%E5%BC%8F%E5%8F%8A%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81/"/>
    <id>http://yoursite.com/2018/03/13/C-面试问题准备：Base64编码方式及实现代码/</id>
    <published>2018-03-13T13:39:21.000Z</published>
    <updated>2018-03-14T13:59:20.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>之前根本就没有听过base64编码，可能还是对网络这里了解不够，参加了北京柠檬微趣的现场笔试，看到了这个题目，当时想的太简单了，其实本来思路想好之后就不会很难，可惜先入为主了，导致没有参加面试机会，可惜可惜！！！<br>特总结base64编码实现如下：<br><a id="more"></a></p><h2 id="Base64编码"><a href="#Base64编码" class="headerlink" title="Base64编码"></a>Base64编码</h2></blockquote><p>是一种基于64个可打印字符来表示二进制数据的表示方法!它是一种将二进制编码转换为可打印字符一种。<br>它是MIME编码里面非常常见一种可逆转换二进制方法！现常用于电子邮件中，邮件类型声明如：Content-Transfer-Encoding: base64 。</p><h2 id="编码原理"><a href="#编码原理" class="headerlink" title="编码原理"></a>编码原理</h2><p>我们知道三个字节有24个位元，就可以刚好对应于4个Base64单元，即3个字节需要用4个Base64的可打印字符来表示。在Base64中的可打印字符包括字母A-Z、a-z、数字0-9 ，这样共有62个字符，此外两个可打印符号在不同的系统中一般有所不同。但是，我们经常所说的Base64另外2个字符是：“+/”。这64个字符，所对应表如下。<br><img src="/images/base64.png" alt=""></p><p>转换的时候按照如下方法:</p><p><font color="#DC143C">将输入数据流每次取6 bit，用此6 bit的值(0-63)作为索引去查表，输出相应字符。这样，每3个字节将编码为4个字符(3×8 → 4×6)；不满4个字符的以’=’填充</font><br>如下图：</p><p><img src="/images/base.png" alt=""></p><p>主要是通过位运算符将6bit的数据提取出来，并且对最后不足6位的bit进行补位。</p><p>代码如下:</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> EnBase64Tab[] = <span class="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"</span>;</span><br><span class="line"><span class="keyword">int</span> CBase64::EncodeBase64(<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span>* pSrc, <span class="keyword">char</span>* pDst, <span class="keyword">int</span> nSrcLen, <span class="keyword">int</span> nMaxLineLen)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> c1, c2, c3;    <span class="comment">// 输入缓冲区读出3个字节</span></span><br><span class="line">    <span class="keyword">int</span> nDstLen = <span class="number">0</span>;             <span class="comment">// 输出的字符计数</span></span><br><span class="line">    <span class="keyword">int</span> nLineLen = <span class="number">0</span>;            <span class="comment">// 输出的行长度计数</span></span><br><span class="line">    <span class="keyword">int</span> nDiv = nSrcLen / <span class="number">3</span>;      <span class="comment">// 输入数据长度除以3得到的倍数</span></span><br><span class="line">    <span class="keyword">int</span> nMod = nSrcLen % <span class="number">3</span>;      <span class="comment">// 输入数据长度除以3得到的余数</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 每次取3个字节，编码成4个字符</span></span><br><span class="line">    <span class="built_in">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nDiv; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 取3个字节</span></span><br><span class="line">        c1 = *pSrc++;</span><br><span class="line">        c2 = *pSrc++;</span><br><span class="line">        c3 = *pSrc++;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 编码成4个字符</span></span><br><span class="line">        *pDst++ = EnBase64Tab[c1 &gt;&gt; <span class="number">2</span>];</span><br><span class="line">        *pDst++ = EnBase64Tab[((c1 &lt;&lt; <span class="number">4</span>) | (c2 &gt;&gt; <span class="number">4</span>)) &amp; <span class="number">0x3f</span>];</span><br><span class="line">        *pDst++ = EnBase64Tab[((c2 &lt;&lt; <span class="number">2</span>) | (c3 &gt;&gt; <span class="number">6</span>)) &amp; <span class="number">0x3f</span>];</span><br><span class="line">        *pDst++ = EnBase64Tab[c3 &amp; <span class="number">0x3f</span>];</span><br><span class="line">        nLineLen += <span class="number">4</span>;</span><br><span class="line">        nDstLen += <span class="number">4</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 是否输出换行？</span></span><br><span class="line">        <span class="built_in">if</span> (nLineLen &gt; nMaxLineLen - <span class="number">4</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            *pDst++ = <span class="string">'/r'</span>;</span><br><span class="line">            *pDst++ = <span class="string">'/n'</span>;</span><br><span class="line">            nLineLen = <span class="number">0</span>;</span><br><span class="line">            nDstLen += <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 编码余下的字节</span></span><br><span class="line">    <span class="built_in">if</span> (nMod == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        c1 = *pSrc++;</span><br><span class="line">        *pDst++ = EnBase64Tab[(c1 &amp; <span class="number">0xfc</span>) &gt;&gt; <span class="number">2</span>];</span><br><span class="line">        *pDst++ = EnBase64Tab[((c1 &amp; <span class="number">0x03</span>) &lt;&lt; <span class="number">4</span>)];</span><br><span class="line">        *pDst++ = <span class="string">'='</span>;</span><br><span class="line">        *pDst++ = <span class="string">'='</span>;</span><br><span class="line">        nLineLen += <span class="number">4</span>;</span><br><span class="line">        nDstLen += <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">else</span> <span class="built_in">if</span> (nMod == <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        c1 = *pSrc++;</span><br><span class="line">        c2 = *pSrc++;</span><br><span class="line">        *pDst++ = EnBase64Tab[(c1 &amp; <span class="number">0xfc</span>) &gt;&gt; <span class="number">2</span>];</span><br><span class="line">        *pDst++ = EnBase64Tab[((c1 &amp; <span class="number">0x03</span>) &lt;&lt; <span class="number">4</span>) | ((c2 &amp; <span class="number">0xf0</span>) &gt;&gt; <span class="number">4</span>)];</span><br><span class="line">        *pDst++ = EnBase64Tab[((c2 &amp; <span class="number">0x0f</span>) &lt;&lt; <span class="number">2</span>)];</span><br><span class="line">        *pDst++ = <span class="string">'='</span>;</span><br><span class="line">        nDstLen += <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 输出加个结束符</span></span><br><span class="line">    *pDst = <span class="string">'/0'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">return</span> nDstLen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;之前根本就没有听过base64编码，可能还是对网络这里了解不够，参加了北京柠檬微趣的现场笔试，看到了这个题目，当时想的太简单了，其实本来思路想好之后就不会很难，可惜先入为主了，导致没有参加面试机会，可惜可惜！！！&lt;br&gt;特总结base64编码实现如下：&lt;br&gt;
    
    </summary>
    
      <category term="面试" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>实现String类</title>
    <link href="http://yoursite.com/2018/03/13/C-%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E5%87%86%E5%A4%87-%E5%AE%9E%E7%8E%B0String%E7%B1%BB/"/>
    <id>http://yoursite.com/2018/03/13/C-面试问题准备-实现String类/</id>
    <published>2018-03-13T10:04:21.000Z</published>
    <updated>2018-03-14T13:33:59.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="String-类"><a href="#String-类" class="headerlink" title="String 类"></a>String 类</h2><p>原型如下：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class <span class="keyword">String</span></span><br><span class="line">&#123; </span><br><span class="line"> <span class="keyword">public</span>: </span><br><span class="line"> <span class="keyword">String</span>(<span class="keyword">const</span> <span class="keyword">char</span> *str = NULL); <span class="comment">// 普通构造函数 </span></span><br><span class="line"> <span class="keyword">String</span>(<span class="keyword">const</span> <span class="keyword">String</span> &amp;other); <span class="comment">// 拷贝构造函数 </span></span><br><span class="line"> ~ <span class="keyword">String</span>(<span class="keyword">void</span>); <span class="comment">// 析构函数 </span></span><br><span class="line"> <span class="keyword">String</span> &amp; <span class="keyword">operator</span> =(<span class="keyword">const</span> <span class="keyword">String</span> &amp;other); <span class="comment">// 赋值函数 </span></span><br><span class="line"> <span class="keyword">private</span>: </span><br><span class="line"> <span class="keyword">char</span> *m_data; <span class="comment">// 用于保存字符串 </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><a id="more"></a><p>具体实现:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">String::String(<span class="keyword">const</span> <span class="keyword">char</span> * str) &#123;</span><br><span class="line">    <span class="keyword">if</span> (str == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        m_data = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (m_data == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"内存分配失败"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        *m_data = <span class="string">'\0'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="built_in">strlen</span>(str);</span><br><span class="line">        m_data = <span class="keyword">new</span> <span class="keyword">char</span>[len + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">//同样可以加分配失败的处理</span></span><br><span class="line">        <span class="built_in">strcpy</span>(m_data,str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String::~String(<span class="keyword">void</span>) &#123;</span><br><span class="line">    <span class="keyword">delete</span>[] m_data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String::String(<span class="keyword">const</span> String &amp;other) &#123;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(other.m_data);</span><br><span class="line">    m_data = <span class="keyword">new</span> <span class="keyword">char</span>[len + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(m_data,other.m_data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String &amp; String :: <span class="keyword">operator</span> = (<span class="keyword">const</span> String &amp;other) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;other) &#123;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> [] m_data;</span><br><span class="line">    <span class="keyword">int</span> length = <span class="built_in">strlen</span>( other.m_data ); </span><br><span class="line">    m_data = <span class="keyword">new</span> <span class="keyword">char</span>[length+<span class="number">1</span>]; 　</span><br><span class="line">    <span class="built_in">strcpy</span>( m_data, other.m_data ); </span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>; 　　　　　　　　<span class="comment">//得分点：返回本对象的引用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;String-类&quot;&gt;&lt;a href=&quot;#String-类&quot; class=&quot;headerlink&quot; title=&quot;String 类&quot;&gt;&lt;/a&gt;String 类&lt;/h2&gt;&lt;p&gt;原型如下：&lt;/p&gt;
&lt;figure class=&quot;highlight arduino&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;class &lt;span class=&quot;keyword&quot;&gt;String&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt;: &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;keyword&quot;&gt;String&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; *str = NULL); &lt;span class=&quot;comment&quot;&gt;// 普通构造函数 &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;keyword&quot;&gt;String&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;String&lt;/span&gt; &amp;amp;other); &lt;span class=&quot;comment&quot;&gt;// 拷贝构造函数 &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; ~ &lt;span class=&quot;keyword&quot;&gt;String&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;); &lt;span class=&quot;comment&quot;&gt;// 析构函数 &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;keyword&quot;&gt;String&lt;/span&gt; &amp;amp; &lt;span class=&quot;keyword&quot;&gt;operator&lt;/span&gt; =(&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;String&lt;/span&gt; &amp;amp;other); &lt;span class=&quot;comment&quot;&gt;// 赋值函数 &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt;: &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; *m_data; &lt;span class=&quot;comment&quot;&gt;// 用于保存字符串 &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="面试" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>KMP算法</title>
    <link href="http://yoursite.com/2018/03/13/C-%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E5%87%86%E5%A4%87%EF%BC%9AKMP%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2018/03/13/C-面试问题准备：KMP算法/</id>
    <published>2018-03-12T16:35:13.000Z</published>
    <updated>2018-03-14T13:21:03.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在说KMP算法之前先说一下普通的模式匹配算法</p></blockquote><h2 id="BF蛮力算法–字符串匹配"><a href="#BF蛮力算法–字符串匹配" class="headerlink" title="BF蛮力算法–字符串匹配"></a>BF蛮力算法–字符串匹配</h2><font size="5">算法思想：</font><br><font color="#DC143C">从目标串T的的第一个字符起与模式串P的第一个字符比较<br>若相等，则继续对字符进行后续的比较<br>否则目标串从第二个字符起与模式串的第一个字符重新比较<br>直至模式串中的每个字符依次和目标串中的一个连续的字符序列相等为止，此时称为匹配成功，否则匹配失败</font> <a id="more"></a><br><br><font size="5">算法性能：</font><br><font color="#DC143C">假设模式串的长度是m，目标串的长度是n.<br>最坏情况即每次模式串都是在最后一个出现不等，最坏的时间复杂度为O(mn),因为其回溯比较，从而影响效率。<br><br>代码如下：<br><br><figure class="highlight hsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> bf_match(char *target,char * pattern) &#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">pos</span> = <span class="number">-1</span><span class="comment">;</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, k = <span class="number">0</span><span class="comment">;</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">pos</span> == <span class="number">-1</span> &amp;&amp; i &lt; <span class="keyword">strlen</span>(target)) &#123;</span><br><span class="line">        <span class="keyword">while</span>(j &lt; <span class="keyword">strlen</span>(pattern) &amp;&amp; target[i] == pattern[j]) &#123;</span><br><span class="line">            i ++<span class="comment">;</span></span><br><span class="line">            j ++<span class="comment">;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="keyword">strlen</span>(pattern)) <span class="comment">//扫描完，匹配成功，则让pos为开始匹配的下标</span></span><br><span class="line">            <span class="keyword">pos</span> = k<span class="comment">;</span></span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">//未扫描完，则模式串从头开始，目标串从下一个字符开始</span></span><br><span class="line">            j = <span class="number">0</span><span class="comment">;</span></span><br><span class="line">            k++<span class="comment">;</span></span><br><span class="line">            i = k<span class="comment">;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">pos</span><span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>## KMP–Knuth-Morris-Pratt算法：消除BF中的回溯<br><br><font size="5">算法思想：</font><br><font color="#DC143C"><br>(1) 计算跳转位置信息，这里我们称之为部分匹配表。<br>(2) 后移到指定位置，重新开始匹配。</font><p>这里 <strong><font color="#DC143C">部分匹配表</font></strong>的含义是在目标字符串中最大前缀和最大后缀所拥有相同字符的最大长度。</p><p>next数组的计算代码如下:</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> cal_next(<span class="keyword">char</span> *<span class="keyword">str</span>, <span class="keyword">int</span> *next, <span class="keyword">int</span> len)</span><br><span class="line">&#123;</span><br><span class="line">    next[<span class="number">0</span>] = <span class="number">-1</span>;<span class="comment">//next[0]初始化为-1，-1表示不存在相同的最大前缀和最大后缀</span></span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">-1</span>;<span class="comment">//k初始化为-1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> q = <span class="number">1</span>; q &lt;= len<span class="number">-1</span>; q++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (k &gt; <span class="number">-1</span> &amp;&amp; <span class="keyword">str</span>[k + <span class="number">1</span>] != <span class="keyword">str</span>[q])<span class="comment">//如果下一个不同，那么k就变成next[k]，注意next[k]是小于k的，无论k取任何值。</span></span><br><span class="line">        &#123;</span><br><span class="line">            k = next[k];<span class="comment">//往前回溯</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">str</span>[k + <span class="number">1</span>] == <span class="keyword">str</span>[q])<span class="comment">//如果相同，k++</span></span><br><span class="line">        &#123;</span><br><span class="line">            k = k + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        next[q] = k;<span class="comment">//这个是把算的k的值（就是相同的最大前缀和最大后缀长）赋给next[q]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>KMP代码如下:</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> KMP(<span class="keyword">char</span> *<span class="keyword">str</span>, <span class="keyword">int</span> slen, <span class="keyword">char</span> *ptr, <span class="keyword">int</span> plen)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> *next = <span class="keyword">new</span> <span class="keyword">int</span>[plen];</span><br><span class="line">    cal_next(ptr, next, plen);<span class="comment">//计算next数组</span></span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; slen; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (k &gt;<span class="number">-1</span>&amp;&amp; ptr[k + <span class="number">1</span>] != <span class="keyword">str</span>[i])<span class="comment">//ptr和str不匹配，且k&gt;-1（表示ptr和str有部分匹配）</span></span><br><span class="line">            k = next[k];<span class="comment">//往前回溯</span></span><br><span class="line">        <span class="keyword">if</span> (ptr[k + <span class="number">1</span>] == <span class="keyword">str</span>[i])</span><br><span class="line">            k = k + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (k == plen<span class="number">-1</span>)<span class="comment">//说明k移动到ptr的最末端</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//cout &lt;&lt; "在位置" &lt;&lt; i-plen+1&lt;&lt; endl;</span></span><br><span class="line">            <span class="comment">//k = -1;//重新初始化，寻找下一个</span></span><br><span class="line">            <span class="comment">//i = i - plen + 1;//i定位到该位置，外层for循环i++可以继续找下一个（这里默认存在两个匹配字符串可以部分重叠），感谢评论中同学指出错误。</span></span><br><span class="line">            <span class="keyword">return</span> i-plen+<span class="number">1</span>;<span class="comment">//返回相应的位置</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></font>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;在说KMP算法之前先说一下普通的模式匹配算法&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;BF蛮力算法–字符串匹配&quot;&gt;&lt;a href=&quot;#BF蛮力算法–字符串匹配&quot; class=&quot;headerlink&quot; title=&quot;BF蛮力算法–字符串匹配&quot;&gt;&lt;/a&gt;BF蛮力算法–字符串匹配&lt;/h2&gt;&lt;font size=&quot;5&quot;&gt;算法思想：&lt;/font&gt;&lt;br&gt;&lt;font color=&quot;#DC143C&quot;&gt;从目标串T的的第一个字符起与模式串P的第一个字符比较&lt;br&gt;若相等，则继续对字符进行后续的比较&lt;br&gt;否则目标串从第二个字符起与模式串的第一个字符重新比较&lt;br&gt;直至模式串中的每个字符依次和目标串中的一个连续的字符序列相等为止，此时称为匹配成功，否则匹配失败&lt;/font&gt;
    
    </summary>
    
      <category term="面试" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>剑指 offer--丑数和两个链表的第一个公共结点</title>
    <link href="http://yoursite.com/2018/03/12/C-%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E5%87%86%E5%A4%87%EF%BC%9A%E5%89%91%E6%8C%87-offer-%E4%B8%91%E6%95%B0%E5%92%8C%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E7%BB%93%E7%82%B9/"/>
    <id>http://yoursite.com/2018/03/12/C-面试问题准备：剑指-offer-丑数和两个链表的第一个公共结点/</id>
    <published>2018-03-12T10:01:41.000Z</published>
    <updated>2018-03-14T13:21:03.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="两个链表的第一个公共结点"><a href="#两个链表的第一个公共结点" class="headerlink" title="两个链表的第一个公共结点"></a>两个链表的第一个公共结点</h2><blockquote><p>问题描述：输入两个链表，找出它们的第一个公共结点。</p></blockquote><p>这道题第一次很容易想到，在第一个链表上遍历每个结点的时候再在第二个链表顺序遍历所有的结点，如果第二个链表上有一个结点和第一个链表上的结点一样，则返回该结点。但是这样的遍历方式会导致时间复杂度为O(mn);<a id="more"></a></p><p>这样显然是不能让面试官满意的，那么分析两个链表具有公共结点的特点，即从该公共结点之后它们所有的结点都是重合的。我们可以考虑从后往前遍历链表，只需要找到最后一个不相同的结点，则该结点就是第一个公共结点。</p><p>代码如下:</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">listNode * findFirstCommonNode(listNode * head1, listNode * head2) &#123;</span><br><span class="line">    <span class="keyword">if</span> (head1 == <span class="keyword">NULL</span> || head2 == <span class="keyword">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">NULL</span>;</span><br><span class="line">    stack &lt;listNode &gt; s1,s2;</span><br><span class="line">    <span class="keyword">while</span>(head1 -&gt; <span class="keyword">next</span> != <span class="keyword">NULL</span>) &#123;</span><br><span class="line">        s1.<span class="keyword">push</span>(head1);</span><br><span class="line">        head1 = head1 -&gt; <span class="keyword">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="keyword">while</span>(head2 -&gt; <span class="keyword">next</span> != <span class="keyword">NULL</span>) &#123;</span><br><span class="line">         s1.<span class="keyword">push</span>(head2);</span><br><span class="line">         head1 = head2 -&gt; <span class="keyword">next</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">while</span>(!s1.empty() &amp;&amp; !s2.empty()) &#123;</span><br><span class="line">          <span class="keyword">int</span> result;</span><br><span class="line">          <span class="keyword">if</span> (s1.top() == s2.top()) &#123;</span><br><span class="line">            s1.<span class="keyword">pop</span>();</span><br><span class="line">            result = s2.top();</span><br><span class="line">            s2.<span class="keyword">pop</span>()</span><br><span class="line">          &#125; </span><br><span class="line">          <span class="keyword">else</span> </span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上一个方法需要两个辅助栈，如果链表的长度分别为m和n，那么空间复杂度是O(m+n)。这种思路的时间复杂度也是O(m+n)。和最开始的蛮力法相比，时间效率得到了提高，相当于是空间换时间。</p><p>接下来有一个更简单的办法：首先遍历两个链表得到它们的长度，就能知道哪个链表比较长，以及长的链表比短的链表多几个结点。在第二次遍历的时候，在较长的链表上先走若干步，接着同时在两个链表上遍历，找到的第一个相同的结点就是它们的第一个公共结点。</p><p>代码如下：<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">listNode * findFirstCommonNode(listNode * head1, listNode * head2) &#123;</span><br><span class="line">    unsigned <span class="keyword">int</span> length1 = getListLength(head1);</span><br><span class="line">    unsigned <span class="keyword">int</span> length2 = getListLength(head2);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> nLengthDif = length1 -length2;</span><br><span class="line">    listNode * listLong = head1;</span><br><span class="line">    listNode * listShort = head2;</span><br><span class="line">    <span class="keyword">if</span> (length2 &gt; length1) &#123;</span><br><span class="line">        listLong = head2;</span><br><span class="line">        listShort = head1;</span><br><span class="line">        nLengthDif = length2 -length1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//先从长链表走几步</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; nLengthDif; ++i) </span><br><span class="line">        listLong = listLong -&gt; <span class="keyword">next</span>;</span><br><span class="line">    <span class="keyword">while</span>(listLong != <span class="keyword">NULL</span> &amp;&amp; listShort != <span class="keyword">NULL</span> &amp;&amp; listLong != listShort) &#123;</span><br><span class="line">        listLong = listLong -&gt; <span class="keyword">next</span>;</span><br><span class="line">        listShort = listShort -&gt; <span class="keyword">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    listNode *first = listLong;</span><br><span class="line">     <span class="keyword">return</span> first;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> getListLength(listNode * head) &#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">NULL</span>) </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">count</span> = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(head -&gt; <span class="keyword">next</span> != <span class="keyword">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">count</span> ++;</span><br><span class="line">        head = head -&gt; <span class="keyword">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">count</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="丑数"><a href="#丑数" class="headerlink" title="丑数"></a>丑数</h2><blockquote><p>题目描述：我们把只包含因子2、3、5的数称作丑数。求按从小到大的顺序第1500个丑数。例如6、8都是丑数，但14不是，因为它包含因子7。习惯上我们把1当作第一个丑数。</p></blockquote><p>显然我们可以得到一个数如果能够连续被2整除、被3整除或者被5整除，最后结果余1，那么它就是丑数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isUgly</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(n % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">        n /= <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span>(n % <span class="number">3</span> == <span class="number">0</span>)</span><br><span class="line">        n /= <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">while</span>(n % <span class="number">5</span> == <span class="number">0</span>)</span><br><span class="line">        n /= <span class="number">5</span>;</span><br><span class="line">     <span class="keyword">if</span> (n == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getUglyNumber</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> uglyFound = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(uglyFound &lt; n) &#123;</span><br><span class="line">        i ++;</span><br><span class="line">        <span class="keyword">if</span> (isUgly(i))</span><br><span class="line">            uglyFound ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上段代码很直观得告诉我们指定题目的第n个丑数的计算过程。但是由于它会对每个非丑数也进行丑数的判断，从而导致算法效率不高。</p><p>此时我们可以采用方法2:<strong><font color="#DC143C">创建数组保存已经找到的丑数，用空间换时间的解法。</font></strong></p><p>即找到如何计算丑数的方法，而非判断丑数。我们可以创建一个数组，里面的数字是排好序的丑数，每一个丑数都是前面的丑数乘以2、3或5得到的。</p><p>这种思路的关键在于怎样确保数组里面的丑数是排好序的。假设数组中已经由若干丑数排好序后存放在数组中，并且已有最大的丑数计作M，我们接下来分析如何生成下一个丑数。该丑数一定是前面某一个丑数乘以2、3或5的结果，所以我们首先考虑把已有的每个丑数乘以2。在乘以2的时候，能得到若干个小于或等于M的结果。</p><p>代码如下：</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> getUglyNumber_Solution2(<span class="built_in">int</span> <span class="built_in">index</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">index</span> &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">int</span> *uglyNumbers = new <span class="built_in">int</span>[<span class="built_in">index</span>];</span><br><span class="line">    uglyNumbers[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">int</span> nextUglyIndex = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">int</span> *multiply2 = uglyNumbers;</span><br><span class="line">    <span class="built_in">int</span> *multiply3 = uglyNumbers;</span><br><span class="line">    <span class="built_in">int</span> *multiply5 = uglyNumbers;</span><br><span class="line">    <span class="keyword">while</span>(nextUglyIndex &lt; <span class="built_in">index</span>) &#123;</span><br><span class="line">        <span class="built_in">int</span> <span class="built_in">min</span> = <span class="built_in">Min</span>(*multiply2 * <span class="number">2</span> ,*multiply3 * <span class="number">3</span> ,*multiply5 * <span class="number">5</span>);</span><br><span class="line">        uglyNumbers[nextUglyIndex] = <span class="built_in">min</span>;</span><br><span class="line">        <span class="keyword">while</span>(*multiply2 * <span class="number">2</span> &lt;= uglyNumbers[nextUglyIndex])</span><br><span class="line">             multiply2 ++;</span><br><span class="line">        <span class="keyword">while</span>(*multiply3 * <span class="number">3</span> &lt;= uglyNumbers[nextUglyIndex])</span><br><span class="line">             multiply3 ++;</span><br><span class="line">        <span class="keyword">while</span>(*multiply5 * <span class="number">5</span> &lt;= uglyNumbers[nextUglyIndex])</span><br><span class="line">             multiply5 ++;</span><br><span class="line">        nextUglyIndex++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">int</span> ugly = uglyNumbers[nextUglyIndex - <span class="number">1</span>];</span><br><span class="line">    delete[] uglyNumbers;</span><br><span class="line">    <span class="keyword">return</span> ugly;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> <span class="built_in">min</span>(<span class="built_in">int</span> number1,<span class="built_in">int</span> number2,<span class="built_in">int</span> number3) &#123;</span><br><span class="line">    <span class="built_in">int</span> <span class="built_in">min</span> = (number1 &lt; number2) ? number1:number2;</span><br><span class="line">    <span class="built_in">min</span> = (<span class="built_in">min</span> &lt; number3) ? <span class="built_in">min</span>:number3;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">min</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;两个链表的第一个公共结点&quot;&gt;&lt;a href=&quot;#两个链表的第一个公共结点&quot; class=&quot;headerlink&quot; title=&quot;两个链表的第一个公共结点&quot;&gt;&lt;/a&gt;两个链表的第一个公共结点&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;问题描述：输入两个链表，找出它们的第一个公共结点。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这道题第一次很容易想到，在第一个链表上遍历每个结点的时候再在第二个链表顺序遍历所有的结点，如果第二个链表上有一个结点和第一个链表上的结点一样，则返回该结点。但是这样的遍历方式会导致时间复杂度为O(mn);
    
    </summary>
    
      <category term="面试" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>2018-03-11</title>
    <link href="http://yoursite.com/2018/03/11/2018-03-11/"/>
    <id>http://yoursite.com/2018/03/11/2018-03-11/</id>
    <published>2018-03-11T15:33:03.000Z</published>
    <updated>2018-03-12T01:36:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天是喜欢糖永永同学的第60天，在这60天里我知道了她的很多故事和经历。看到了她的各种表情，生气、难过、开心、犹豫、纠结、茫然、撒娇。。。我知道了她是一个非常非常感性的姑娘。<a id="more"></a></p><p>有人说，真正的爱是不会计算的。从来没有全心全意爱过一个人，从来没有想过一个人可以让我无时无刻不充满动力，又无时无刻不想念纠结。她在这60天里做到了，是的呢，虽然时间有点短，但是在这段时里我真正得陷入了她的漩涡。<br>我欣赏她对生活的态度，即使自己遍历鳞伤也不忘微笑对待这个世界；我喜欢她那种安静，表面平平淡淡，内心星月沉浮；我喜欢她洒脱的微笑，所有眼泪与痛苦都一笑而过（其实并没有-_-）；我喜欢她吃饭的样子，很慢很慢得吃了很多^_^。我特别喜欢看她，她笑起来很自然，如沐春风。<br>她现在能够接受我，但是她还没有答应我，因为她需要时间去淡化之前那段刻骨铭心的经历。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天是喜欢糖永永同学的第60天，在这60天里我知道了她的很多故事和经历。看到了她的各种表情，生气、难过、开心、犹豫、纠结、茫然、撒娇。。。我知道了她是一个非常非常感性的姑娘。
    
    </summary>
    
      <category term="日记" scheme="http://yoursite.com/categories/life/"/>
    
    
  </entry>
  
  <entry>
    <title>如何实现守护进程</title>
    <link href="http://yoursite.com/2018/03/11/C-%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E5%87%86%E5%A4%87%EF%BC%9A%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B/"/>
    <id>http://yoursite.com/2018/03/11/C-面试问题准备：如何实现守护进程/</id>
    <published>2018-03-11T11:27:06.000Z</published>
    <updated>2018-03-14T13:23:16.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h3><p>守护进程也称精灵进程(Daemon)，是运行在后台的一种特殊进程。它独立于控制终端并且周期性的执行某种任务或等待处理某些发送的事件。Linux上的大多数服务器就是用守护进程实现的。 <a id="more"></a></p><blockquote><p>守护进程可以解决产生死锁的一个必要条件，资源独占问题。即可以实现间接线程资源共享，对于打印机来说我们不允许任何线程直接占有，而是设计一个”精灵程序”（守护进程）来管理。这个进程独占打印机，所有的打印任务都由它发出，任何一个线程想要打印，不是直接请求打印机，而是将打印要求发给这个守护进程指定的地方，这个守护进程将负责完成任务打印。</p></blockquote><p>Linux系统启动时会启动很多系统服务进程，这些系统服务进程没有控制终端，不能直接和用户交互。其他进程启东市都是在用户登录或运行程序是创建，在运行结束或用户注销时终止，但系统服务进程不受用户登录注销影响，他们一直运行着。这种进程就叫做守护进程(精灵进程)（Deamon）。 </p><p>如下图，一般守护进程会在程序运行名后面多一个d,但不是所有尾字母是d的都是守护进程。</p><p><img src="/images/linuxImages/deamon.png" alt=""></p><h3 id="创建守护进程"><a href="#创建守护进程" class="headerlink" title="创建守护进程"></a>创建守护进程</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">pid_t</span> setsid(<span class="keyword">void</span>); <span class="comment">//setid()创建成功后返回新建的会话ID，出错返回-1;</span></span><br></pre></td></tr></table></figure><p>所以我们在调用setsid()函数之前，必须先fork()创建父子进程，父子进程在同一个进程组中，父进程是组长进程，所以子进程符合条件，将父进程退出即可满足要求； </p><p>步骤：</p><p>1、调用umask()将文件模式创建屏蔽字设置为0；<br>2、调用fork，父进程退出。//1、保证守护进程不是进程组长<br>3、调用setsid创建一个会话。//setsid会导致：1、调用进程成为新会话的首进程，2、调用进程成为一个进程组的组长进程，3、调用进程没有控制终端。<br>4、将当前工作目录更改我根目录。//系统中除了跟目录都可以被删除<br>5、关闭不在需要的文件描述符<br>6、忽略SIGCHLD信号；</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;守护进程&quot;&gt;&lt;a href=&quot;#守护进程&quot; class=&quot;headerlink&quot; title=&quot;守护进程&quot;&gt;&lt;/a&gt;守护进程&lt;/h3&gt;&lt;p&gt;守护进程也称精灵进程(Daemon)，是运行在后台的一种特殊进程。它独立于控制终端并且周期性的执行某种任务或等待处理某些发送的事件。Linux上的大多数服务器就是用守护进程实现的。
    
    </summary>
    
      <category term="面试" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="OS" scheme="http://yoursite.com/tags/OS/"/>
    
  </entry>
  
</feed>
