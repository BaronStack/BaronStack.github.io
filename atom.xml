<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>那一刻 风情万种</title>
  
  <subtitle>我喜欢看你笑的样子</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-03-22T13:29:59.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>那一刻 风情万种</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2018-03-22</title>
    <link href="http://yoursite.com/2018/03/22/2018-03-22/"/>
    <id>http://yoursite.com/2018/03/22/2018-03-22/</id>
    <published>2018-03-22T13:16:21.000Z</published>
    <updated>2018-03-22T13:29:59.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天去参加了海康威视的签约，拿到了(10K + 1K)*15的薪资，在北京，当时我觉得自己有点傻，应该可以正确更高的，因为我是知道我在面试过程中的表现，所以对自己薪资还是不够满意。<a id="more"></a><br>最后又想了一下，刚毕业，相对于秋招时候的工作来说还是有很大的进步。只要自己在海康表现足够好，就一定有更多的机会去提升自己。小唐同学给我送了一个小鸡腿作为奖励，哈哈哈哈<br>重点是海康在北京的地点也是海淀区，哈哈，和她距离比较近。看看截图哦：  </p><p><img src="/images/path.png" alt=""></p><p>看了一下，哎呀，开心死我了，我们工作的地点距离她们学校居然只有600多米，啊哈哈哈哈哈哈哈哈哈哈哈哈，难道这就是所谓的缘分嘛，我并不知道在海康在北京的具体地点。。。。。。开心开心</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天去参加了海康威视的签约，拿到了(10K + 1K)*15的薪资，在北京，当时我觉得自己有点傻，应该可以正确更高的，因为我是知道我在面试过程中的表现，所以对自己薪资还是不够满意。
    
    </summary>
    
      <category term="日记" scheme="http://yoursite.com/categories/life/"/>
    
    
  </entry>
  
  <entry>
    <title>2018-03-21</title>
    <link href="http://yoursite.com/2018/03/22/2018-03-21/"/>
    <id>http://yoursite.com/2018/03/22/2018-03-21/</id>
    <published>2018-03-22T12:42:17.000Z</published>
    <updated>2018-03-22T13:31:59.000Z</updated>
    
    <content type="html"><![CDATA[<p>即喜欢糖永永的第70天！！！  </p><p>今天发生了一件快要让我崩溃的事情，糖永永同学不理我了。起因是昨天晚上她抱着我问我：以后我回云南，你也回吗？我当时也不知道脑袋在想什么，然后表现出来一点点犹豫，结果，瞬间她远离我3米，极度冷漠，向着宿舍的方向走去。<a id="more"></a></p><p>我当时还是一脸懵逼，我赶紧给她解释，可是她一句话也不说，直接走进了宿舍。我默默得站在了宿舍楼下，脑袋快要炸了。  </p><p>晚上会去看到她发的一首歌，她好像又把自己的内心藏起来了，这次好像是彻底藏起来了。听着歌词里”你再也不会梦或痛或心动了”，听着听着我的眼泪掉下来了。我。。。我并不是说不愿意给她结果，我只想要做一个慎重有结果的承诺，可她总会往坏处去想。  </p><p>第一次听着歌流了如此之多的眼泪，我内心对她的痛感觉如此之深刻。我只想说我肯定会给你一个结果的，可你总会将自己包裹起来，不去好好交流。  </p><p>给她发了很多信息，她不回，打电话也不接。在这期间感觉整个世界都是昏暗无光，老师打了电话说让去见一个公司老总，我用下午有面试的理由搪塞过去了。我不想去，躺在床上，心里老是想起她所承受的痛，想着她又将自己封闭，我就觉得我的世界真的快要塌了，突然发现我已经习惯性得想要呆在她身边，想要有她陪伴，即使她内心喜欢的还是小胖子我也无所谓。  </p><p>不行，一定要去找她，我不能就这样放手。给她打了电话问她在哪，听到她的声音瞬间的心痛又浮上心里，我的眼泪刷刷得向下流（我靠，写的时候才发现这是第一次在一个女生面前哭得如此凄惨，fuck），总之，听到她的声音我就特别想见她。  </p><p>哭着鼻子了解到她不在学校，我不能就这么放弃，不知道她什么时候回学校，估摸着她会回学校的时间，于是我就到她们宿舍楼下等了3个小时，失落得回到学校，走在路上发现一切的努力好像都没有意义了，一切的获得好像也没有意义了，什么北京，什么海康威视，都让我提不起兴趣，世界在昏暗得转动，我的内心如死去一般，因为我感觉我要失去她了。  </p><p>回到宿舍，突然收到她的微信，原来她手机没电了，然后说让我帮她报名。天哪，我的小心脏瞬间满血复活，我巴不得自己长出一对翅膀直接飞到她们学校去。这样的开心比获得年薪20W的工作更来的刺激，因为我喜欢的姑娘对我还是有点理睬的。  </p><p>之后就是在她们学校向她表明衷心，即使她的心还有一部分在别人身上依然阻挡不了我对她的喜欢。哎，接下来我们的动作就比较羞羞了，开心的一天！！！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;即喜欢糖永永的第70天！！！  &lt;/p&gt;
&lt;p&gt;今天发生了一件快要让我崩溃的事情，糖永永同学不理我了。起因是昨天晚上她抱着我问我：以后我回云南，你也回吗？我当时也不知道脑袋在想什么，然后表现出来一点点犹豫，结果，瞬间她远离我3米，极度冷漠，向着宿舍的方向走去。
    
    </summary>
    
      <category term="日记" scheme="http://yoursite.com/categories/life/"/>
    
    
  </entry>
  
  <entry>
    <title>西山居：开发工程师二面</title>
    <link href="http://yoursite.com/2018/03/20/%E8%A5%BF%E5%B1%B1%E5%B1%85%EF%BC%9A%E5%BC%80%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88%E4%BA%8C%E9%9D%A2/"/>
    <id>http://yoursite.com/2018/03/20/西山居：开发工程师二面/</id>
    <published>2018-03-20T09:18:02.000Z</published>
    <updated>2018-03-22T13:33:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>在海康威视HR面结束后收到了西山居来自珠海的二面，感觉有点尴尬，因为我知道当时我的一面过程是一塌糊涂，根本没有抱有二面的希望，又收到了二面通知。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在海康威视HR面结束后收到了西山居来自珠海的二面，感觉有点尴尬，因为我知道当时我的一面过程是一塌糊涂，根本没有抱有二面的希望，又收到了二面通知。&lt;/p&gt;

      
    
    </summary>
    
      <category term="面试" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
  </entry>
  
  <entry>
    <title>深信服：C++开发工程师面经</title>
    <link href="http://yoursite.com/2018/03/20/%E6%B7%B1%E4%BF%A1%E6%9C%8D%EF%BC%9AC-%E5%BC%80%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88%E9%9D%A2%E7%BB%8F/"/>
    <id>http://yoursite.com/2018/03/20/深信服：C-开发工程师面经/</id>
    <published>2018-03-20T05:05:00.000Z</published>
    <updated>2018-03-20T09:13:34.000Z</updated>
    
    <content type="html"><![CDATA[<p>本来以为深信服笔试应挂了，结果在第二天吃饭的时候竟然收到了深信服的面试通知，很是惊喜，但是经历的西山居的追根问底之后就发现自己在专业学习过程中还是存在很多的问题。<a id="more"></a><br>深信服的几个笔试编程题目做的不是很好：链表排序、棋盘遍历（简单深搜的应用）、哈夫曼编码的创建过程、求所有的出栈顺序。<br>面试我的是一个很温和的面试官，看起来也是技术大佬。<br>上来先让我做了一个自我介绍，自我介绍的过程中就是将我的项目功能、架构、用到的技术、遇到的问题都一一讲解。又涉及到了网络通信这里（感觉几乎所有的面试官都对网络通信这里情有独钟），面试官追根问底  </p><ol><li>select和epoll有什么区别，为什么选择使用select而不是epoll。如果让你实现epoll，你该会如何实现 </li><li>阻塞和非阻塞、同步和异步有什么区别  </li></ol><p>接下来他就拿出一张表，从上面挑选问题问我  </p><ol><li>C语言中如何查看文件大小 （fseek()）</li><li>二进制文件和文本文件的区别</li><li>C++中拷贝构造函数为什么先要加一个const,为什么传进去的参数是引用，为什么不能是指针</li><li>C++相比于C语言有什么优势</li><li>什么是僵尸进程，为什么会产生僵尸进程，如何避免僵尸进程</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本来以为深信服笔试应挂了，结果在第二天吃饭的时候竟然收到了深信服的面试通知，很是惊喜，但是经历的西山居的追根问底之后就发现自己在专业学习过程中还是存在很多的问题。
    
    </summary>
    
      <category term="面试" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
  </entry>
  
  <entry>
    <title>2018-03-19</title>
    <link href="http://yoursite.com/2018/03/19/2018-03-19/"/>
    <id>http://yoursite.com/2018/03/19/2018-03-19/</id>
    <published>2018-03-19T00:08:32.000Z</published>
    <updated>2018-03-20T09:13:34.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近大脑一直处于高度紧张状态，可能是由于过多的面试以及面试之后对不懂问题的极速学习让脑袋反应有点慢。不过还好有她的陪伴，给予了我莫大的鼓励与支持。<a id="more"></a><br>我告诉她，我其实是因为你才选择去北京，因为我知道你说过你不想异地。当然按照我的要求，北京生活的话得工资好一点，再一个就是进入一个对我来说我很喜欢的公司才行，这样可以在钱上不讲究，也可以在工作上不讲究。所以最近所面试的一些公司相对来说还是不错的，也是让我真正体会到了所谓技术面试是什么样子的。遇到了很多问题，也发现了自己在专业学习上的盲点，真的是受益匪浅。<br>不过每天忙完之后能够和小猪同学见一见，哎呀，还真是幸福感爆棚呢。<br>有很多同学很羡慕我的大学生活，不过仔细回想起来还真是做过好多事情呢，唯一的遗憾就是在专业学习上花费的时间太少，导致最后所花费的时间去学习一些基础性的东西实在是时间不够用。不过有失必有得，我去学习口语，去摄影摄像剪辑，去健身，去游览祖国的大好河山，这个过程也让我体会到了一种不同于学校的感受。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近大脑一直处于高度紧张状态，可能是由于过多的面试以及面试之后对不懂问题的极速学习让脑袋反应有点慢。不过还好有她的陪伴，给予了我莫大的鼓励与支持。
    
    </summary>
    
      <category term="日记" scheme="http://yoursite.com/categories/life/"/>
    
    
  </entry>
  
  <entry>
    <title>2018-03-16</title>
    <link href="http://yoursite.com/2018/03/17/2018-03-16/"/>
    <id>http://yoursite.com/2018/03/17/2018-03-16/</id>
    <published>2018-03-16T16:49:26.000Z</published>
    <updated>2018-03-20T09:13:34.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天，我和”小唐老师”一起吃了一大桌烧烤，看见她满脸堆笑容，我好开心啊！<a id="more"></a><br>之后我们一起进行了饭后百步走活动，嗯，这个百得在乘一个百。风吹着我和她的头发，我的手抓着她的手，看着她一直笑！这个时候所有的不愉快，所有因为白天自己在专业面试上被打击的不愉快都烟消云散。<br>风儿继续吹着，我们沿着人行道走在昏黄的灯光下，很静，路边那些”一夜尽是长安花”在昏黄灯光下看起来有一种安静的美。原来长安郊区的夜是这个样子的，广场上闪烁的灯光，灯光下映衬的不知名的白色花朵，以及嫩柳扬起的发支都让我感受到一种发自内心的安静。<br>我们依偎在亭子下的小长椅上，我偷偷吻了她，她看起来有点不高兴，但是我忍着脸皮厚被她打了几下，哈哈！看着她枕着我的手臂”目前已经变成她的专用枕头了”，静静得闭目养神。这样就挺好（原谅我最近专注于专业笔试面试，没有去看看看文学类的书，词穷了）！不过，说实话，今天看到的她真的好美好美！<br>每次疲惫的时候只要想起她我就充满动力，我大概知道了她以后想要什么样子的生活，也知道她以后可能会回到老家，我会想尽一切办法和她在一起。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天，我和”小唐老师”一起吃了一大桌烧烤，看见她满脸堆笑容，我好开心啊！
    
    </summary>
    
      <category term="日记" scheme="http://yoursite.com/categories/life/"/>
    
    
  </entry>
  
  <entry>
    <title>西山居：开发工程师面经</title>
    <link href="http://yoursite.com/2018/03/16/%E8%A5%BF%E5%B1%B1%E5%B1%85%EF%BC%9A%E5%BC%80%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88%E9%9D%A2%E7%BB%8F/"/>
    <id>http://yoursite.com/2018/03/16/西山居：开发工程师面经/</id>
    <published>2018-03-16T03:20:41.000Z</published>
    <updated>2018-03-16T04:05:25.000Z</updated>
    
    <content type="html"><![CDATA[<p>当我写下这篇博客的时候其实已经知道我此次面试已经没戏了，但是我还是想要反思自我实力以及对网上所谓西山居面经的吐槽（网上的面经太简单了）。  </p><p>昨晚收到面试通知，我是C／C++方向，之后就一直在具体准备，先是网上的面经，就是一些较为基础的问题： <a id="more"></a> </p><ol><li>堆和栈的区别</li><li>静态库和动态库的区别，什么时候动态链接库需要的内存会超过静态库</li><li>Linux动态库的后缀名是什么</li><li>windows的任务调度机制</li><li>模版的实现原理，以及类型是在编译期绑定还是在运行期绑定</li><li>double的精度问题，0.1能精确表示吗</li><li>给一个ip地址，/22，写出子网掩码和广播地址</li><li>c++中的虚函数表</li><li>说说四次挥手的过程，为什么握手要三次，挥手要四次</li><li>linux的终端的工作方式</li><li>shell脚本里面用过哪些命令</li><li>在公司内网ping www.baidu.com的过程，使用了哪些网络协议</li><li>map里面如何删除一个元素</li><li>你写的程序cpu占用很高怎么办</li><li>程序崩溃了一般的debug步骤</li></ol><p>接下来就是我被问到的问题，面试官一看就是一个搞技术的，一上来就是各种技术问题！自我介绍的时候我有介绍到我做的项目是linux QT下的，主要涉及网络通信。</p><ol><li>QT的跨平台机制是怎么实现的，为什么它可以在Linux、MAC、Windows下运行</li><li>什么是阻塞，非阻塞、select()和epoll的区别</li><li>多线程和多进程的区别，各自的优缺点</li><li>Linux下查找指定文件名的文件（find），查找文件中指定的独立字符串(想不出来，好像是grep的某个同类命令)</li><li>awk和sed了解吗(没有好好准备)</li><li>vi非编辑模式下替换字符</li><li>C++ 的跨平台机制，为什么它可以在windows、Linux下运行</li><li>Java的跨平台机制，Java和C/C++的区别</li><li>python下创建一个0-9的数组</li><li>mysql 和mongodb的区别</li><li>MySQL，Oracle，Access的区别</li><li>NoSQL和关系型数据库的区别</li><li>我写了我了解过tensor flow,问了常用的激励函数(relu,sigmoid)，各自的优缺点</li><li>RNN和LSTM的区别</li><li>git如何创建一个分支,git的stash（git的核心）</li><li>C／C++标准出来的新特性说说</li><li>两个智能指针的用法</li><li>static关键字的作用</li><li>函数栈是在什么时候创建的，具体的过程</li><li>你所了解的服务器技术</li><li>QQ服务器是怎么运作的</li><li>端游中数据的交互</li></ol><p>总结：我大概只能想到这么多了。面试官是根据个人简历去问的，自我介绍的时候发掘你项目中用到的技术，然后根据你的技能点去问你熟悉的东。其中很多我答的都不好甚至没有答上来，面试官就说你对低层实现不够了解，对自己发展方向不够清晰，说是C++服务器方向，但是大多做的东西都是C端，而且一些常见的服务器技术都不去了解，Linux命令不够熟悉（很长时间没有练了，一直在总结问题）。<br>总之还是个人基础不够扎实，所以以后学习大概模拟一个方向：搞清楚软件的运行原理，然后由大及小，遇到细节上的问题也是穷尽原理，这样学到的东西才有体系，才有深度。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当我写下这篇博客的时候其实已经知道我此次面试已经没戏了，但是我还是想要反思自我实力以及对网上所谓西山居面经的吐槽（网上的面经太简单了）。  &lt;/p&gt;
&lt;p&gt;昨晚收到面试通知，我是C／C++方向，之后就一直在具体准备，先是网上的面经，就是一些较为基础的问题：
    
    </summary>
    
      <category term="面试" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux常用信号</title>
    <link href="http://yoursite.com/2018/03/15/Linux%E5%B8%B8%E7%94%A8%E4%BF%A1%E5%8F%B7/"/>
    <id>http://yoursite.com/2018/03/15/Linux常用信号/</id>
    <published>2018-03-15T03:43:58.000Z</published>
    <updated>2018-03-16T04:05:25.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="常用Linux信号"><a href="#常用Linux信号" class="headerlink" title="常用Linux信号"></a>常用Linux信号</h2><p><img src="/images/kill.png" alt=""></p><blockquote><p>Linux系统下有很多信号，按照可靠性可以分为可靠信号和非可靠信号，按时间分为实时信号和非实时信号。</p></blockquote><p>Linux有三种方式来处理收到的信号：</p><ul><li>忽略信号：即对信号不作处理（除了SIGKILL和SIGSTOP）</li><li>捕捉信号：定义信号处理函数，当信号发生时，执行相应的处理函数</li><li>执行缺省操作，Linux对每种信号都规定了默认操作</li></ul><p>常用信号如下：</p><ol><li><strong><font color="#DC143C">SIGHUP</font></strong> 和控制台操作相关，当控制台被关闭的时候系统会向拥有控制台sessionID的进程发送HUP信号，默认HUP信号执行的action是exit,如果远程登启动某个服务进程，并在程序运行时关闭某个链接的会话导致服务进程退出，所以服务程序一般都会用nohup工具启动（该命令就是让系统忽略该信号），或者写一个daemon<a href="">守护进程</a>(利用setsid进行)。</li><li><strong><font color="#DC143C">SIGINT</font></strong> 终止进程，通常我们的ctrl+c就发送这个消息</li><li><strong><font color="#DC143C">SIGQUIT</font></strong> 和SIGINT类似, 但由QUIT字符(通常是Ctrl- / )来控制. 进程收到该消息退出时会产生core文件。</li><li><strong><font color="#DC143C">SIGKILL</font></strong> 消息编号为9，我们经常用kill -9来杀死进程,发送的就是这个消息，程序收到这个消息立即终止，这个消息不能被捕获，封锁或忽略，所以是杀死进程的终极武器。</li><li><strong><font color="#DC143C">SIGTERM</font></strong> 不带参数时kill默认发送的信号，默认是杀死进程</li><li><strong><font color="#DC143C">SIGSTOP</font></strong> 停止进程的执行，同SIGKILL一样不可以被应用程序所处理，注意它和terminate以及interrupt的区别:该进程还未结束, 只是暂停执行</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;常用Linux信号&quot;&gt;&lt;a href=&quot;#常用Linux信号&quot; class=&quot;headerlink&quot; title=&quot;常用Linux信号&quot;&gt;&lt;/a&gt;常用Linux信号&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/images/kill.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;b
      
    
    </summary>
    
      <category term="面试" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>系统调用与函数调用</title>
    <link href="http://yoursite.com/2018/03/15/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E4%B8%8E%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8/"/>
    <id>http://yoursite.com/2018/03/15/系统调用与函数调用/</id>
    <published>2018-03-15T02:33:24.000Z</published>
    <updated>2018-03-15T03:40:31.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Linux下对文件的操作有两种方式：系统调用（system call）和库函数调用（Library Functions）</p></blockquote><h3 id="系统调用（system-call）"><a href="#系统调用（system-call）" class="headerlink" title="系统调用（system call）"></a>系统调用（system call）</h3><blockquote><p>指运行在<font color="#DC143C">用户空间</font>的<font color="#DC143C">应用程序</font>向<font color="#DC143C">操作系统内核</font>请求某些服务的过程。系统调用提供了用户程序与操作系统之间的接口。一般来说系统调用都是在内核态执行，由于系统调用不考虑平台差异性，它是由内核直接提供，因而移植性较差（几乎没有移植性）。<a id="more"></a></p></blockquote><p>这里简单介绍一下Linux系统下常见的系统调用：</p><ul><li><p>getpid,getppid—获取进程识别号</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">pid_t</span> getpid(<span class="keyword">void</span>);<span class="comment">// 获取进程标识号，它可以作为当前进程的唯一标识</span></span><br><span class="line"><span class="keyword">pid_t</span> getppid(<span class="keyword">void</span>);<span class="comment">//获取当前进程的父进程标识号</span></span><br></pre></td></tr></table></figure></li><li><p>fork创建子进程</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">pid_t</span> fork(<span class="keyword">void</span>); <span class="comment">//通过完全复制当前进程创建一个子进程</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">如果创建子进程成功，在父进程中返回子进程的进程标示符，在子进程中返回0。</span></span><br><span class="line"><span class="comment">如果失败，在父进程中返回-1，子进程不会被创建，errno被设置。</span></span><br><span class="line"><span class="comment">因为在fork()的调用处，整个父进程空间会原模原样地复制到子进程中，包括指令，</span></span><br><span class="line"><span class="comment">变量值，程序调用栈，环境变量，缓冲区，等等。所以，子进程和父进程是不能通过</span></span><br><span class="line"><span class="comment">程序内的变量（即使是全局变量）通信的，对于这两个进程来说，它们有各自的进程空间，</span></span><br><span class="line"><span class="comment">互不影响。但父进程和子进程可以通过管道，共享内存，等方式实现通信。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li><li><p>sleep时进程睡眠指定的秒数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">sleep</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> seconds)</span></span>;<span class="comment">//到达指定时间后返回0，若有信号中断，则返回剩余的秒数</span></span><br></pre></td></tr></table></figure></li><li><p>wait,waitpid等待子进程终止</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="keyword">pid_t</span> wait(<span class="keyword">int</span> *status);</span><br><span class="line"><span class="keyword">pid_t</span> waitpid(<span class="keyword">pid_t</span> pid, <span class="keyword">int</span> *status, <span class="keyword">int</span> options);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">等待子进程的状态发生变化：子进程终止，子进程被信号停止，子进程被信号恢复。</span></span><br><span class="line"><span class="comment">wait等待一个子进程终止，waitpid等待pid指定的子进程状态改变。默认waitpid仅等待子进程终止，</span></span><br><span class="line"><span class="comment">可以通过options来改变行为,waitpid执行成功返回状态改变子进程的进程号；</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>具体详细的系统调用可以参考<font color="#DC143C"><a href="http://blog.csdn.net/gwq5210/article/details/41345339" target="_blank" rel="noopener">Linux下系统调用</a></font></strong></p><h3 id="库函数（Library-Functions）"><a href="#库函数（Library-Functions）" class="headerlink" title="库函数（Library Functions）"></a>库函数（Library Functions）</h3><blockquote><p>由用户或组织自己开发的，具有一定功能的函数集合，一般具有较好平台移植性，通过库文件（静态库或动态库）向程序员提供功能性调用。程序员无需关心平台差异，由库来屏蔽平台差异性。</p></blockquote><p>库函数一般分为两类：C语言标准规定的库函数和编译器特定的库函数。可以理解库函数为系统调用的一层封装（大部分），比如：如printf的实现最终还是调用了putc()和user.h中的write()这样的系统调用，而另一些则不会使用系统调用，比如strlen，strcat，memcpy等  </p><blockquote><p>既然使用库函数调用也有系统调用的开销，那为什么不直接使用系统调用呢?<br>因为读写文件通常是大量的数据（这种大量是相对于底层驱动的系统调用所需要的数据单位而言），使用库函数可以大大减少系统调用的次数。<strong><font color="#DC143C">缓冲区技术的出现，在用户空间和内核空间，对文件的操作都是用了缓冲区技术，当内核缓冲区写满之后才将内核缓冲区中的数据写入文件对应的硬件媒介中，而不是每写一次，就要执行一次系统调用，再切换到用户空间写如磁盘。对CPU处理效率消耗比较大</font></strong></p></blockquote><h3 id="系统调用和库函数的区别"><a href="#系统调用和库函数的区别" class="headerlink" title="系统调用和库函数的区别"></a>系统调用和库函数的区别</h3><p><img src="/images/syscall.png" alt=""></p><h3 id="联系"><a href="#联系" class="headerlink" title="联系"></a>联系</h3><blockquote><p>内核功能与操作系统特性紧密相关的服务，由系统调用提供<br>具有共通特性的功能一般需要较好的平台移植性，故而由库函数提供</p></blockquote><p>库函数与系统调用在功能上相互补充，如进程间通信资源的管理，进程控制等功能与平台特性和内核息息相关，必须由系统调用来实现<br>文件 I/O操作等各平台都具有的共通功能一般采用库函数，也便于跨平台移植<br>库函数与系统调用也有交集，如 库函数中的I/O操作的内部实现依然需要调用系统的I/O方能实现</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Linux下对文件的操作有两种方式：系统调用（system call）和库函数调用（Library Functions）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;系统调用（system-call）&quot;&gt;&lt;a href=&quot;#系统调用（system-call）&quot; class=&quot;headerlink&quot; title=&quot;系统调用（system call）&quot;&gt;&lt;/a&gt;系统调用（system call）&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;指运行在&lt;font color=&quot;#DC143C&quot;&gt;用户空间&lt;/font&gt;的&lt;font color=&quot;#DC143C&quot;&gt;应用程序&lt;/font&gt;向&lt;font color=&quot;#DC143C&quot;&gt;操作系统内核&lt;/font&gt;请求某些服务的过程。系统调用提供了用户程序与操作系统之间的接口。一般来说系统调用都是在内核态执行，由于系统调用不考虑平台差异性，它是由内核直接提供，因而移植性较差（几乎没有移植性）。
    
    </summary>
    
      <category term="面试" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="OS" scheme="http://yoursite.com/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>项目问题总结</title>
    <link href="http://yoursite.com/2018/03/13/%E9%A1%B9%E7%9B%AE%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2018/03/13/项目问题总结/</id>
    <published>2018-03-13T15:29:42.000Z</published>
    <updated>2018-03-14T09:52:15.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题一：主机间通信断开链接后重新连接失败，显示接受（C端）端口被占用"><a href="#问题一：主机间通信断开链接后重新连接失败，显示接受（C端）端口被占用" class="headerlink" title="问题一：主机间通信断开链接后重新连接失败，显示接受（C端）端口被占用"></a>问题一：主机间通信断开链接后重新连接失败，显示接受（C端）端口被占用</h2><h3 id="分析："><a href="#分析：" class="headerlink" title="分析："></a><font color="#DC143C">分析：</font></h3><p>主机之间建立的链接属于TCP链接，断开的时候会发生TCP四次挥手，过程中C端会进入TIME_WAIT状态，有时S端主动断开链接的时候也会导致S端进入TIME_WAIT状态。即我们断开TCP链接的时候并没有完全断开，此时S端还处于TIME_WAIT，导致通信端口被占用，无法创建新的链接。<a id="more"></a></p><p><img src="/images/time_wait.png" alt=""></p><h3 id="为什么会有TIME-WAIT状态的原因："><a href="#为什么会有TIME-WAIT状态的原因：" class="headerlink" title="为什么会有TIME_WAIT状态的原因："></a><font color="#DC143C">为什么会有TIME_WAIT状态的原因：</font></h3><ul><li>可靠的终止TCP链接</li></ul><blockquote><p>若处于time_wait的客户端发送给服务器确认报文段丢失的话，服务器将在此重新发送FIN报文段，那么客户端必须处于一个可接收的状态就是time_wait而不是close状态</p><ul><li>保证让迟来的TCP报文段有足够的时间被识别并丢弃</li></ul><p>linux 中一个TCP端口不能打开两次或两次以上，当客户端处于time_wait状态时我们将无法使用此端口建立新连接，如果不存在time_wait状态，新连接可能会收到旧连接的数据。time_wait持续的时间是2MSL，保证旧的数据可以丢弃，因为网络中的数据最大存在MSL</p></blockquote><h3 id="解决TIME-WAIT的状态占用："><a href="#解决TIME-WAIT的状态占用：" class="headerlink" title="解决TIME_WAIT的状态占用："></a><font color="#DC143C">解决TIME_WAIT的状态占用：</font></h3><ul><li>通过socket的选项SO_REUSEADDR来强制进程立即使用处于time_wait状态的连接占用的端口，即使sock处于time_wait状态，与之绑定的socket地址也可以立即被重用 </li><li>修改内核参数/proc/sys/net/ipv4/tcp_tw/recycle来快速回收被关闭的socket,从而是tcp连接根本不进入time_wait状态，进而允许应用程序立即重用本地的socket地址。详细修改方式可以参考文章<a href="https://www.cnblogs.com/balaamwe/archive/2011/12/07/2279282.html" target="_blank" rel="noopener">如何优雅得关闭socket</a></li></ul><h2 id="问题二：多个C端同时向数据库写／取数据，如何防止数据被覆盖"><a href="#问题二：多个C端同时向数据库写／取数据，如何防止数据被覆盖" class="headerlink" title="问题二：多个C端同时向数据库写／取数据，如何防止数据被覆盖"></a>问题二：多个C端同时向数据库写／取数据，如何防止数据被覆盖</h2><h4 id="MySQL的并发控制与加锁分析"><a href="#MySQL的并发控制与加锁分析" class="headerlink" title="MySQL的并发控制与加锁分析"></a>MySQL的并发控制与加锁分析</h4>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;问题一：主机间通信断开链接后重新连接失败，显示接受（C端）端口被占用&quot;&gt;&lt;a href=&quot;#问题一：主机间通信断开链接后重新连接失败，显示接受（C端）端口被占用&quot; class=&quot;headerlink&quot; title=&quot;问题一：主机间通信断开链接后重新连接失败，显示接受（C端）端口被占用&quot;&gt;&lt;/a&gt;问题一：主机间通信断开链接后重新连接失败，显示接受（C端）端口被占用&lt;/h2&gt;&lt;h3 id=&quot;分析：&quot;&gt;&lt;a href=&quot;#分析：&quot; class=&quot;headerlink&quot; title=&quot;分析：&quot;&gt;&lt;/a&gt;&lt;font color=&quot;#DC143C&quot;&gt;分析：&lt;/font&gt;&lt;/h3&gt;&lt;p&gt;主机之间建立的链接属于TCP链接，断开的时候会发生TCP四次挥手，过程中C端会进入TIME_WAIT状态，有时S端主动断开链接的时候也会导致S端进入TIME_WAIT状态。即我们断开TCP链接的时候并没有完全断开，此时S端还处于TIME_WAIT，导致通信端口被占用，无法创建新的链接。
    
    </summary>
    
      <category term="面试" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
  </entry>
  
  <entry>
    <title>Base64编码方式及实现代码</title>
    <link href="http://yoursite.com/2018/03/13/C-%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E5%87%86%E5%A4%87%EF%BC%9ABase64%E7%BC%96%E7%A0%81%E6%96%B9%E5%BC%8F%E5%8F%8A%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81/"/>
    <id>http://yoursite.com/2018/03/13/C-面试问题准备：Base64编码方式及实现代码/</id>
    <published>2018-03-13T13:39:21.000Z</published>
    <updated>2018-03-14T13:59:20.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>之前根本就没有听过base64编码，可能还是对网络这里了解不够，参加了北京柠檬微趣的现场笔试，看到了这个题目，当时想的太简单了，其实本来思路想好之后就不会很难，可惜先入为主了，导致没有参加面试机会，可惜可惜！！！<br>特总结base64编码实现如下：<br><a id="more"></a></p><h2 id="Base64编码"><a href="#Base64编码" class="headerlink" title="Base64编码"></a>Base64编码</h2></blockquote><p>是一种基于64个可打印字符来表示二进制数据的表示方法!它是一种将二进制编码转换为可打印字符一种。<br>它是MIME编码里面非常常见一种可逆转换二进制方法！现常用于电子邮件中，邮件类型声明如：Content-Transfer-Encoding: base64 。</p><h2 id="编码原理"><a href="#编码原理" class="headerlink" title="编码原理"></a>编码原理</h2><p>我们知道三个字节有24个位元，就可以刚好对应于4个Base64单元，即3个字节需要用4个Base64的可打印字符来表示。在Base64中的可打印字符包括字母A-Z、a-z、数字0-9 ，这样共有62个字符，此外两个可打印符号在不同的系统中一般有所不同。但是，我们经常所说的Base64另外2个字符是：“+/”。这64个字符，所对应表如下。<br><img src="/images/base64.png" alt=""></p><p>转换的时候按照如下方法:</p><p><font color="#DC143C">将输入数据流每次取6 bit，用此6 bit的值(0-63)作为索引去查表，输出相应字符。这样，每3个字节将编码为4个字符(3×8 → 4×6)；不满4个字符的以’=’填充</font><br>如下图：</p><p><img src="/images/base.png" alt=""></p><p>主要是通过位运算符将6bit的数据提取出来，并且对最后不足6位的bit进行补位。</p><p>代码如下:</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> EnBase64Tab[] = <span class="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"</span>;</span><br><span class="line"><span class="keyword">int</span> CBase64::EncodeBase64(<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span>* pSrc, <span class="keyword">char</span>* pDst, <span class="keyword">int</span> nSrcLen, <span class="keyword">int</span> nMaxLineLen)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> c1, c2, c3;    <span class="comment">// 输入缓冲区读出3个字节</span></span><br><span class="line">    <span class="keyword">int</span> nDstLen = <span class="number">0</span>;             <span class="comment">// 输出的字符计数</span></span><br><span class="line">    <span class="keyword">int</span> nLineLen = <span class="number">0</span>;            <span class="comment">// 输出的行长度计数</span></span><br><span class="line">    <span class="keyword">int</span> nDiv = nSrcLen / <span class="number">3</span>;      <span class="comment">// 输入数据长度除以3得到的倍数</span></span><br><span class="line">    <span class="keyword">int</span> nMod = nSrcLen % <span class="number">3</span>;      <span class="comment">// 输入数据长度除以3得到的余数</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 每次取3个字节，编码成4个字符</span></span><br><span class="line">    <span class="built_in">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nDiv; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 取3个字节</span></span><br><span class="line">        c1 = *pSrc++;</span><br><span class="line">        c2 = *pSrc++;</span><br><span class="line">        c3 = *pSrc++;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 编码成4个字符</span></span><br><span class="line">        *pDst++ = EnBase64Tab[c1 &gt;&gt; <span class="number">2</span>];</span><br><span class="line">        *pDst++ = EnBase64Tab[((c1 &lt;&lt; <span class="number">4</span>) | (c2 &gt;&gt; <span class="number">4</span>)) &amp; <span class="number">0x3f</span>];</span><br><span class="line">        *pDst++ = EnBase64Tab[((c2 &lt;&lt; <span class="number">2</span>) | (c3 &gt;&gt; <span class="number">6</span>)) &amp; <span class="number">0x3f</span>];</span><br><span class="line">        *pDst++ = EnBase64Tab[c3 &amp; <span class="number">0x3f</span>];</span><br><span class="line">        nLineLen += <span class="number">4</span>;</span><br><span class="line">        nDstLen += <span class="number">4</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 是否输出换行？</span></span><br><span class="line">        <span class="built_in">if</span> (nLineLen &gt; nMaxLineLen - <span class="number">4</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            *pDst++ = <span class="string">'/r'</span>;</span><br><span class="line">            *pDst++ = <span class="string">'/n'</span>;</span><br><span class="line">            nLineLen = <span class="number">0</span>;</span><br><span class="line">            nDstLen += <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 编码余下的字节</span></span><br><span class="line">    <span class="built_in">if</span> (nMod == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        c1 = *pSrc++;</span><br><span class="line">        *pDst++ = EnBase64Tab[(c1 &amp; <span class="number">0xfc</span>) &gt;&gt; <span class="number">2</span>];</span><br><span class="line">        *pDst++ = EnBase64Tab[((c1 &amp; <span class="number">0x03</span>) &lt;&lt; <span class="number">4</span>)];</span><br><span class="line">        *pDst++ = <span class="string">'='</span>;</span><br><span class="line">        *pDst++ = <span class="string">'='</span>;</span><br><span class="line">        nLineLen += <span class="number">4</span>;</span><br><span class="line">        nDstLen += <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">else</span> <span class="built_in">if</span> (nMod == <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        c1 = *pSrc++;</span><br><span class="line">        c2 = *pSrc++;</span><br><span class="line">        *pDst++ = EnBase64Tab[(c1 &amp; <span class="number">0xfc</span>) &gt;&gt; <span class="number">2</span>];</span><br><span class="line">        *pDst++ = EnBase64Tab[((c1 &amp; <span class="number">0x03</span>) &lt;&lt; <span class="number">4</span>) | ((c2 &amp; <span class="number">0xf0</span>) &gt;&gt; <span class="number">4</span>)];</span><br><span class="line">        *pDst++ = EnBase64Tab[((c2 &amp; <span class="number">0x0f</span>) &lt;&lt; <span class="number">2</span>)];</span><br><span class="line">        *pDst++ = <span class="string">'='</span>;</span><br><span class="line">        nDstLen += <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 输出加个结束符</span></span><br><span class="line">    *pDst = <span class="string">'/0'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">return</span> nDstLen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;之前根本就没有听过base64编码，可能还是对网络这里了解不够，参加了北京柠檬微趣的现场笔试，看到了这个题目，当时想的太简单了，其实本来思路想好之后就不会很难，可惜先入为主了，导致没有参加面试机会，可惜可惜！！！&lt;br&gt;特总结base64编码实现如下：&lt;br&gt;
    
    </summary>
    
      <category term="面试" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>实现String类</title>
    <link href="http://yoursite.com/2018/03/13/C-%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E5%87%86%E5%A4%87-%E5%AE%9E%E7%8E%B0String%E7%B1%BB/"/>
    <id>http://yoursite.com/2018/03/13/C-面试问题准备-实现String类/</id>
    <published>2018-03-13T10:04:21.000Z</published>
    <updated>2018-03-14T13:33:59.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="String-类"><a href="#String-类" class="headerlink" title="String 类"></a>String 类</h2><p>原型如下：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class <span class="keyword">String</span></span><br><span class="line">&#123; </span><br><span class="line"> <span class="keyword">public</span>: </span><br><span class="line"> <span class="keyword">String</span>(<span class="keyword">const</span> <span class="keyword">char</span> *str = NULL); <span class="comment">// 普通构造函数 </span></span><br><span class="line"> <span class="keyword">String</span>(<span class="keyword">const</span> <span class="keyword">String</span> &amp;other); <span class="comment">// 拷贝构造函数 </span></span><br><span class="line"> ~ <span class="keyword">String</span>(<span class="keyword">void</span>); <span class="comment">// 析构函数 </span></span><br><span class="line"> <span class="keyword">String</span> &amp; <span class="keyword">operator</span> =(<span class="keyword">const</span> <span class="keyword">String</span> &amp;other); <span class="comment">// 赋值函数 </span></span><br><span class="line"> <span class="keyword">private</span>: </span><br><span class="line"> <span class="keyword">char</span> *m_data; <span class="comment">// 用于保存字符串 </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><a id="more"></a><p>具体实现:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">String::String(<span class="keyword">const</span> <span class="keyword">char</span> * str) &#123;</span><br><span class="line">    <span class="keyword">if</span> (str == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        m_data = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (m_data == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"内存分配失败"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        *m_data = <span class="string">'\0'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="built_in">strlen</span>(str);</span><br><span class="line">        m_data = <span class="keyword">new</span> <span class="keyword">char</span>[len + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">//同样可以加分配失败的处理</span></span><br><span class="line">        <span class="built_in">strcpy</span>(m_data,str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String::~String(<span class="keyword">void</span>) &#123;</span><br><span class="line">    <span class="keyword">delete</span>[] m_data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String::String(<span class="keyword">const</span> String &amp;other) &#123;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(other.m_data);</span><br><span class="line">    m_data = <span class="keyword">new</span> <span class="keyword">char</span>[len + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(m_data,other.m_data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String &amp; String :: <span class="keyword">operator</span> = (<span class="keyword">const</span> String &amp;other) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;other) &#123;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> [] m_data;</span><br><span class="line">    <span class="keyword">int</span> length = <span class="built_in">strlen</span>( other.m_data ); </span><br><span class="line">    m_data = <span class="keyword">new</span> <span class="keyword">char</span>[length+<span class="number">1</span>]; 　</span><br><span class="line">    <span class="built_in">strcpy</span>( m_data, other.m_data ); </span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>; 　　　　　　　　<span class="comment">//得分点：返回本对象的引用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;String-类&quot;&gt;&lt;a href=&quot;#String-类&quot; class=&quot;headerlink&quot; title=&quot;String 类&quot;&gt;&lt;/a&gt;String 类&lt;/h2&gt;&lt;p&gt;原型如下：&lt;/p&gt;
&lt;figure class=&quot;highlight arduino&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;class &lt;span class=&quot;keyword&quot;&gt;String&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt;: &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;keyword&quot;&gt;String&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; *str = NULL); &lt;span class=&quot;comment&quot;&gt;// 普通构造函数 &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;keyword&quot;&gt;String&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;String&lt;/span&gt; &amp;amp;other); &lt;span class=&quot;comment&quot;&gt;// 拷贝构造函数 &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; ~ &lt;span class=&quot;keyword&quot;&gt;String&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;); &lt;span class=&quot;comment&quot;&gt;// 析构函数 &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;keyword&quot;&gt;String&lt;/span&gt; &amp;amp; &lt;span class=&quot;keyword&quot;&gt;operator&lt;/span&gt; =(&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;String&lt;/span&gt; &amp;amp;other); &lt;span class=&quot;comment&quot;&gt;// 赋值函数 &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt;: &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; *m_data; &lt;span class=&quot;comment&quot;&gt;// 用于保存字符串 &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="面试" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>KMP算法</title>
    <link href="http://yoursite.com/2018/03/13/C-%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E5%87%86%E5%A4%87%EF%BC%9AKMP%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2018/03/13/C-面试问题准备：KMP算法/</id>
    <published>2018-03-12T16:35:13.000Z</published>
    <updated>2018-03-14T13:21:03.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在说KMP算法之前先说一下普通的模式匹配算法</p></blockquote><h2 id="BF蛮力算法–字符串匹配"><a href="#BF蛮力算法–字符串匹配" class="headerlink" title="BF蛮力算法–字符串匹配"></a>BF蛮力算法–字符串匹配</h2><font size="5">算法思想：</font><br><font color="#DC143C">从目标串T的的第一个字符起与模式串P的第一个字符比较<br>若相等，则继续对字符进行后续的比较<br>否则目标串从第二个字符起与模式串的第一个字符重新比较<br>直至模式串中的每个字符依次和目标串中的一个连续的字符序列相等为止，此时称为匹配成功，否则匹配失败</font> <a id="more"></a><br><br><font size="5">算法性能：</font><br><font color="#DC143C">假设模式串的长度是m，目标串的长度是n.<br>最坏情况即每次模式串都是在最后一个出现不等，最坏的时间复杂度为O(mn),因为其回溯比较，从而影响效率。<br><br>代码如下：<br><br><figure class="highlight hsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> bf_match(char *target,char * pattern) &#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">pos</span> = <span class="number">-1</span><span class="comment">;</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, k = <span class="number">0</span><span class="comment">;</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">pos</span> == <span class="number">-1</span> &amp;&amp; i &lt; <span class="keyword">strlen</span>(target)) &#123;</span><br><span class="line">        <span class="keyword">while</span>(j &lt; <span class="keyword">strlen</span>(pattern) &amp;&amp; target[i] == pattern[j]) &#123;</span><br><span class="line">            i ++<span class="comment">;</span></span><br><span class="line">            j ++<span class="comment">;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="keyword">strlen</span>(pattern)) <span class="comment">//扫描完，匹配成功，则让pos为开始匹配的下标</span></span><br><span class="line">            <span class="keyword">pos</span> = k<span class="comment">;</span></span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">//未扫描完，则模式串从头开始，目标串从下一个字符开始</span></span><br><span class="line">            j = <span class="number">0</span><span class="comment">;</span></span><br><span class="line">            k++<span class="comment">;</span></span><br><span class="line">            i = k<span class="comment">;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">pos</span><span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>## KMP–Knuth-Morris-Pratt算法：消除BF中的回溯<br><br><font size="5">算法思想：</font><br><font color="#DC143C"><br>(1) 计算跳转位置信息，这里我们称之为部分匹配表。<br>(2) 后移到指定位置，重新开始匹配。</font><p>这里 <strong><font color="#DC143C">部分匹配表</font></strong>的含义是在目标字符串中最大前缀和最大后缀所拥有相同字符的最大长度。</p><p>next数组的计算代码如下:</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> cal_next(<span class="keyword">char</span> *<span class="keyword">str</span>, <span class="keyword">int</span> *next, <span class="keyword">int</span> len)</span><br><span class="line">&#123;</span><br><span class="line">    next[<span class="number">0</span>] = <span class="number">-1</span>;<span class="comment">//next[0]初始化为-1，-1表示不存在相同的最大前缀和最大后缀</span></span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">-1</span>;<span class="comment">//k初始化为-1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> q = <span class="number">1</span>; q &lt;= len<span class="number">-1</span>; q++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (k &gt; <span class="number">-1</span> &amp;&amp; <span class="keyword">str</span>[k + <span class="number">1</span>] != <span class="keyword">str</span>[q])<span class="comment">//如果下一个不同，那么k就变成next[k]，注意next[k]是小于k的，无论k取任何值。</span></span><br><span class="line">        &#123;</span><br><span class="line">            k = next[k];<span class="comment">//往前回溯</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">str</span>[k + <span class="number">1</span>] == <span class="keyword">str</span>[q])<span class="comment">//如果相同，k++</span></span><br><span class="line">        &#123;</span><br><span class="line">            k = k + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        next[q] = k;<span class="comment">//这个是把算的k的值（就是相同的最大前缀和最大后缀长）赋给next[q]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>KMP代码如下:</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> KMP(<span class="keyword">char</span> *<span class="keyword">str</span>, <span class="keyword">int</span> slen, <span class="keyword">char</span> *ptr, <span class="keyword">int</span> plen)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> *next = <span class="keyword">new</span> <span class="keyword">int</span>[plen];</span><br><span class="line">    cal_next(ptr, next, plen);<span class="comment">//计算next数组</span></span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; slen; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (k &gt;<span class="number">-1</span>&amp;&amp; ptr[k + <span class="number">1</span>] != <span class="keyword">str</span>[i])<span class="comment">//ptr和str不匹配，且k&gt;-1（表示ptr和str有部分匹配）</span></span><br><span class="line">            k = next[k];<span class="comment">//往前回溯</span></span><br><span class="line">        <span class="keyword">if</span> (ptr[k + <span class="number">1</span>] == <span class="keyword">str</span>[i])</span><br><span class="line">            k = k + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (k == plen<span class="number">-1</span>)<span class="comment">//说明k移动到ptr的最末端</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//cout &lt;&lt; "在位置" &lt;&lt; i-plen+1&lt;&lt; endl;</span></span><br><span class="line">            <span class="comment">//k = -1;//重新初始化，寻找下一个</span></span><br><span class="line">            <span class="comment">//i = i - plen + 1;//i定位到该位置，外层for循环i++可以继续找下一个（这里默认存在两个匹配字符串可以部分重叠），感谢评论中同学指出错误。</span></span><br><span class="line">            <span class="keyword">return</span> i-plen+<span class="number">1</span>;<span class="comment">//返回相应的位置</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></font>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;在说KMP算法之前先说一下普通的模式匹配算法&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;BF蛮力算法–字符串匹配&quot;&gt;&lt;a href=&quot;#BF蛮力算法–字符串匹配&quot; class=&quot;headerlink&quot; title=&quot;BF蛮力算法–字符串匹配&quot;&gt;&lt;/a&gt;BF蛮力算法–字符串匹配&lt;/h2&gt;&lt;font size=&quot;5&quot;&gt;算法思想：&lt;/font&gt;&lt;br&gt;&lt;font color=&quot;#DC143C&quot;&gt;从目标串T的的第一个字符起与模式串P的第一个字符比较&lt;br&gt;若相等，则继续对字符进行后续的比较&lt;br&gt;否则目标串从第二个字符起与模式串的第一个字符重新比较&lt;br&gt;直至模式串中的每个字符依次和目标串中的一个连续的字符序列相等为止，此时称为匹配成功，否则匹配失败&lt;/font&gt;
    
    </summary>
    
      <category term="面试" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>剑指 offer--丑数和两个链表的第一个公共结点</title>
    <link href="http://yoursite.com/2018/03/12/C-%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E5%87%86%E5%A4%87%EF%BC%9A%E5%89%91%E6%8C%87-offer-%E4%B8%91%E6%95%B0%E5%92%8C%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E7%BB%93%E7%82%B9/"/>
    <id>http://yoursite.com/2018/03/12/C-面试问题准备：剑指-offer-丑数和两个链表的第一个公共结点/</id>
    <published>2018-03-12T10:01:41.000Z</published>
    <updated>2018-03-14T13:21:03.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="两个链表的第一个公共结点"><a href="#两个链表的第一个公共结点" class="headerlink" title="两个链表的第一个公共结点"></a>两个链表的第一个公共结点</h2><blockquote><p>问题描述：输入两个链表，找出它们的第一个公共结点。</p></blockquote><p>这道题第一次很容易想到，在第一个链表上遍历每个结点的时候再在第二个链表顺序遍历所有的结点，如果第二个链表上有一个结点和第一个链表上的结点一样，则返回该结点。但是这样的遍历方式会导致时间复杂度为O(mn);<a id="more"></a></p><p>这样显然是不能让面试官满意的，那么分析两个链表具有公共结点的特点，即从该公共结点之后它们所有的结点都是重合的。我们可以考虑从后往前遍历链表，只需要找到最后一个不相同的结点，则该结点就是第一个公共结点。</p><p>代码如下:</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">listNode * findFirstCommonNode(listNode * head1, listNode * head2) &#123;</span><br><span class="line">    <span class="keyword">if</span> (head1 == <span class="keyword">NULL</span> || head2 == <span class="keyword">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">NULL</span>;</span><br><span class="line">    stack &lt;listNode &gt; s1,s2;</span><br><span class="line">    <span class="keyword">while</span>(head1 -&gt; <span class="keyword">next</span> != <span class="keyword">NULL</span>) &#123;</span><br><span class="line">        s1.<span class="keyword">push</span>(head1);</span><br><span class="line">        head1 = head1 -&gt; <span class="keyword">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="keyword">while</span>(head2 -&gt; <span class="keyword">next</span> != <span class="keyword">NULL</span>) &#123;</span><br><span class="line">         s1.<span class="keyword">push</span>(head2);</span><br><span class="line">         head1 = head2 -&gt; <span class="keyword">next</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">while</span>(!s1.empty() &amp;&amp; !s2.empty()) &#123;</span><br><span class="line">          <span class="keyword">int</span> result;</span><br><span class="line">          <span class="keyword">if</span> (s1.top() == s2.top()) &#123;</span><br><span class="line">            s1.<span class="keyword">pop</span>();</span><br><span class="line">            result = s2.top();</span><br><span class="line">            s2.<span class="keyword">pop</span>()</span><br><span class="line">          &#125; </span><br><span class="line">          <span class="keyword">else</span> </span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上一个方法需要两个辅助栈，如果链表的长度分别为m和n，那么空间复杂度是O(m+n)。这种思路的时间复杂度也是O(m+n)。和最开始的蛮力法相比，时间效率得到了提高，相当于是空间换时间。</p><p>接下来有一个更简单的办法：首先遍历两个链表得到它们的长度，就能知道哪个链表比较长，以及长的链表比短的链表多几个结点。在第二次遍历的时候，在较长的链表上先走若干步，接着同时在两个链表上遍历，找到的第一个相同的结点就是它们的第一个公共结点。</p><p>代码如下：<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">listNode * findFirstCommonNode(listNode * head1, listNode * head2) &#123;</span><br><span class="line">    unsigned <span class="keyword">int</span> length1 = getListLength(head1);</span><br><span class="line">    unsigned <span class="keyword">int</span> length2 = getListLength(head2);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> nLengthDif = length1 -length2;</span><br><span class="line">    listNode * listLong = head1;</span><br><span class="line">    listNode * listShort = head2;</span><br><span class="line">    <span class="keyword">if</span> (length2 &gt; length1) &#123;</span><br><span class="line">        listLong = head2;</span><br><span class="line">        listShort = head1;</span><br><span class="line">        nLengthDif = length2 -length1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//先从长链表走几步</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; nLengthDif; ++i) </span><br><span class="line">        listLong = listLong -&gt; <span class="keyword">next</span>;</span><br><span class="line">    <span class="keyword">while</span>(listLong != <span class="keyword">NULL</span> &amp;&amp; listShort != <span class="keyword">NULL</span> &amp;&amp; listLong != listShort) &#123;</span><br><span class="line">        listLong = listLong -&gt; <span class="keyword">next</span>;</span><br><span class="line">        listShort = listShort -&gt; <span class="keyword">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    listNode *first = listLong;</span><br><span class="line">     <span class="keyword">return</span> first;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> getListLength(listNode * head) &#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">NULL</span>) </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">count</span> = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(head -&gt; <span class="keyword">next</span> != <span class="keyword">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">count</span> ++;</span><br><span class="line">        head = head -&gt; <span class="keyword">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">count</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="丑数"><a href="#丑数" class="headerlink" title="丑数"></a>丑数</h2><blockquote><p>题目描述：我们把只包含因子2、3、5的数称作丑数。求按从小到大的顺序第1500个丑数。例如6、8都是丑数，但14不是，因为它包含因子7。习惯上我们把1当作第一个丑数。</p></blockquote><p>显然我们可以得到一个数如果能够连续被2整除、被3整除或者被5整除，最后结果余1，那么它就是丑数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isUgly</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(n % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">        n /= <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span>(n % <span class="number">3</span> == <span class="number">0</span>)</span><br><span class="line">        n /= <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">while</span>(n % <span class="number">5</span> == <span class="number">0</span>)</span><br><span class="line">        n /= <span class="number">5</span>;</span><br><span class="line">     <span class="keyword">if</span> (n == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getUglyNumber</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> uglyFound = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(uglyFound &lt; n) &#123;</span><br><span class="line">        i ++;</span><br><span class="line">        <span class="keyword">if</span> (isUgly(i))</span><br><span class="line">            uglyFound ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上段代码很直观得告诉我们指定题目的第n个丑数的计算过程。但是由于它会对每个非丑数也进行丑数的判断，从而导致算法效率不高。</p><p>此时我们可以采用方法2:<strong><font color="#DC143C">创建数组保存已经找到的丑数，用空间换时间的解法。</font></strong></p><p>即找到如何计算丑数的方法，而非判断丑数。我们可以创建一个数组，里面的数字是排好序的丑数，每一个丑数都是前面的丑数乘以2、3或5得到的。</p><p>这种思路的关键在于怎样确保数组里面的丑数是排好序的。假设数组中已经由若干丑数排好序后存放在数组中，并且已有最大的丑数计作M，我们接下来分析如何生成下一个丑数。该丑数一定是前面某一个丑数乘以2、3或5的结果，所以我们首先考虑把已有的每个丑数乘以2。在乘以2的时候，能得到若干个小于或等于M的结果。</p><p>代码如下：</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> getUglyNumber_Solution2(<span class="built_in">int</span> <span class="built_in">index</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">index</span> &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">int</span> *uglyNumbers = new <span class="built_in">int</span>[<span class="built_in">index</span>];</span><br><span class="line">    uglyNumbers[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">int</span> nextUglyIndex = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">int</span> *multiply2 = uglyNumbers;</span><br><span class="line">    <span class="built_in">int</span> *multiply3 = uglyNumbers;</span><br><span class="line">    <span class="built_in">int</span> *multiply5 = uglyNumbers;</span><br><span class="line">    <span class="keyword">while</span>(nextUglyIndex &lt; <span class="built_in">index</span>) &#123;</span><br><span class="line">        <span class="built_in">int</span> <span class="built_in">min</span> = <span class="built_in">Min</span>(*multiply2 * <span class="number">2</span> ,*multiply3 * <span class="number">3</span> ,*multiply5 * <span class="number">5</span>);</span><br><span class="line">        uglyNumbers[nextUglyIndex] = <span class="built_in">min</span>;</span><br><span class="line">        <span class="keyword">while</span>(*multiply2 * <span class="number">2</span> &lt;= uglyNumbers[nextUglyIndex])</span><br><span class="line">             multiply2 ++;</span><br><span class="line">        <span class="keyword">while</span>(*multiply3 * <span class="number">3</span> &lt;= uglyNumbers[nextUglyIndex])</span><br><span class="line">             multiply3 ++;</span><br><span class="line">        <span class="keyword">while</span>(*multiply5 * <span class="number">5</span> &lt;= uglyNumbers[nextUglyIndex])</span><br><span class="line">             multiply5 ++;</span><br><span class="line">        nextUglyIndex++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">int</span> ugly = uglyNumbers[nextUglyIndex - <span class="number">1</span>];</span><br><span class="line">    delete[] uglyNumbers;</span><br><span class="line">    <span class="keyword">return</span> ugly;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> <span class="built_in">min</span>(<span class="built_in">int</span> number1,<span class="built_in">int</span> number2,<span class="built_in">int</span> number3) &#123;</span><br><span class="line">    <span class="built_in">int</span> <span class="built_in">min</span> = (number1 &lt; number2) ? number1:number2;</span><br><span class="line">    <span class="built_in">min</span> = (<span class="built_in">min</span> &lt; number3) ? <span class="built_in">min</span>:number3;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">min</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;两个链表的第一个公共结点&quot;&gt;&lt;a href=&quot;#两个链表的第一个公共结点&quot; class=&quot;headerlink&quot; title=&quot;两个链表的第一个公共结点&quot;&gt;&lt;/a&gt;两个链表的第一个公共结点&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;问题描述：输入两个链表，找出它们的第一个公共结点。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这道题第一次很容易想到，在第一个链表上遍历每个结点的时候再在第二个链表顺序遍历所有的结点，如果第二个链表上有一个结点和第一个链表上的结点一样，则返回该结点。但是这样的遍历方式会导致时间复杂度为O(mn);
    
    </summary>
    
      <category term="面试" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>2018-03-11</title>
    <link href="http://yoursite.com/2018/03/11/2018-03-11/"/>
    <id>http://yoursite.com/2018/03/11/2018-03-11/</id>
    <published>2018-03-11T15:33:03.000Z</published>
    <updated>2018-03-12T01:36:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天是喜欢糖永永同学的第60天，在这60天里我知道了她的很多故事和经历。看到了她的各种表情，生气、难过、开心、犹豫、纠结、茫然、撒娇。。。我知道了她是一个非常非常感性的姑娘。<a id="more"></a></p><p>有人说，真正的爱是不会计算的。从来没有全心全意爱过一个人，从来没有想过一个人可以让我无时无刻不充满动力，又无时无刻不想念纠结。她在这60天里做到了，是的呢，虽然时间有点短，但是在这段时里我真正得陷入了她的漩涡。<br>我欣赏她对生活的态度，即使自己遍历鳞伤也不忘微笑对待这个世界；我喜欢她那种安静，表面平平淡淡，内心星月沉浮；我喜欢她洒脱的微笑，所有眼泪与痛苦都一笑而过（其实并没有-_-）；我喜欢她吃饭的样子，很慢很慢得吃了很多^_^。我特别喜欢看她，她笑起来很自然，如沐春风。<br>她现在能够接受我，但是她还没有答应我，因为她需要时间去淡化之前那段刻骨铭心的经历。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天是喜欢糖永永同学的第60天，在这60天里我知道了她的很多故事和经历。看到了她的各种表情，生气、难过、开心、犹豫、纠结、茫然、撒娇。。。我知道了她是一个非常非常感性的姑娘。
    
    </summary>
    
      <category term="日记" scheme="http://yoursite.com/categories/life/"/>
    
    
  </entry>
  
  <entry>
    <title>如何实现守护进程</title>
    <link href="http://yoursite.com/2018/03/11/C-%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E5%87%86%E5%A4%87%EF%BC%9A%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B/"/>
    <id>http://yoursite.com/2018/03/11/C-面试问题准备：如何实现守护进程/</id>
    <published>2018-03-11T11:27:06.000Z</published>
    <updated>2018-03-14T13:23:16.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h3><p>守护进程也称精灵进程(Daemon)，是运行在后台的一种特殊进程。它独立于控制终端并且周期性的执行某种任务或等待处理某些发送的事件。Linux上的大多数服务器就是用守护进程实现的。 <a id="more"></a></p><blockquote><p>守护进程可以解决产生死锁的一个必要条件，资源独占问题。即可以实现间接线程资源共享，对于打印机来说我们不允许任何线程直接占有，而是设计一个”精灵程序”（守护进程）来管理。这个进程独占打印机，所有的打印任务都由它发出，任何一个线程想要打印，不是直接请求打印机，而是将打印要求发给这个守护进程指定的地方，这个守护进程将负责完成任务打印。</p></blockquote><p>Linux系统启动时会启动很多系统服务进程，这些系统服务进程没有控制终端，不能直接和用户交互。其他进程启东市都是在用户登录或运行程序是创建，在运行结束或用户注销时终止，但系统服务进程不受用户登录注销影响，他们一直运行着。这种进程就叫做守护进程(精灵进程)（Deamon）。 </p><p>如下图，一般守护进程会在程序运行名后面多一个d,但不是所有尾字母是d的都是守护进程。</p><p><img src="/images/linuxImages/deamon.png" alt=""></p><h3 id="创建守护进程"><a href="#创建守护进程" class="headerlink" title="创建守护进程"></a>创建守护进程</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">pid_t</span> setsid(<span class="keyword">void</span>); <span class="comment">//setid()创建成功后返回新建的会话ID，出错返回-1;</span></span><br></pre></td></tr></table></figure><p>所以我们在调用setsid()函数之前，必须先fork()创建父子进程，父子进程在同一个进程组中，父进程是组长进程，所以子进程符合条件，将父进程退出即可满足要求； </p><p>步骤：</p><p>1、调用umask()将文件模式创建屏蔽字设置为0；<br>2、调用fork，父进程退出。//1、保证守护进程不是进程组长<br>3、调用setsid创建一个会话。//setsid会导致：1、调用进程成为新会话的首进程，2、调用进程成为一个进程组的组长进程，3、调用进程没有控制终端。<br>4、将当前工作目录更改我根目录。//系统中除了跟目录都可以被删除<br>5、关闭不在需要的文件描述符<br>6、忽略SIGCHLD信号；</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;守护进程&quot;&gt;&lt;a href=&quot;#守护进程&quot; class=&quot;headerlink&quot; title=&quot;守护进程&quot;&gt;&lt;/a&gt;守护进程&lt;/h3&gt;&lt;p&gt;守护进程也称精灵进程(Daemon)，是运行在后台的一种特殊进程。它独立于控制终端并且周期性的执行某种任务或等待处理某些发送的事件。Linux上的大多数服务器就是用守护进程实现的。
    
    </summary>
    
      <category term="面试" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="OS" scheme="http://yoursite.com/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>什么函数不能作为虚函数</title>
    <link href="http://yoursite.com/2018/03/11/C-%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E5%87%86%E5%A4%87%EF%BC%9A%E4%BB%80%E4%B9%88%E5%87%BD%E6%95%B0%E4%B8%8D%E8%83%BD%E4%BD%9C%E4%B8%BA%E8%99%9A%E5%87%BD%E6%95%B0/"/>
    <id>http://yoursite.com/2018/03/11/C-面试问题准备：什么函数不能作为虚函数/</id>
    <published>2018-03-11T07:22:28.000Z</published>
    <updated>2018-03-14T13:21:03.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong><font color="#DC143C">虚函数</font></strong></p><p>虚函数必须是类的非静态成员，即在类的成员函数生命中前面关键字为<code>virtual</code>的是虚函数。虚函数是为了实现的面向对象的多态（动态绑定）机制而提出来的。<br>即在程序运行过程中，进行对象所属类型的匹配，也是父类对象访问子类成员的方式。本质上还是为了实现代码复用以及项目的鲁棒性。<a id="more"></a></p><p>不能作为虚函数的函数如下：</p><ul><li>普通函数（非成员函数）</li></ul><blockquote><p>因为普通函数只能被overload，不能被override，也不能被继承，所以在编译的时候就绑定函数，所以不能申明为virtual，没有意义！</p></blockquote><ul><li>构造函数</li></ul><blockquote><p>主要因为构造函数是用来确定初始化对象的,virtual主要是为了在不了解具体的情况下实现动态绑定，调用不同类型中合适的成员函数而存在的，现在对象都没产生，怎么能实现多态呢。<br>构造函数不能被继承，所以不能virtual；</p></blockquote><ul><li>内联函数</li></ul><font color="#DC143C"><br>inline函数在编译时被展开，在调用处将整个函数替换为代码块，省去了函数跳转的时间，提高了SD，减少函数调用的开销，虚函数是为了继承后对象能够准确的调用自己的函数，执行相应的动作。</font><blockquote><p>inline函数是在编译时期展开的，而virtual函数是在运行时期进行动态绑定，所以两者执行时期不一样。、</p></blockquote><ul><li>静态成员函数</li></ul><blockquote><p>静态成员函数是类的组成部分，但是不是任何对象的组成部分，所有对象共享一份，没有必要动态绑定.而且静态成员函数只能访问静态变量，虽然说是可以继承，但是编译器却不会让它真正的继承，它只能作为整个类共有的成员。</p></blockquote><ul><li>友元函数</li></ul><blockquote><p>友员函数不是类的成员函数，C++不支持友员被继承，所以不能为virtual</p></blockquote><h5 id="综上可以作为虚函数的条件是"><a href="#综上可以作为虚函数的条件是" class="headerlink" title="综上可以作为虚函数的条件是"></a><strong>综上可以作为虚函数的条件是</strong></h5><font color="#DC143C"><br><br>1. 类的成员函数<br>2. 能被继承<br>3. 动态编译 </font><blockquote><p>空指针不能调用虚函数，因为虚指针（指向虚函数表）在类实例化时创建，没有创建对象就没有虚指针，那么用空指针调用虚函数就会崩溃。</p></blockquote><p>空指针可以访问普通的成员函数，但是该成员函数中不能调用类的成员变量，因为虽然知道了函数的入口地址，但是成员变量是在实例化的时候分配地址和空间的。所以如果该函数调用成员变量，指针会因为找不到而崩溃。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;&lt;font color=&quot;#DC143C&quot;&gt;虚函数&lt;/font&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;虚函数必须是类的非静态成员，即在类的成员函数生命中前面关键字为&lt;code&gt;virtual&lt;/code&gt;的是虚函数。虚函数是为了实现的面向对象的多态（动态绑定）机制而提出来的。&lt;br&gt;即在程序运行过程中，进行对象所属类型的匹配，也是父类对象访问子类成员的方式。本质上还是为了实现代码复用以及项目的鲁棒性。
    
    </summary>
    
      <category term="面试" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>sizeof(class)的大小</title>
    <link href="http://yoursite.com/2018/03/11/C-%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E5%87%86%E5%A4%87-C-%E7%B1%BB%E7%9A%84%E5%A4%A7%E5%B0%8F-sizeof-class/"/>
    <id>http://yoursite.com/2018/03/11/C-面试问题准备-C-类的大小-sizeof-class/</id>
    <published>2018-03-11T06:18:40.000Z</published>
    <updated>2018-03-14T13:33:27.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="空类的大小"><a href="#空类的大小" class="headerlink" title="空类的大小"></a>空类的大小</h3><p><img src="/images/emptyClass.png" alt=""></p><p>为什么空的什么都没有是1呢？<a id="more"></a></p><blockquote><p>类的实例化就是在内存中分配一块地址，每个实例在内存中都有独一无二的地址。同样空类也会被实例化，所以编译器会给空类隐含的添加一个字节，这样空类实例化之后就有了独一无二的地址了。所以空类的sizeof为1。</p></blockquote><h3 id="一般非空类大小"><a href="#一般非空类大小" class="headerlink" title="一般非空类大小"></a>一般非空类大小</h3><p><img src="/images/generalNo.png" alt=""></p><blockquote><p>编译器为类中的数据成员分配一定的存储空间。实例化时类的地址拥有指向将数据成员的空间。同时因为内存对齐，所以该类的大小就是16(我电脑是64位系统，char * 大小为8字节)</p></blockquote><p>这里简单提一下32位和64位机器中数据类型的长度大小的不同</p><p>32位：</p><ul><li>char 1个字节</li><li>short 2个字节</li><li>int 4个字节</li><li>long 4个字节</li><li>long long 8个字节</li><li>指针  4个字节</li></ul><p>64位：</p><ul><li>char 1个字节</li><li>short 2个字节</li><li>int 4个字节</li><li>long 8个字节</li><li><font color="#DC143C">long long 8个字节</font></li><li><font color="#DC143C">指针 8个字节</font></li></ul><h3 id="有虚函数的类"><a href="#有虚函数的类" class="headerlink" title="有虚函数的类"></a>有虚函数的类</h3><p><img src="/images/virtualNo.png" alt=""></p><blockquote><p>这里类中如果有虚函数，编译器在类实例化的时候会创建一个虚函数表。所以此时该类实例的大小又多了一个指向虚函数表的指针。</p></blockquote><h3 id="有虚函数类的继承"><a href="#有虚函数类的继承" class="headerlink" title="有虚函数类的继承"></a>有虚函数类的继承</h3><p><img src="/images/virtualExtend.png" alt=""></p><blockquote><p>可见子类的大小是本身成员变量的大小加上父类的大小。</p></blockquote><h3 id="拥有静态变量的类"><a href="#拥有静态变量的类" class="headerlink" title="拥有静态变量的类"></a>拥有静态变量的类</h3><p><img src="/images/staticVariable.png" alt=""></p><blockquote><p>看到添加了静态变量的显示结果是和上一个显示的结果一样的。因为static变量对于整个类只有一份拷贝，且静态成员被编译器放在内存空间的全局存储区，但是在类实例化的时候只为类中的成员变量分配存储空间，所以它不会影响类的大小。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;空类的大小&quot;&gt;&lt;a href=&quot;#空类的大小&quot; class=&quot;headerlink&quot; title=&quot;空类的大小&quot;&gt;&lt;/a&gt;空类的大小&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;/images/emptyClass.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;为什么空的什么都没有是1呢？
    
    </summary>
    
      <category term="面试" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>tcp/udp通信过程以及局域网内非阻塞的通信</title>
    <link href="http://yoursite.com/2018/03/11/C-%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E5%87%86%E5%A4%87%EF%BC%9Atcp-udp%E9%80%9A%E4%BF%A1%E8%BF%87%E7%A8%8B%E4%BB%A5%E5%8F%8A%E5%B1%80%E5%9F%9F%E7%BD%91%E5%86%85%E9%9D%9E%E9%98%BB%E5%A1%9E%E7%9A%84%E9%80%9A%E4%BF%A1/"/>
    <id>http://yoursite.com/2018/03/11/C-面试问题准备：tcp-udp通信过程以及局域网内非阻塞的通信/</id>
    <published>2018-03-11T04:52:45.000Z</published>
    <updated>2018-03-14T13:21:03.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="TCP和UDP协议的特点"><a href="#TCP和UDP协议的特点" class="headerlink" title="TCP和UDP协议的特点"></a>TCP和UDP协议的特点</h2><p><strong><font color="#DC143C">TCP</font></strong></p><ul><li>支持面向链接的传输服务（相当于人们打电话，需要先建立一个用来传输双方信息的链接）</li><li>支持字节流的传输（流模式 stream socket）</li><li>支持全双工通信（允许通信双方的应用程序在任何时候都可以发送数据）</li><li>支持建立多个并发的TCP链接</li><li>支持可靠的传输服务（提供确认／重传与拥塞控制功能）<a id="more"></a></li></ul><p><strong><font color="#DC143C">UDP</font></strong></p><ul><li>无连接、不可靠的传输层协议<ol><li>UDP协议在传输报文之前不需要在通信双方之间建立连接，因此减少了协议开销与传输延迟</li><li>UDP对报文除了提供一种可选的校验和之外，几乎没有提供其他的保证数据传输可靠性的措施</li><li>如果UDP协议检测处收到的分组出错，它就丢弃这个分组，既不确认，也不通知发送端和要求重传</li></ol></li><li>面向报文（数据报模式 datagram socket）<ol><li>UDP协议对于提交的报文，在添加了UDP头部，构成一个TPDU之后就向下提交给IP层</li><li>UDP协议对应用程序提交的报文既不合并，也不拆分，而是保留原报文的长度与格式。</li><li>对于UDP提交的报文长度应该设置合理，太短会使协议开销太大；太长，则UDP向IP层提交的TPDU可能在IP层会被分片，这样也会降低协议效率。</li></ol></li></ul><h2 id="TCP和UDP通信实现"><a href="#TCP和UDP通信实现" class="headerlink" title="TCP和UDP通信实现"></a>TCP和UDP通信实现</h2><p><strong><font color="#DC143C">TCP</font></strong></p><p><img src="/images/tcp.png" alt=""></p><blockquote><p>三次握手:<br>1.客户端发送一个syn段（同步序号）指明客户打算连接的服务器端口，以及初始化序号(ISN)，同时客户端进入”SYN-SEND”（状态）<br>2.服务器发回包含服务器的初始序号的SYN报文段作为应答。同时，将确认序号(ACK)设置为客户的ISN加1以对客户的SYN 报文段进行确认，同时服务端进入”SYN-RCVD”状态<br>3.客户必须将确认序号设置为服务器的ISN加1以对服务器的SYN报文段进行确认。此时客户端进入”ESTABLISHED”，而且服务端在接收到”ACK”报文之后也进入”ESTABLISHED”</p></blockquote><p><img src="/images/tcpThree.png" alt=""></p><p>TCP编程的服务器端一般步骤是： </p><ul><li>创建一个socket，用函数socket()； </li><li>设置socket属性，用函数setsockopt(); 可选</li><li>绑定IP地址、端口等信息到socket上，用函数bind(); </li><li>开启监听，用函数listen()； </li><li>接收客户端上来的连接，用函数accept()； </li><li>收发数据，用函数send()和recv()，或者read()和write(); </li><li>关闭网络连接； </li><li>关闭监听；</li></ul><p>TCP编程的客户端一般步骤是： </p><ul><li>创建一个socket，用函数socket()； </li><li>设置socket属性，用函数setsockopt();* 可选 </li><li>绑定IP地址、端口等信息到socket上，用函数bind();* 可选 </li><li>设置要连接的对方的IP地址和端口等属性； </li><li>连接服务器，用函数connect()； </li><li>收发数据，用函数send()和recv()，或者read()和write(); </li><li>关闭网络连接；</li></ul><p><strong><font color="#DC143C">UDP</font></strong></p><p><img src="/images/udp.png" alt=""></p><p>UDP编程的服务器端一般步骤是： </p><ul><li>创建一个socket，用函数socket()； </li><li>设置socket属性，用函数setsockopt();* 可选 </li><li>绑定IP地址、端口等信息到socket上，用函数bind(); </li><li>循环接收数据，用函数recvfrom(); </li><li>关闭网络连接；</li></ul><p>UDP编程的客户端一般步骤是： </p><ul><li>创建一个socket，用函数socket()； </li><li>设置socket属性，用函数setsockopt();* 可选 </li><li>绑定IP地址、端口等信息到socket上，用函数bind();* 可选 </li><li>设置对方的IP地址和端口等属性; </li><li>发送数据，用函数sendto(); </li><li>关闭网络连接</li></ul><p><strong><font color="#DC143C">TCP 连接实现代码</font></strong></p><p>server</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;//包含socket函数使用的各种协议族，send(),recv()  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;//调用linux系统函数的头文件(read(),write(),send()，select())  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PORT 7000  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IP <span class="meta-string">"127.0.0.1"</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">int</span> s;  </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servaddr</span>;</span>  </span><br><span class="line"><span class="keyword">socklen_t</span> len;  </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; li;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getConn</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;  </span><br><span class="line">        <span class="keyword">int</span> conn = accept(s, (struct sockaddr*)&amp;servaddr, &amp;len);<span class="comment">//第二个参数保存客户端套接字对应的IP地址和port 端口信息  </span></span><br><span class="line">        li.push_back(conn);  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, conn);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getData</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>;</span>  </span><br><span class="line">    tv.tv_sec = <span class="number">2</span>;  </span><br><span class="line">    tv.tv_usec = <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;  </span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator it;  </span><br><span class="line">        <span class="keyword">for</span>(it=li.begin(); it!=li.end(); ++it)&#123;  </span><br><span class="line">            fd_set rfds;  </span><br><span class="line">            FD_ZERO(&amp;rfds);  </span><br><span class="line">            <span class="keyword">int</span> maxfd = <span class="number">0</span>;  </span><br><span class="line">            <span class="keyword">int</span> retval = <span class="number">0</span>;  </span><br><span class="line">            FD_SET(*it, &amp;rfds);  </span><br><span class="line">            <span class="keyword">if</span>(maxfd &lt; *it)&#123;  </span><br><span class="line">                maxfd = *it;  </span><br><span class="line">            &#125;  </span><br><span class="line">            retval = select(maxfd+<span class="number">1</span>, &amp;rfds, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;tv);<span class="comment">//实现非阻塞式的通信，即需要等待时间的发生，一旦执行一定返回，返回的结果不同以表示函数执行的结果  </span></span><br><span class="line">            <span class="keyword">if</span>(retval == <span class="number">-1</span>)&#123;  </span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"select error\n"</span>);  </span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(retval == <span class="number">0</span>) &#123;  </span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;  </span><br><span class="line">                <span class="keyword">char</span> buf[<span class="number">1024</span>];  </span><br><span class="line">                <span class="built_in">memset</span>(buf, <span class="number">0</span> ,<span class="keyword">sizeof</span>(buf));  </span><br><span class="line">                <span class="keyword">long</span> len = recv(*it, buf, <span class="keyword">sizeof</span>(buf), <span class="number">0</span>);  </span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%s"</span>, buf);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        sleep(<span class="number">1</span>);  </span><br><span class="line">          </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sendMess</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;  </span><br><span class="line">        <span class="keyword">char</span> buf[<span class="number">1024</span>];  </span><br><span class="line">        fgets(buf, <span class="keyword">sizeof</span>(buf), <span class="built_in">stdin</span>);<span class="comment">//从文件流读取一行，送到缓冲区，使用时注意以下几点  </span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator it;  </span><br><span class="line">        <span class="keyword">for</span>(it=li.begin(); it!=li.end(); ++it)&#123;  </span><br><span class="line">            send(*it, buf, <span class="keyword">sizeof</span>(buf), <span class="number">0</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    s = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);  </span><br><span class="line">    <span class="built_in">memset</span>(&amp;servaddr, <span class="number">0</span>, <span class="keyword">sizeof</span>(servaddr));  </span><br><span class="line">    servaddr.sin_family = AF_INET;  </span><br><span class="line">    servaddr.sin_port = htons(PORT);  </span><br><span class="line">    servaddr.sin_addr.s_addr = inet_addr(IP);  </span><br><span class="line">    <span class="keyword">if</span>(bind(s, (struct sockaddr* ) &amp;servaddr, <span class="keyword">sizeof</span>(servaddr))==<span class="number">-1</span>) &#123;  </span><br><span class="line">        perror(<span class="string">"bind"</span>);  </span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">if</span>(listen(s, <span class="number">20</span>) == <span class="number">-1</span>) &#123;  </span><br><span class="line">        perror(<span class="string">"listen"</span>);  </span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    len = <span class="keyword">sizeof</span>(servaddr);  </span><br><span class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">t</span><span class="params">(getConn)</span></span>;  </span><br><span class="line">    t.detach();  </span><br><span class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">t1</span><span class="params">(sendMess)</span></span>;  </span><br><span class="line">    t1.detach();  </span><br><span class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">t2</span><span class="params">(getData)</span></span>;  </span><br><span class="line">    t2.detach();  </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;  </span><br><span class="line">          </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>client</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MYPORT  7000  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFFER_SIZE 1024  </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> sock_cli;  </span><br><span class="line">    fd_set rfds;  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>;</span><span class="comment">//设置时间  </span></span><br><span class="line">    <span class="keyword">int</span> retval, maxfd;  </span><br><span class="line">      </span><br><span class="line">    <span class="comment">///定义sockfd  </span></span><br><span class="line">    sock_cli = socket(AF_INET,SOCK_STREAM, <span class="number">0</span>);  </span><br><span class="line">    <span class="comment">///定义sockaddr_in  </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servaddr</span>;</span>  </span><br><span class="line">    <span class="built_in">memset</span>(&amp;servaddr, <span class="number">0</span>, <span class="keyword">sizeof</span>(servaddr));  </span><br><span class="line">    servaddr.sin_family = AF_INET;  </span><br><span class="line">    <span class="keyword">char</span> s[<span class="number">1024</span>];  </span><br><span class="line">    <span class="keyword">int</span> a;  </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"输入想要建立连接的端口号以及IP地址:"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;  </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a);  </span><br><span class="line">    getchar();  </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>,s);  </span><br><span class="line">    servaddr.sin_port = htons(a);  <span class="comment">///服务器端口，利用htons将主机字节顺序转换为网路字节数序从而进行数据包的传送  </span></span><br><span class="line">    servaddr.sin_addr.s_addr = inet_addr(s);  <span class="comment">///服务器ip  </span></span><br><span class="line">      </span><br><span class="line">    <span class="comment">//连接服务器，成功返回0，错误返回-1  </span></span><br><span class="line">    <span class="keyword">if</span> (connect(sock_cli, (struct sockaddr *)&amp;servaddr, <span class="keyword">sizeof</span>(servaddr)) &lt; <span class="number">0</span>)  </span><br><span class="line">    &#123;  </span><br><span class="line">        perror(<span class="string">"connect"</span>);  </span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;  </span><br><span class="line">        <span class="comment">/*把可读文件描述符的集合清空*/</span>  </span><br><span class="line">        FD_ZERO(&amp;rfds);  </span><br><span class="line">        <span class="comment">/*把标准输入的文件描述符加入到集合中*/</span>  </span><br><span class="line">        FD_SET(<span class="number">0</span>, &amp;rfds);  </span><br><span class="line">        maxfd = <span class="number">0</span>;  </span><br><span class="line">        <span class="comment">/*把当前连接的文件描述符加入到集合中*/</span>  </span><br><span class="line">        FD_SET(sock_cli, &amp;rfds);  </span><br><span class="line">        <span class="comment">/*找出文件描述符集合中最大的文件描述符*/</span>  </span><br><span class="line">        <span class="keyword">if</span>(maxfd &lt; sock_cli)  </span><br><span class="line">            maxfd = sock_cli;  </span><br><span class="line">        <span class="comment">/*设置超时时间*/</span>  </span><br><span class="line">        tv.tv_sec = <span class="number">5</span>;  </span><br><span class="line">        tv.tv_usec = <span class="number">0</span>;  </span><br><span class="line">        <span class="comment">/*等待聊天*/</span>  </span><br><span class="line">        retval = select(maxfd+<span class="number">1</span>, &amp;rfds, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;tv);<span class="comment">//int select(int maxfdp,fd_set *readfds,fd_set *writefds,fd_set *errorfds,struct timeval*timeout);  监视我们需要的文件的文件描述符的变化情况——读写或是异常  </span></span><br><span class="line">        <span class="keyword">if</span>(retval == <span class="number">-1</span>)&#123;  </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"select出错，客户端程序退出\n"</span>);  </span><br><span class="line">            <span class="keyword">break</span>;  </span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(retval == <span class="number">0</span>)&#123;<span class="comment">//超时  </span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"客户端没有任何输入信息，并且服务器也没有信息到来，waiting...\n"</span>);  </span><br><span class="line">            <span class="keyword">continue</span>;  </span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">//文件可进行读写或者出错  </span></span><br><span class="line">            <span class="comment">/*服务器发来了消息*/</span>  </span><br><span class="line">            <span class="keyword">if</span>(FD_ISSET(sock_cli,&amp;rfds))&#123;  </span><br><span class="line">                <span class="keyword">char</span> recvbuf[BUFFER_SIZE];  </span><br><span class="line">                <span class="keyword">long</span> len;  </span><br><span class="line">                len = recv(sock_cli, recvbuf, <span class="keyword">sizeof</span>(recvbuf),<span class="number">0</span>);  </span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%s"</span>, recvbuf);  </span><br><span class="line">                <span class="built_in">memset</span>(recvbuf, <span class="number">0</span>, <span class="keyword">sizeof</span>(recvbuf));  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="comment">/*用户输入信息了,开始处理信息并发送*/</span>  </span><br><span class="line">            <span class="keyword">if</span>(FD_ISSET(<span class="number">0</span>, &amp;rfds))&#123;  </span><br><span class="line">                <span class="keyword">char</span> sendbuf[<span class="number">1024</span>];  </span><br><span class="line"><span class="comment">//                scanf("%s",sendbuf);  </span></span><br><span class="line">                fgets(sendbuf, <span class="keyword">sizeof</span>(sendbuf), <span class="built_in">stdin</span>);  </span><br><span class="line">                send(sock_cli, sendbuf, <span class="built_in">strlen</span>(sendbuf),<span class="number">0</span>); <span class="comment">//发送  </span></span><br><span class="line">                <span class="built_in">memset</span>(sendbuf, <span class="number">0</span>, <span class="keyword">sizeof</span>(sendbuf));  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    close(sock_cli);  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在终端下分别编译运行结果显示如下：</p><p><img src="/images/result.png" alt=""></p><blockquote><p>安利一个函数，<code>int select(int maxfdp,fd_set *readfds,fd_set *writefds,fd_set *errorfds,struct timeval *timeout);</code>.也是以上程序用到的函数。<br>因为在TCP通信中所用到的accept(),connect(),recv(),send()函数都是阻塞式通信（虽然阻塞的概念是针对S端,但是我们在建立连接后都可以作为发送端和接受端，所以这个概念是可以用在这里的），即我必须在这里等待我的调用结果，也就是如果S端没有发送信息，我的进程就会一直等待，直到recv()可以接受到结果才开始继续运行。<br>但是select()函数确可以让我们进行不用等待的通信，即程或线程执行此函数时不必非要等待接受消息。一旦该函数执行肯定返回，以返回值的不同来反映函数的执行情况，如果有接受到消息则与阻塞方式相同，若没有接收到消息则返回一个代码来告知事件未发生，而进程或线程继续执行。它的最后一个参数可以用来作为超时检测，即很长时间没有信息互动，那么接受端会弹出一条信息来告知目前你没有发送信息，是否发送端出现传输问题。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;TCP和UDP协议的特点&quot;&gt;&lt;a href=&quot;#TCP和UDP协议的特点&quot; class=&quot;headerlink&quot; title=&quot;TCP和UDP协议的特点&quot;&gt;&lt;/a&gt;TCP和UDP协议的特点&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;&lt;font color=&quot;#DC143C&quot;&gt;TCP&lt;/font&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;支持面向链接的传输服务（相当于人们打电话，需要先建立一个用来传输双方信息的链接）&lt;/li&gt;
&lt;li&gt;支持字节流的传输（流模式 stream socket）&lt;/li&gt;
&lt;li&gt;支持全双工通信（允许通信双方的应用程序在任何时候都可以发送数据）&lt;/li&gt;
&lt;li&gt;支持建立多个并发的TCP链接&lt;/li&gt;
&lt;li&gt;支持可靠的传输服务（提供确认／重传与拥塞控制功能）
    
    </summary>
    
      <category term="面试" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="网络通信" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/"/>
    
  </entry>
  
  <entry>
    <title>阻塞和非阻塞、同步和异步</title>
    <link href="http://yoursite.com/2018/03/10/C-%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E5%87%86%E5%A4%87%EF%BC%9A%E9%98%BB%E5%A1%9E%E5%92%8C%E9%9D%9E%E9%98%BB%E5%A1%9E%E3%80%81%E5%90%8C%E6%AD%A5%E5%92%8C%E5%BC%82%E6%AD%A5/"/>
    <id>http://yoursite.com/2018/03/10/C-面试问题准备：阻塞和非阻塞、同步和异步/</id>
    <published>2018-03-10T14:11:46.000Z</published>
    <updated>2018-03-14T13:23:16.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="同步和异步主要针对C端"><a href="#同步和异步主要针对C端" class="headerlink" title="同步和异步主要针对C端"></a>同步和异步主要针对C端</h2><h3 id="同步"><a href="#同步" class="headerlink" title="同步"></a><strong><font color="#DC143C">同步</font></strong></h3><p>所谓同步，就是在c端发出一个功能调用时，在没有得到结果之前，该调用就不返回。也就是必须一件一件事做,等前一件做完了才能做下一件事。 <a id="more"></a></p><blockquote><p>例如普通B/S模式（同步）：提交请求-&gt;等待服务器处理-&gt;处理完毕返回 这个期间客户端浏览器不能干任何事</p></blockquote><h3 id="异步"><a href="#异步" class="headerlink" title="异步"></a><strong><font color="#DC143C">异步</font></strong></h3><p>当c端一个异步过程调用发出后，调用者不能立刻得到结果。实际处理这个调用的部件在完成后，通过状态、通知和回调来通知调用者。</p><blockquote><p>例如 ajax请求（异步）: 请求通过事件触发-&gt;服务器处理（这时浏览器仍然可以作其他事情）-&gt;处理完毕</p></blockquote><h2 id="阻塞和非阻塞针对S端"><a href="#阻塞和非阻塞针对S端" class="headerlink" title="阻塞和非阻塞针对S端"></a>阻塞和非阻塞针对S端</h2><h3 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a><strong><font color="#DC143C">阻塞</font></strong></h3><p>阻塞调用是指调用结果返回之前，当前线程会被挂起（线程进入非可执行状态，在这个状态下，cpu不会给线程分配时间片，即线程暂停运行）。函数只有在得到结果之后才会返回</p><blockquote><p>比如到你某个时候到A楼一层（假如是内核缓冲区）取快递，但是你不知道快递什么时候过来，你又不能干别的事，只能死等着。但你可以睡觉（进程处于休眠状态），因为你知道快递把货送来时一定会给你打个电话（假定一定能叫醒你）。</p></blockquote><h3 id="非阻塞"><a href="#非阻塞" class="headerlink" title="非阻塞"></a><strong><font color="#DC143C">非阻塞</font></strong></h3><p>在不能立刻得到结果之前，该函数不会阻塞当前线程，而会立刻返回</p><blockquote><p>还是等快递的例子：如果用忙轮询的方法，每隔5分钟到A楼一层(内核缓冲区）去看快递来了没有。如果没来，立即返回。而快递来了，就放在A楼一层，等你去取</p></blockquote><p>综上：</p><p>同步  就是我客户端（c端调用者）调用一个功能，该功能没有结束前，我（c端调用者）死等结果<br>异步  就是我（c端调用者）调用一个功能，不需要知道该功能结果，该功能有结果后通知我（c端调用者）即回调通知。<br>阻塞  就是调用我（s端被调用者，函数），我（s端被调用者，函数）没有接收完数据或者没有得到结果之前，我不会返回。<br>非阻塞 就是调用我（s端被调用者，函数），我（s端被调用者，函数）立即返回，通过select通知调用者</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;同步和异步主要针对C端&quot;&gt;&lt;a href=&quot;#同步和异步主要针对C端&quot; class=&quot;headerlink&quot; title=&quot;同步和异步主要针对C端&quot;&gt;&lt;/a&gt;同步和异步主要针对C端&lt;/h2&gt;&lt;h3 id=&quot;同步&quot;&gt;&lt;a href=&quot;#同步&quot; class=&quot;headerlink&quot; title=&quot;同步&quot;&gt;&lt;/a&gt;&lt;strong&gt;&lt;font color=&quot;#DC143C&quot;&gt;同步&lt;/font&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;所谓同步，就是在c端发出一个功能调用时，在没有得到结果之前，该调用就不返回。也就是必须一件一件事做,等前一件做完了才能做下一件事。
    
    </summary>
    
      <category term="面试" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="OS" scheme="http://yoursite.com/tags/OS/"/>
    
  </entry>
  
</feed>
