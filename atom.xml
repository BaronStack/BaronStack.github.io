<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>那一刻 风情万种</title>
  
  <subtitle>我喜欢看你笑的样子</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-03-09T15:58:27.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>那一刻 风情万种</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2018-03-09</title>
    <link href="http://yoursite.com/2018/03/09/2018-03-09/"/>
    <id>http://yoursite.com/2018/03/09/2018-03-09/</id>
    <published>2018-03-09T15:46:27.000Z</published>
    <updated>2018-03-09T15:58:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近和她呆在一起的时间比较长，不过大多是在上自习。因为她要准备专八，我要准备找工作。但是今天她接受到了一个她前男友的快递，他送给她一条毛毯，说是看到西安有点冷。<a id="more"></a><br>是的，虽然她并没有答应我，但是我能感觉到她已经能够接受我了。只是看到这个快递，还是很难受，看到她的纠结犹豫了，我忍受着内心无奈与难受，告诉她你把毛毯放宿舍吧，然后想的话再给他打个电话。之后我就去自习室了，路上一时间我发现我不知道再能为她做什么了，真的不知道能够做什么才能让她将心交给我，想着她晚上盖着他送的毛毯，回忆着曾经那段幸福的时光。<br>算了我写不下去了，可能我还是太急了，毕竟她还需要时间！当下之急是解决工作问题，这样才会有更多时间可以陪伴了解，我也相信我能够让她真正喜欢上我！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近和她呆在一起的时间比较长，不过大多是在上自习。因为她要准备专八，我要准备找工作。但是今天她接受到了一个她前男友的快递，他送给她一条毛毯，说是看到西安有点冷。
    
    </summary>
    
      <category term="日记" scheme="http://yoursite.com/categories/life/"/>
    
    
  </entry>
  
  <entry>
    <title>C++面试问题准备：剑指 offer--从上往下打印和二叉搜索树的后序遍历序列</title>
    <link href="http://yoursite.com/2018/03/08/C-%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E5%87%86%E5%A4%87%EF%BC%9A%E5%89%91%E6%8C%87-offer-%E4%BB%8E%E4%B8%8A%E5%BE%80%E4%B8%8B%E6%89%93%E5%8D%B0%E5%92%8C%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97/"/>
    <id>http://yoursite.com/2018/03/08/C-面试问题准备：剑指-offer-从上往下打印和二叉搜索树的后序遍历序列/</id>
    <published>2018-03-08T12:20:51.000Z</published>
    <updated>2018-03-09T16:48:36.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="从上往下打印二叉树"><a href="#从上往下打印二叉树" class="headerlink" title="从上往下打印二叉树"></a>从上往下打印二叉树</h2><blockquote><p>题目描述：从上往下打印出二叉树的每个结点，同一层的结点按照从左到右的顺序打印。</p></blockquote><p>因为按层打印的顺序决定应该先打印根节点，所以我们从树的根节点开始分析。 <a id="more"></a></p><p><img src="/images/printTre.jpg" alt=""></p><p>为了接下来能够打印值为8的结点的两个子结点，我们应该在遍历到该结点时把值为6和10的两个结点保存到一个容器，现在容器内就有两个结点了。按照从左到右打印的要求，我们先取出值分别为5和7的两个结点放入数据容器。此时数据容器中有三个结点，值分别为10，5，7。接下来我们从数据容器中取出值为10的结点。注意到值为10的结点比值为5、7的结点先放入容器，此时又比这两个结点先取出，这就是我们经常说的 <strong><font color="#DC143C">先入先出</font></strong></p><p>综上我们可以得到思想：</p><p><strong><font color="#DC143C">每一次打印一个结点的时候，如果该结点有子结点，则把该结点的子结点放到一个队列的末尾。接下来到队列的头部取出最早进入队列的结点，重复前面的打印操作，直至队列中所有的子结点都被打印出来为止</font></strong></p><p>代码如下：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">void printTree(Tree *root) &#123;</span><br><span class="line">    if (root == NULL)</span><br><span class="line">        return ;</span><br><span class="line">    std::deque <span class="tag">&lt;Tree *&gt;</span> dequeTree;</span><br><span class="line">    dequeTree.push_back(root);</span><br><span class="line">    while(dequeTree.size()) &#123;</span><br><span class="line">        Tree *<span class="keyword">node</span> <span class="title">= dequeTree</span>.front();</span><br><span class="line">        dequeTree.pop_front();</span><br><span class="line">        cout <span class="tag">&lt;&lt; node -&gt;</span> value <span class="tag">&lt;&lt; endl;</span></span><br><span class="line"><span class="tag">        if (node -&gt;</span> left)</span><br><span class="line">            dequeTree.push_back(<span class="keyword">node</span> <span class="title">-&gt; left</span>);</span><br><span class="line">        if (<span class="keyword">node</span> <span class="title">-&gt; right</span>)</span><br><span class="line">            dequeTree.push_back(<span class="keyword">node</span> <span class="title">-&gt; right</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二叉搜索树的后序遍历序列"><a href="#二叉搜索树的后序遍历序列" class="headerlink" title="二叉搜索树的后序遍历序列"></a>二叉搜索树的后序遍历序列</h2><blockquote><p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则返回true,否则返回false。假设输入的数组的任意两个数字都互不相同。</p></blockquote><p><img src="/images/printTree.jpg" alt=""></p><p>在后续遍历序列中，最后一个数字是树的根节点的值。数组中前面的数字可以分为两部分：第一部分是左子树结点的值，他们都比根节点的值小；第二部分是右子树结点的值，它们都比根节点的值大。根据以上给出的数组，后序遍历结果的最后一个数字8就是根节点的值。在这个数组中，前3个数字5、7和6都比8小，是值为8的结点的左子树结点；后3个数字9、11和10都比8大，是值为8的结点的右子树结点。接下来我们可以用同样的方法，确定数组每一部分对应的子树的结构。</p><p>代码如下：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> verifySquenceOfBST(<span class="type">int</span> sequence[],<span class="type">int</span> <span class="built_in">length</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (sequence == NULL || <span class="built_in">length</span> &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">int</span> root = sequence[<span class="built_in">length</span> - <span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt; <span class="built_in">length</span> - <span class="number">1</span>; ++i)</span><br><span class="line">        <span class="keyword">if</span> (sequence[i] &gt; root)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    <span class="type">int</span> j = i;</span><br><span class="line">    <span class="keyword">for</span> (; j &lt; <span class="built_in">length</span> - i - <span class="number">1</span>; ++ j)</span><br><span class="line">        <span class="keyword">if</span> (sequence[j] &lt; root)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">bool</span> left = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (i &gt; <span class="number">0</span>)</span><br><span class="line">        left = verifySquenceOfBST(sequence,i);</span><br><span class="line">    <span class="type">bool</span> right = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="built_in">length</span> - <span class="number">1</span>)</span><br><span class="line">        right = verifySquenceOfBST(sequence,<span class="built_in">length</span> - i - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> left &amp;&amp; right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;从上往下打印二叉树&quot;&gt;&lt;a href=&quot;#从上往下打印二叉树&quot; class=&quot;headerlink&quot; title=&quot;从上往下打印二叉树&quot;&gt;&lt;/a&gt;从上往下打印二叉树&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;题目描述：从上往下打印出二叉树的每个结点，同一层的结点按照从左到右的顺序打印。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;因为按层打印的顺序决定应该先打印根节点，所以我们从树的根节点开始分析。
    
    </summary>
    
      <category term="面试" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++面试问题准备：剑指-offer--合并两个排序链表和树的子结构</title>
    <link href="http://yoursite.com/2018/03/07/C-%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E5%87%86%E5%A4%87%EF%BC%9A%E5%89%91%E6%8C%87-offer-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E5%92%8C%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84/"/>
    <id>http://yoursite.com/2018/03/07/C-面试问题准备：剑指-offer-合并两个排序链表和树的子结构/</id>
    <published>2018-03-07T11:59:45.000Z</published>
    <updated>2018-03-08T11:22:48.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="合并两个排序链表"><a href="#合并两个排序链表" class="headerlink" title="合并两个排序链表"></a>合并两个排序链表</h2><blockquote><p>输入两个递增排序的链表，合并这两个链表并使新链表中的结点仍然使按照递增排序的。</p></blockquote><p>常见问题：</p><ul><li>写代码之前没有对合并过程想清楚，最终合并出来的链表要么中间断开，要么没有做到递增排序</li><li>代码的鲁棒性存在问题，程序有特殊输入会崩溃（输入空链表）<a id="more"></a><img src="/images/mergeList.png" alt=""></li></ul><p>两个链表的合并过程中：</p><ol><li>链表1的头结点的值小于链表2的头结点的值，因此链表1的头结点使合并后链表的头结点</li><li>在剩余的结点中，链表2的头结点的值小于链表1的头结点的值，因此链表2的头结点是剩余结点的头结点，把这个结点和之前已经合并好的结点连接起来。</li></ol><p>之后的步骤和以上两个步骤的比较是相同的，则可以用递归解决，代码如下：</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">listNode *mergeList(listNode *head1,listNode *head2) &#123;</span><br><span class="line">    <span class="keyword">if</span> (head1 == NULL)</span><br><span class="line">        return head2;</span><br><span class="line">    <span class="keyword">if</span> (head2 == NULL)</span><br><span class="line">        return head1;</span><br><span class="line">    listNode *mergeResult = NULL;</span><br><span class="line">    <span class="function"><span class="title">if</span> (head1 -&gt;</span> <span class="function"><span class="title">value</span> &lt; head2 -&gt;</span> value) &#123;</span><br><span class="line">        mergeResult = head1;</span><br><span class="line">        <span class="function"><span class="title">mergeResult</span> -&gt;</span> <span class="function"><span class="title">next</span> = mergeList(head1 -&gt;</span> next,head2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        mergeResult = head2;</span><br><span class="line">        <span class="function"><span class="title">mergeResult</span> -&gt;</span> <span class="function"><span class="title">next</span> = mergeList(head1,head2 -&gt;</span> next);</span><br><span class="line">    &#125;</span><br><span class="line">    return mergeResult;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="树的子结构"><a href="#树的子结构" class="headerlink" title="树的子结构"></a>树的子结构</h2><blockquote><p>输入两棵二叉树A和B，判断B是不是A的子结构。</p></blockquote><p><img src="/images/subTree.png" alt=""></p><p>如上图，第一棵树命名为A，第二棵树命名为B。</p><p>要查找第一棵树中是否存在和第二棵树一样的字结构,我们可以分成两步：第一步在A中找到和B的根结点的值一样的结点R，第二步再判断A中以R为根节点的子树是否包含和B一样的子树的结构。</p><p>代码如下，注意代码的鲁棒性，即在函数入口处检查参数的正确性。</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一步，找到和B树根节点数值相同的子树根结点</span></span><br><span class="line">bool judegeSubTree(Tree *root1, Tree *root2) &#123;</span><br><span class="line">    bool isSubTree = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (root1 != NULL &amp;&amp; root2 != NULL) &#123;</span><br><span class="line">        <span class="function"><span class="title">if</span> (root1 -&gt;</span> <span class="function"><span class="title">value</span> == root2 -&gt;</span> value) &#123;</span><br><span class="line">            isSubTree = judgeDefinateSubTree(root1,root2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="function"><span class="title">isSubTree</span> = judgeSubTree(root1 -&gt;</span> <span class="function"><span class="title">left</span>,root2) || judgeSubTree(root1 -&gt;</span> right,root2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return isSubTree;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第二步，进行两个树各自子结点的比较</span></span><br><span class="line">bool judgeDefinateSubTree(Tree *root1, Tree *root2) &#123;</span><br><span class="line">    bool result = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (root2 == NULL)</span><br><span class="line">        result = <span class="literal">true</span>;</span><br><span class="line">    <span class="function"><span class="title">if</span> (root1 -&gt;</span> <span class="function"><span class="title">value</span> == root2 -&gt;</span> value)</span><br><span class="line">        result = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="function"><span class="title">result</span> = judgeDefinateSubTree(root1 -&gt;</span> <span class="function"><span class="title">left</span>,root2 -&gt;</span> <span class="function"><span class="title">left</span>) &amp;&amp; judgeDefinateSubTree(root1 -&gt;</span> <span class="function"><span class="title">right</span>, root2 -&gt;</span> right);</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;合并两个排序链表&quot;&gt;&lt;a href=&quot;#合并两个排序链表&quot; class=&quot;headerlink&quot; title=&quot;合并两个排序链表&quot;&gt;&lt;/a&gt;合并两个排序链表&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;输入两个递增排序的链表，合并这两个链表并使新链表中的结点仍然使按照递增排序的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;常见问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;写代码之前没有对合并过程想清楚，最终合并出来的链表要么中间断开，要么没有做到递增排序&lt;/li&gt;
&lt;li&gt;代码的鲁棒性存在问题，程序有特殊输入会崩溃（输入空链表）
    
    </summary>
    
      <category term="面试" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++面试问题准备：剑指 offer--链表中倒数第k个结点和合并反转链表</title>
    <link href="http://yoursite.com/2018/03/07/C-%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E5%87%86%E5%A4%87%EF%BC%9A%E5%89%91%E6%8C%87%20offer-%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E7%BB%93%E7%82%B9%E5%92%8C%E5%90%88%E5%B9%B6%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/"/>
    <id>http://yoursite.com/2018/03/07/C-面试问题准备：剑指 offer-链表中倒数第k个结点和合并反转链表/</id>
    <published>2018-03-07T11:07:47.000Z</published>
    <updated>2018-03-07T13:43:33.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="链表中倒数第K个结点"><a href="#链表中倒数第K个结点" class="headerlink" title="链表中倒数第K个结点"></a>链表中倒数第K个结点</h2><blockquote><p>问题描述：输入一个链表，输出该链表中倒数第K个结点。例如一个链表有6个结点，从头结点开始它们的值依次是1，2，3，4，5，6。这个链表的倒数第三个结点值为4。<br><a id="more"></a></p></blockquote><p>为了得到我们想要的结果，我们会很自然的想到假设这个链表有n个结点，那么倒数第k个结点就是从头结点开始的第n-k+1个结点。如果我们能够得到链表中结点的个数n,那么我们只要从头结点开始向后走n-k+1步就可以了。<br>这个时候需要遍历链表两次，第一次统计出链表中结点的个数，第二次就能找到倒数第k个结点。<br>然而面试官希望我们能够只需要遍历依次链表就能够获取指定的值。</p><p>这个时候我们可以：</p><p><strong><font color="#DC143C">定义两个指针，第一个指针从链表的头指针开始遍历向前走k-1，第二个指针保持不动；从第k步开始，第二个指针也开始从链表的头指针开始遍历。由于两个指针的距离始终保持在k-1，当第一个（走在前面的）指针到达链表的尾结点时，第二个指针正好是倒数第k个结点。</font></strong></p><p><img src="/images/linkList.jpeg" alt=""></p><p>为了保证代码的鲁棒性，可以参考如下下代码；</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">listNode * findKthToTail(listNode * head,<span class="keyword">int</span> k) &#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">NULL</span> || k &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">NULL</span>;</span><br><span class="line">    listNode *pHead = head;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; k - <span class="number">1</span>; ++ i) &#123;</span><br><span class="line">        pHead = pHead -&gt; <span class="keyword">next</span>;</span><br><span class="line">        <span class="keyword">if</span> (pHead == <span class="keyword">NULL</span>) <span class="comment">// 防止k的大小超过链表的长度</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    listNode *pBehind = head;</span><br><span class="line">    <span class="keyword">while</span>(pHead -&gt; <span class="keyword">next</span> != <span class="keyword">NULL</span>) &#123;</span><br><span class="line">        pHead = pHead -&gt; <span class="keyword">next</span>;</span><br><span class="line">        pBehind = pBehind -&gt; <span class="keyword">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pBehind;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h2><blockquote><p>定义一个函数，输入一个链表的头结点，反转链表并输出反转后链表的头结点。</p></blockquote><p>为了正确反转一个链表，我们需要调整链表中指针的方向。如下图：</p><p><img src="/images/reservelist.png" alt=""></p><p>如上图所示的链表中,h,i和j是3个相邻的结点。假设经过若干操作，我们已经把结点h之前的指针调整完毕，这些结点的next都指向前面一个结点。接下来我们把i的next指向h,此时的链表如上图(b),由于结点i的next指向了它的前一个结点，导致链表在结点i,j之间断开。为了避免该问题，我们需要在调整结点i的next之前，把结点j保存下来。</p><p><strong><font color="#DC143C">我们在调整结点i的next指针时，除了需要知道结点本身之外还需要知道i的前一个结点h，因为我们需要把结点i的next指向结点h.同时还要事先保存i的一个结点j,以防止链表断开。</font></strong></p><p>代码如下：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">listNode * reserveList(listNode *head) &#123;</span><br><span class="line">    listNode * <span class="keyword">beReserved </span>= NULL<span class="comment">;</span></span><br><span class="line">    listNode *pNode = head<span class="comment">;</span></span><br><span class="line">    listNode *prev = NULL<span class="comment">;</span></span><br><span class="line">    while(pNode != NULL) &#123;</span><br><span class="line">        listNode *pNext = pNode -&gt; next<span class="comment">;</span></span><br><span class="line">        if (pNext == NULL)</span><br><span class="line">            <span class="keyword">beReserved </span>= pNode<span class="comment">;</span></span><br><span class="line">        pNode -&gt; next = prev<span class="comment">;</span></span><br><span class="line">        prev = pNode<span class="comment">;</span></span><br><span class="line">        pNode = pNext<span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">    return <span class="keyword">beReserved;</span></span><br><span class="line"><span class="keyword">&#125;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;链表中倒数第K个结点&quot;&gt;&lt;a href=&quot;#链表中倒数第K个结点&quot; class=&quot;headerlink&quot; title=&quot;链表中倒数第K个结点&quot;&gt;&lt;/a&gt;链表中倒数第K个结点&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;问题描述：输入一个链表，输出该链表中倒数第K个结点。例如一个链表有6个结点，从头结点开始它们的值依次是1，2，3，4，5，6。这个链表的倒数第三个结点值为4。&lt;br&gt;
    
    </summary>
    
      <category term="面试" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++面试问题准备：strcpy和strncpy以及memcpy函数</title>
    <link href="http://yoursite.com/2018/03/06/C-%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E5%87%86%E5%A4%87%EF%BC%9Astrcpy%E5%92%8Cstrncpy%E4%BB%A5%E5%8F%8Amemcpy%E5%87%BD%E6%95%B0/"/>
    <id>http://yoursite.com/2018/03/06/C-面试问题准备：strcpy和strncpy以及memcpy函数/</id>
    <published>2018-03-06T02:46:32.000Z</published>
    <updated>2018-03-08T05:26:05.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="strcpy函数以及strncpy函数"><a href="#strcpy函数以及strncpy函数" class="headerlink" title="strcpy函数以及strncpy函数"></a>strcpy函数以及strncpy函数</h2><blockquote><p>这两个函数都是字符串拷贝函数</p></blockquote><p>函数原型：</p><p><code>char * strcpy(char * destStr,char * srcStr);</code></p><p><code>cahr * strncpy(char * destStr,char * srcStr,int num);</code></p><a id="more"></a><p>很明显可以看出函数strncpy函数相对于函数strcpy更加安全，strcpy函数在进行复制的时候并没有考虑指定字符串空间的大小，如果目标字符串在空间没有指定字符串空间大的话会产生溢出，即内存泄漏。</p><p> 以上两个函数的实现如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">strcpy</span><span class="params">(<span class="keyword">char</span> * destStr,<span class="keyword">char</span> * srcStr)</span> </span>&#123;</span><br><span class="line">    assert((destStr != <span class="literal">NULL</span>) &amp;&amp; (srcStr != <span class="literal">NULL</span>));</span><br><span class="line">    <span class="keyword">char</span> * strDestCopy = destStr;</span><br><span class="line">    <span class="keyword">while</span>((*destStr++ = *srcStr++) != <span class="string">'\0'</span>);</span><br><span class="line">    <span class="keyword">return</span> strDestCopy;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">char</span> * <span class="title">strncpy</span><span class="params">(<span class="keyword">char</span> * destStr, <span class="keyword">char</span> * srcStr, <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    assert((destStr != <span class="literal">NULL</span>) &amp;&amp; (srcStr != <span class="literal">NULL</span>) &amp;&amp; (num != <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">char</span> * strDestCopy = destStr;</span><br><span class="line">    <span class="keyword">while</span>((*destStr++ = *srcStr++) != <span class="string">'\0'</span>)</span><br><span class="line">        num--;</span><br><span class="line">    <span class="keyword">if</span> (num &gt; <span class="number">0</span>) &#123;<span class="comment">//如果指定长度大于源字符串长度</span></span><br><span class="line">        <span class="keyword">while</span>(num --) &#123;</span><br><span class="line">            *destStr ++ = <span class="string">'\0'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> strDestCopy;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="memcpy函数"><a href="#memcpy函数" class="headerlink" title="memcpy函数"></a>memcpy函数</h2><blockquote><p>该函数可以针对任意类型数据进行拷贝</p></blockquote><p>函数原型：</p><p><code>void *memcpy(void*dest, const void *src, size_t n);</code></p><p>函数功能：</p><p>从src所指内存起始地址开始，拷贝n个字节的数据到目标地址空间dest.</p><p>函数实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">memory</span><span class="params">(<span class="keyword">void</span> *dst,<span class="keyword">const</span> <span class="keyword">void</span> *src,<span class="keyword">size_t</span> s)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">   <span class="keyword">const</span> <span class="keyword">char</span>* psrc=<span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">char</span>*&gt;(src); </span><br><span class="line">   </span><br><span class="line">    <span class="comment">//static_cast表示任何具有明确定义的类型转换，只要不包含底层const,都可以使用static_cast</span></span><br><span class="line">    <span class="comment">//const_cast只能改变运算对象的底层const,且其即可以添加const性质，也可以删除const性质</span></span><br><span class="line">    <span class="comment">//reinterpret_cast通常为运算对象的位模式提供较低层次上的重新解释</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">char</span>* pdst=<span class="keyword">static_cast</span>&lt;<span class="keyword">char</span>*&gt;(dst);  </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(psrc==<span class="literal">NULL</span> || pdst==<span class="literal">NULL</span>)  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;  </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(pdst &gt; psrc &amp;&amp; pdst &lt; (psrc+s))  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">size_t</span> i=s<span class="number">-1</span>;i!=<span class="number">-1</span>;i--)  </span><br><span class="line">            pdst[i]=psrc[i];  </span><br><span class="line">    &#125;  </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">else</span>  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">size_t</span> i=<span class="number">0</span>;i&lt;s;++i)  </span><br><span class="line">            pdst[i]=psrc[i];  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> dst;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;strcpy函数以及strncpy函数&quot;&gt;&lt;a href=&quot;#strcpy函数以及strncpy函数&quot; class=&quot;headerlink&quot; title=&quot;strcpy函数以及strncpy函数&quot;&gt;&lt;/a&gt;strcpy函数以及strncpy函数&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;这两个函数都是字符串拷贝函数&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;函数原型：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;char * strcpy(char * destStr,char * srcStr);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;cahr * strncpy(char * destStr,char * srcStr,int num);&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="面试" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>2018-03-04</title>
    <link href="http://yoursite.com/2018/03/04/2018-03-04/"/>
    <id>http://yoursite.com/2018/03/04/2018-03-04/</id>
    <published>2018-03-04T15:46:13.000Z</published>
    <updated>2018-03-05T07:05:47.000Z</updated>
    
    <content type="html"><![CDATA[<p>我和她不在一块的时间老想她，很想很想。结果今天中午回到学校，她竟然在我们学校学习，所以：<a id="more"></a><br>今天和糖永永同学呆在一块的时间大概有8个小时，这是一种很独特的感觉。<br>我们一起学习，她在看专八，我在总结面试笔记。我看看她，她看看我，莫名开心兴奋，当然对于我来说还真好，越看她越喜欢，然而她老不让我看她，其中有一个原因是她脸上有了一些小痘痘。</p><p>晚上回学校的时候，一路上沉默的时间很多，但并不是那种无话可说，而是发自内心的不想说话。结果她提到了以前和小胖子的相处方式，小胖子应该是属于那种非常能说话的，而且说的很好的那种。突然我内心有点失落，我发现我对她一点也不了解了，我又不知道她心里怎么想的了，她的内心还是很难受，她又很想他了，我不知道怎么对她说，因为我不了解，而且我个人属于那种现实生活中聊天很差的那种人，无法很清晰正确得表达自己想要表的东西。<br>就这样相处吧，还是希望能够对她以前的生活更了解一点！晚安啦！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我和她不在一块的时间老想她，很想很想。结果今天中午回到学校，她竟然在我们学校学习，所以：
    
    </summary>
    
      <category term="日记" scheme="http://yoursite.com/categories/life/"/>
    
    
  </entry>
  
  <entry>
    <title>C++面试问题准备：进程、线程、死锁、多线程还是多进程的选择以及区别</title>
    <link href="http://yoursite.com/2018/03/04/C-%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E5%87%86%E5%A4%87%EF%BC%9A%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%BF%98%E6%98%AF%E5%A4%9A%E8%BF%9B%E7%A8%8B%E7%9A%84%E9%80%89%E6%8B%A9%E4%BB%A5%E5%8F%8A%E5%8C%BA%E5%88%AB/"/>
    <id>http://yoursite.com/2018/03/04/C-面试问题准备：多线程还是多进程的选择以及区别/</id>
    <published>2018-03-04T12:27:20.000Z</published>
    <updated>2018-03-09T15:43:05.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h2><ul><li>一个进程由一个或多个线程组成，线程是一个进程中代码的不同执行路线；</li><li>进程之间相互独立，但同一进程下的各个线程之间共享程序的内存空间(包括代码段、数据集、堆等)及一些进程级的资源(如打开文件和信号)，某进程内的线程在其它进程不可见</li><li>调度和切换：线程上下文切换比进程上下文切换要快得多<a id="more"></a></li></ul><p><strong>进程几种状态</strong>：</p><p>创建态：进程正在创建，操作系统在创建进程时要进行的工作包括分配和建立进程控制块表项、建立资源表格并分配资源、加载程序并建立地址空间。</p><p>就绪态：时间片被用完，此线程被强制暂停，等待下一个属于它的时间片到来</p><p>运行态：此线程正在执行，正在占用时间片</p><p>阻塞：也叫等待状态，等待某一事件（如IO或另一个线程）执行完</p><p>退出：进程已结束，所以也称结束状态，释放操作系统分配的资源。</p><p><strong>线程几种状态</strong>：</p><p>创建：一个新的线程被创建，等待该线程被调用执行  </p><p>就绪：时间片已用完，此线程被强制暂停，等待下一个属于他的时间片到来  </p><p>运行：此线程正在执行，正在占用时间片  </p><p>阻塞：也叫等待状态，等待某一事件(如IO或另一个线程)执行完  </p><p>退出：一个线程完成任务或者其他终止条件发生，该线程终止进入退出状态，退出状态释放该线程所分配的资源</p><blockquote><p><strong><font color="#DC143C">线程共享的资源</font></strong>:<br> a. 堆：堆是在进程空间中开辟出来的，所以它是理所当然地被共享的。因此由malloc和new出来的都是共享的<br> b. 全局变量：它是与具体某一函数无关的，所以也与特定线程无关；因此也是共享的<br> c. 静态变量：即使是局部变量，在该局部变量存在的函数对于整个程序生存期间只有一份拷贝；因此也是共享的<br> d. 文件等公用资源：这个是共享的，使用这些公共资源的线程必须同步。windows下存在的几种线程同步资源的方式：信号、临界区、事件、互斥体<br> <strong><font color="#DC143C">线程独享的资源</font></strong>:<br> a. 线程ID:每个线程都有自己的线程ID，这个ID在本进程中是唯一的。进程用此来标识线程。<br> b. 寄存器组的值:由于线程间是并发运行的，每个线程有自己不同的运行线索，当从一个线程切换到另一个线程上时，必须将原有的线程的寄存器集合的状态保存，以便将来该线程在被重新切换到时能得以恢复。<br> c. 线程的堆栈:<font color="#DC143C">堆栈是保证线程独立运行所必须的.</font>线程函数可以调用函数，而被调用函数中又是可以层层嵌套的，所以线程 必须拥有自己的函数堆栈，使得函数调用可以正常执行，不受其他线程的影响。<br> d. 错误返回码:由于同一个进程中有很多个线程在同时运行，可能某个线程进行系统调用 后设置了errno值，而在该线程还没有处理这个错误，另外一个线程就在此时被调度器投入运行，这样错误值就有可能被修改<br> e. 线程的信号屏蔽码:由于每个线程所感兴趣的信号不同，所以线程的信号屏蔽码应该由线程自己管理。但所有的线程都共享同样的信号处理器<br> f. 线程的优先级:由于线程需要像进程那样能够被调度，那么就必须要有可供调度使用的参数，这个参数就是线程的优先级</p></blockquote><p> <strong><font color="#DC143C">如果有一组线程，每个线程都在等待一个事件的发生，而这个事件只能由该组线程里面的另一个线程发出，则称这组线程发生了死锁</font></strong></p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">线程A        线程B</span><br><span class="line"><span class="keyword">lock</span>(x);       <span class="keyword">lock</span>(y);</span><br><span class="line"><span class="keyword">lock</span>(y);       <span class="keyword">lock</span>(x);</span><br><span class="line">...            ...</span><br><span class="line"><span class="keyword">unlock</span>(y);     <span class="keyword">unlock</span>(x);</span><br><span class="line"><span class="keyword">unlock</span>(x);     <span class="keyword">unlock</span>(y);</span><br></pre></td></tr></table></figure><p>两线程交替执行，则会发生死锁。</p><h4 id="死锁的必要条件"><a href="#死锁的必要条件" class="headerlink" title="死锁的必要条件"></a><strong>死锁的必要条件</strong></h4><ul><li>资源有限：资源不能共享，在一个时候只能由一个线程使用。否则肯定不会发生死锁的。</li><li>持有等待：一个线程在请求新的资源时，其已经获得的资源并不释放，而是继续持有。一个线程在请求资源时，其并没有持有任何资源，自然就不会阻挠别的线程运行。</li><li>不能抢占：如果可以抢占别的线程正在占用的资源，则也不会发生死锁。</li><li>循环等待：如果你等我、我等你、大家都在等着对方，就产生了死锁。</li></ul><h4 id="死锁的应对"><a href="#死锁的应对" class="headerlink" title="死锁的应对"></a><strong>死锁的应对</strong></h4><p><strong><font color="#DC143C">顺其自然：不予理睬</font></strong></p><p>即操作系统不做任何措施，任由死锁发生。在商业操作系统中，死锁发生的频率并不是很高，而且防止死锁的代价很高，比重启100次代价还高。所以有的时候什么也不做其实更好。</p><p><strong><font color="#DC143C">先礼后兵：死锁监测与修复</font></strong></p><p>在高可靠性系统、实时控制系统那就需要进行死锁的防止了。</p><ul><li><p>死锁的检测：死锁的原因是资源竞争，我们只要对资源的拥有和对资源的请求都很清楚的话问题就解决了。</p><ol><li>将线程的资源占用和需求关系用一个有向图表示出来，再检查图中有没有循环，如果有，就发生死锁。但是这种检车算法的事件复杂度为O(n^3)，如果每次资源分配发生变化的时候，做这样一次检查系统效率会出现明显下降。</li></ol><p><img src="/images/deadLock.jpg" alt=""></p><ol><li>利用矩阵：资源分配矩阵和资源等待矩阵。同时维持两个矢量：系统资源总量矢量，表示系统中所有资源的总数是多少；另一个是系统当前可用资源矢量，代表系统还有多少可用资源。<strong><font color="#DC143C">我们将可用资源拿来与资源等待矩阵每一次进行比较，你就知道谁不能满足，如果减出来，每个线程都有负数，那就是发生了死锁。</font></strong></li></ol></li><li>死锁的恢复：<ol><li>抢占：将某个线程所占用的资源强行拿走，分配给别的线程。被抢占的线程很有可能不能正确运行。而且结果很难预料</li><li>杀掉：讲整个线程kill,因为抢占该线程的资源有可能已经造成该线程无法再正确运行。结果也是很难预料</li><li>上翻：即将整个系统反转到过去的某个状态，大家从那个状态重新来过。<blockquote><p>该策略实际上根本行不通，在检测与恢复两个部分都存在巨大困难。致命的问题是：检查死锁的线程自己发生了死锁，此时，死锁检查程序已经无法推进，自然无法检查死锁是否发生。</p></blockquote></li></ol></li></ul><p><strong><font color="#DC143C">先发制人：死锁的动态避免</font></strong></p><p>在每次进行资源分配时，必须经过仔细计算，确保该资源请求批准后系统不会进入死锁或潜在的死锁状态。</p><ul><li>安全状态：从该状态开始，我们能够找到一种资源分配方法和顺序，使得所有的线程都能获得其所需要的资源，从而不会产生死锁。</li><li>不安全状态：尚未发生死锁的状态，但接下来的执行一定会产生死锁。</li></ul><p><strong><font color="#DC143C">执行手段：防止系统进入不安全状态，每次进行资源分配的时候计算一下该分配是否会将系统带入不安全状态，如果是，就否决相关资源请求；否则，就批准。</font></strong></p><blockquote><p>动态避免的<br>优点：无需等待死锁的发生。<br>缺点：计算一个状态是否安全并不容易。如果一个系统资源种类繁杂，线程个数庞大，这种计算将变得十分复杂和费时。更致命的是我们想要预测一个线程的最大资源需求是，进行的估算按照人类一般的超额估算来说是会造成非常严重的后果：资源浪费，死锁误判。</p></blockquote><p><strong><font color="#DC143C">斩草除根：死锁的静态防止</font></strong><br>清除死锁发生的土壤，消除死锁发生的4个必要条件中的任何一个，则死锁将无法发生。</p><ul><li>消除资源独占条件：将资源无限增加或把所有资源变为共享。比如打印机，它是不允许任何线程直接占有，而是设计一个”精灵”程序daemon来管理，所有打印任务都必须经由它发出。</li><li>消除持有等待条件：一个线程必须一次请求其所需要的所有资源，而不是一般情况下的请求一点资源，做一点事情；到需要下一个资源的时候再请求一点，这样获得资源后再将整个程序推进。</li><li>消除非抢占条件：允许抢占资源，可以从一个线程手上将资源抢夺过来。一个线程可以将CPU或内存空间从一个线程手上抢过来，从而避免了因CPU和内存空间的竞争造成死锁。<font color="#DC143C">并不是所有的资源都可以被抢占而不产生不良后果，例如锁</font></li><li>消除循环等待条件：一个线程可以先请求资源A再请求资源B，也可以先请求B再请求资源A。这样如果两个线程按照按照不同的顺序请求A、B两个资源，死锁就有可能发生。但是我们可以规定对A、B两个资源的使用必须按照先A后B的顺序请求，则死锁就不会发生。</li></ul><h2 id="多进程-和多线程的区别"><a href="#多进程-和多线程的区别" class="headerlink" title="多进程 和多线程的区别"></a>多进程 和多线程的区别</h2><blockquote><p>进程是资源分配的最小单位，线程是CPU调度的最小单位。 <!--more--></p></blockquote><p>关于多进程和多线程的区别可以参考如下图：</p><p><img src="/images/moreIPC.png" alt=""></p><h2 id="多进程和多线程的选择"><a href="#多进程和多线程的选择" class="headerlink" title="多进程和多线程的选择"></a>多进程和多线程的选择</h2><p><strong><font color="#DC143C">需频繁创建销毁的优先用线程</font></strong></p><p>这种原则最常见的应用就是Web服务器了，来一个连接建立一个线程，断了就销毁线程，要是用进程，创建和销毁的代价是很难承受的</p><p><strong><font color="#DC143C">需要进行大量计算的优先使用线程</font></strong></p><p>大量计算当然就是要耗费很多CPU，切换频繁了，这种情况下线程是最合适的，一般应用在：图像处理和算法处理。</p><p><strong><font color="#DC143C">强相关的处理用线程，弱相关的处理用进程</font></strong></p><p>一般的Server需要完成如下任务：消息收发、消息处理。“消息收发”和“消息处理”就是弱相关的任务，而“消息处理”里面可能又分为“消息解码”、“业务处理”，这两个任务相对来说相关性就要强多了。因此“消息收发”和“消息处理”可以分进程设计，“消息解码”、“业务处理”可以分线程设计。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;进程和线程的区别&quot;&gt;&lt;a href=&quot;#进程和线程的区别&quot; class=&quot;headerlink&quot; title=&quot;进程和线程的区别&quot;&gt;&lt;/a&gt;进程和线程的区别&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;一个进程由一个或多个线程组成，线程是一个进程中代码的不同执行路线；&lt;/li&gt;
&lt;li&gt;进程之间相互独立，但同一进程下的各个线程之间共享程序的内存空间(包括代码段、数据集、堆等)及一些进程级的资源(如打开文件和信号)，某进程内的线程在其它进程不可见&lt;/li&gt;
&lt;li&gt;调度和切换：线程上下文切换比进程上下文切换要快得多
    
    </summary>
    
      <category term="面试" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++面试问题总结：指针和引用的区别以及extern C的作用</title>
    <link href="http://yoursite.com/2018/03/04/C-%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93%EF%BC%9A%E6%8C%87%E9%92%88%E5%92%8C%E5%BC%95%E7%94%A8%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://yoursite.com/2018/03/04/C-面试问题总结：指针和引用的区别/</id>
    <published>2018-03-04T05:50:38.000Z</published>
    <updated>2018-03-04T10:40:12.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="指针和引用的区别"><a href="#指针和引用的区别" class="headerlink" title="指针和引用的区别"></a>指针和引用的区别</h3><blockquote><p>指针和引用都代表的是地址</p></blockquote><ul><li><strong>引用</strong>需要指向某些对象，但是你可以声明指针变量为空，然后将引用指向该指针变量。</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">char</span> <span class="meta">*pc</span> <span class="string">=</span> <span class="literal">NULL</span><span class="string">;</span></span><br><span class="line"><span class="string">char</span> <span class="meta">&amp;rc</span> <span class="string">=</span> <span class="string">*pc;</span></span><br></pre></td></tr></table></figure><a id="more"></a><ul><li>因为引用肯定会指向一个对象，因此必须初始化，其实和１是一回事。指针无此限制，但是，其实指针的未初始化，过不了coverity这些工具的检测。</li><li>指针可以重新赋值，引用不可以，初始化后就不可改变:即不可以通过以更改指针的方式来更改引用的值，即直接对已经初始化的引用赋值。</li><li>sizeof结果不同，指针返回的是指针本身大小，引用返回的是引用对象的大小:如果是指针的话，一般指针大小是4B，引用返回的大小是引用对象的大小，这样就可能因为对象类型不同而不同。</li><li>引用不需要占用空间,它只是别名，不占用空间。</li></ul><h3 id="extern-C"><a href="#extern-C" class="headerlink" title="extern C"></a>extern C</h3><ul><li>C++代码调用C语言代码</li><li>C++头文件中使用</li><li>多人协同开放的时候可能有的人擅长C语言，有的人擅长C++，这样的情况使用<code>extern c</code>就可以在C++ 中使用C语言</li></ul><p>这里的原因是在编译器对C语言和C++编译的方式有不同。<br>比如针对函数<code>void fun(int ,int )</code>,编译器处理的时候如果按照C语言的方式编译，会将该函数标识为<code>_fun()</code>，此时如果编译器按照C++编译的时候会将该函数编译为<code>_funii()</code>,如果该函数是在C语言的头文件中，我想要C++中调用该函数，肯定需要使用<code>extern c</code>来包含该头文件中的函数，否则在C++编译的情况下，对函数名处理的结果是_funii(),但是真正是找不到这样的函数实际调用的。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;指针和引用的区别&quot;&gt;&lt;a href=&quot;#指针和引用的区别&quot; class=&quot;headerlink&quot; title=&quot;指针和引用的区别&quot;&gt;&lt;/a&gt;指针和引用的区别&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;指针和引用都代表的是地址&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;引用&lt;/strong&gt;需要指向某些对象，但是你可以声明指针变量为空，然后将引用指向该指针变量。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight yaml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;meta&quot;&gt;*pc&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;string&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;meta&quot;&gt;&amp;amp;rc&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;*pc;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="面试" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>2018-03-02</title>
    <link href="http://yoursite.com/2018/03/02/2018-03-02/"/>
    <id>http://yoursite.com/2018/03/02/2018-03-02/</id>
    <published>2018-03-02T13:42:39.000Z</published>
    <updated>2018-03-03T06:19:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天去火车站接到了糖小猪同学，她以为我不会去，结果，哈哈哈，把她给吓到了。</p><p>和她安安静静得坐了一个多小时得火车，嘿嘿，可以看的出来她挺开心的，不过我的初衷是天这么黑，担心她的安全！</p><p>之后回到学校，我们进行了一天简单的应该算是约会吧，一起吃了鸡公煲，一起摘了一筐草莓，有的甜，有的酸。一起从西安外国语大学走到了接近西北政法大学的一个影院，一起看了电影《红海行动》，在路上碰到一个以前学习英语的雪婷老师，结果没理我，我一脸懵逼！糖同学一出口就是是不是你们以前学习口语的，哎呦，我的天哪，她怎么知道的，我的天，内心太震惊了！然后一起在学校里吃了元宵，一起坐在饭堂三楼靠窗的做为聊天，一起走在有大月亮的路上，一切都是美好的开始。</p><p>感觉和她有那么一点点默契了，有的时候她知道我是怎么想的，有的时候我知道她是怎么想的。想到接下来的日子就莫名开心，同样我也会尽自己最大的可能准备北京的工作问题。为了以后能够更容易就这样简简单单，我会在接下来的两个月付出自己所有的能量！</p><p>今天我们走了最少有一万步，嘿嘿。有点累，但是很开心。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天去火车站接到了糖小猪同学，她以为我不会去，结果，哈哈哈，把她给吓到了。&lt;/p&gt;
&lt;p&gt;和她安安静静得坐了一个多小时得火车，嘿嘿，可以看的出来她挺开心的，不过我的初衷是天这么黑，担心她的安全！&lt;/p&gt;
&lt;p&gt;之后回到学校，我们进行了一天简单的应该算是约会吧，一起吃了鸡公煲
      
    
    </summary>
    
      <category term="日记" scheme="http://yoursite.com/categories/life/"/>
    
    
  </entry>
  
  <entry>
    <title>C++面试问题准备：剑指 offer-包含min函数的栈和栈的压入和弹出</title>
    <link href="http://yoursite.com/2018/02/28/C-%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E5%87%86%E5%A4%87%EF%BC%9A%E5%89%91%E6%8C%87-offer-%E5%8C%85%E5%90%ABmin%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88%E5%92%8C%E6%A0%88%E7%9A%84%E5%8E%8B%E5%85%A5%E5%92%8C%E5%BC%B9%E5%87%BA/"/>
    <id>http://yoursite.com/2018/02/28/C-面试问题准备：剑指-offer-包含min函数的栈和栈的压入和弹出/</id>
    <published>2018-02-27T16:12:54.000Z</published>
    <updated>2018-03-03T07:27:32.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="包含min函数的栈"><a href="#包含min函数的栈" class="headerlink" title="包含min函数的栈"></a>包含min函数的栈</h2><blockquote><p>题目描述：定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的min函数，且在该栈中调用min,push以及pop的时间复杂度都是O(1)<a id="more"></a></p></blockquote><p>看到这个问题我们会想到每一次将元素压入栈的时候对栈内所有的元素进行排序，将最小的元素放到栈顶，这样可以在O(1)时间内获得最小元素，但是这样的结果造成的是不能保证最后压入的元素最先出栈，这样就不是栈了。</p><p>那么我们又可以想到在栈中添加一个成员变量用来存放最小元素，每次压入栈的时候将当前元素与要压入的元素进行比较，并且更新该成员变量。此时如果最小元素被弹出了，如何得到下一个最小元素呢？</p><p>这个时候就发现仅仅添加一个栈的成员变量是不够的，因此我们想要在压入这个最小元素之前将次小元素保存下来。这个时候我们可以采用 <strong><font color="#DC143C">辅助栈</font></strong>，保存最小元素和次小元素。</p><p>可以浏览下图，看看整个压入和弹出的过程是什么样子的。</p><p><img src="/images/minStack.png" alt=""></p><p>以上过程是这样子的：<strong>首先往空的数据栈中压入3，显然现在3是最小的，所以同时向辅助栈压入最小值。接下来向数据栈中压入数字4，由于4大于之前的最小值，因此我们仍然往辅助栈里压入数字3。第三步，继续向数据栈里压入数字2，由于2小于之前的最小值3，因此我们将最小值更新为2，并把2压入辅助栈，同样压入数字1的时候也要更新最小值，并把新的最小值压入辅助栈。当第五步在数据栈中弹出1的时候，我们把辅助栈的栈顶弹出，辅助栈的栈顶元素就是2。接下来继续弹出数据栈和辅助栈的栈顶之后，数据栈还剩下3、4两个数字，3是最小值。此时位于辅助栈的栈顶数字也正好是3。</strong></p><p>函数代码如下：</p><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T&gt; <span class="keyword">void</span> stackWithMin&lt;T&gt;::push(const T&amp; <span class="keyword">value</span>) &#123;</span><br><span class="line">    m<span class="number">_</span>data.push(<span class="keyword">value</span>);</span><br><span class="line">    <span class="keyword">if</span> (m<span class="number">_m</span><span class="keyword">in</span>.size() == <span class="number">0</span> || <span class="keyword">value</span> &lt; m<span class="number">_m</span><span class="keyword">in</span>.top())</span><br><span class="line">        m<span class="number">_m</span><span class="keyword">in</span>.push(<span class="keyword">value</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        m<span class="number">_m</span><span class="keyword">in</span>.push(m<span class="number">_m</span><span class="keyword">in</span>.top());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;typename T&gt; <span class="keyword">void</span> stackWithMin&lt;T&gt;::pop() &#123;</span><br><span class="line">    <span class="keyword">assert</span>(m<span class="number">_</span>data.size() &gt; <span class="number">0</span> &amp;&amp; m<span class="number">_m</span><span class="keyword">in</span>.size() &gt; <span class="number">0</span>); <span class="comment">// assert的作用是现计算表达式 expression ，如果其值为假（即为0），那么它先向stderr打印一条出错信息，然后通过调用 abort 来终止程序运行</span></span><br><span class="line">    m<span class="number">_</span>data.pop();</span><br><span class="line">    m<span class="number">_m</span><span class="keyword">in</span>.pop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;typename T&gt; <span class="keyword">void</span> stackWithMin&lt;T&gt;::min() const &#123;</span><br><span class="line">    <span class="keyword">assert</span>(m<span class="number">_</span>data.size() &gt; <span class="number">0</span> &amp;&amp; m<span class="number">_m</span><span class="keyword">in</span>.size() &gt; <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> m<span class="number">_m</span><span class="keyword">in</span>.top();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="栈的压入弹出序列"><a href="#栈的压入弹出序列" class="headerlink" title="栈的压入弹出序列"></a>栈的压入弹出序列</h2><blockquote><p>输入两个整数序列，第一个整数表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1、2、3、4、5是某栈的压栈序列，序列4、5、3、2、1是该栈序列对应的一个弹出序列，但4、3、5、1、2就不可能是该压栈序列的弹出序列。</p></blockquote><p>借用一个辅助栈，把输入的第一个序列中的数字依次压入该辅助栈，并按照第二个序列的顺序依次从该栈中弹出数字。</p><p>以弹出序列4、5、3、2、1为例分析压栈和弹出的过程。第一个希望被弹出的数字是4，因此4需要先压入到辅助栈里面。压入栈的顺序由压栈序列确定了，也就是把4压入到栈之前，数字1、2、3都需要西安压入到栈里面。此时栈里包含4个数字，分别是1、2、3、4，其中4是栈顶。把4弹出后栈中就剩下里1、2、3。接下来希望被弹出的数字是5，由于它不是栈顶数字，接着我们在第一个序列中把4以后数字压入 <strong><font color="#DC143C">辅助栈</font></strong>，直到压入数字5。这个时候5位于栈顶，就可以被弹出来了。接下来希望弹出的三个数字是3、2、1。由于每次操作前他们都位于栈顶，因此直接弹出即可。以下是该操作的全部过程：</p><p><img src="/images/pushStack.png" alt=""></p><p>接下来再分析弹出序列4、3、5、1、2。第一个弹出的数字4的情况和前面一样。把4弹出之后，3位于栈顶，可以直接弹出。接下来希望弹出的数字是5，由于5不是栈顶数字，到压栈序列里把没有压栈的数字压入辅助栈，直至遇到数字5。把数字5压入栈之后，5就位于栈顶了，可以弹出。此时栈内有两个数字1和2，其中2位于栈顶。由于接下来需要弹出的数字是1，但1不在栈顶，我们需要从压栈序列中尚未压入栈的数字中去搜索这个数字。但此时压栈序列中所有数字都已经压入栈了。所以该序列不是序列1、2、3、4、5对应的弹出序列。<br>该过程如下：</p><p><img src="/images/stack.png" alt=""></p><p>总结以下不是栈弹出序列的规律：</p><p><strong><font color="#DC143C">如果下一个弹出的数字刚好是栈顶数字，直接弹出就可以。如果下一个数字不是栈顶数字，我们把压栈序列中还没有压入栈的数字压入辅助栈，直到把下一个需要弹出的数字压入栈顶为止。如果所有的数字都压入栈了仍然没有找到下一个弹出的数字，那么该序列不可能是一个弹出序列。</font></strong></p><p>函数代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPopOrder</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> * pPush,<span class="keyword">const</span> <span class="keyword">int</span> * pPop, <span class="keyword">int</span> nLength)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> bPossible = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (pPush != <span class="literal">NULL</span> &amp;&amp; pPop != <span class="literal">NULL</span> &amp;&amp; nLength &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> * pNextpush = pPush;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> * pNextpop = pPop;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">stack</span> &lt;<span class="keyword">int</span>&gt; stackData;</span><br><span class="line">        <span class="keyword">while</span> (pNextPop - pPop &lt; nLength) &#123;</span><br><span class="line">            <span class="keyword">while</span> (stackData.empty() || stackData.top() != *pNextPop) &#123;</span><br><span class="line">                <span class="keyword">if</span> (pNextPush - pPush == nLength)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                stackData.push(* pNextPush);</span><br><span class="line">                pNextPush ++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (stackData.top() != *pNextPop)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            stackData.pop();</span><br><span class="line">            pNextPop ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (stackData.empty() &amp;&amp; pNextPop - pPop == nLength)</span><br><span class="line">            bPossible = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bPossible;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;包含min函数的栈&quot;&gt;&lt;a href=&quot;#包含min函数的栈&quot; class=&quot;headerlink&quot; title=&quot;包含min函数的栈&quot;&gt;&lt;/a&gt;包含min函数的栈&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;题目描述：定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的min函数，且在该栈中调用min,push以及pop的时间复杂度都是O(1)
    
    </summary>
    
      <category term="面试" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>2018-02-27</title>
    <link href="http://yoursite.com/2018/02/27/2018-02-27/"/>
    <id>http://yoursite.com/2018/02/27/2018-02-27/</id>
    <published>2018-02-27T15:31:50.000Z</published>
    <updated>2018-02-27T15:58:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近脑袋处于紧绷状态，随着春招的临近，北京的相关公司招聘信息发来很多。投了几家较为中意公司的简历，同时自己也铆足精神全心准备笔试和面试。<a id="more"></a></p><p>同时最近在读书的时候努力提升自己的结构化思维能力，让自己在准备过程中梳理的知识更加由条理，方便记忆！</p><p>看着手机里海信多媒体研发中心的新员工群，默默得退了出去，青岛：以后可以去旅游！</p><p>很开心她即将到学校，这样就能每天见到她了！莫名开心！她竟然不说她什么时候到学校，凭借我机制的头脑一下子就从购票网站上搜出她的车次以及到达时间，看着31个小时的车程，这是真心很累,记得以前做了一个29小时去上海的火车，那都快要崩溃了，满脸油光，还顶着一个油头下了车，仿佛自己有一个月没有洗脸洗头洗澡，痛苦如斯！</p><p>附一张她手机里我们聊天背景图：(虽然还是不太懂背景图的含义,以后应该会懂吧)</p><p><img src="/images/yongyong/小黄花.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近脑袋处于紧绷状态，随着春招的临近，北京的相关公司招聘信息发来很多。投了几家较为中意公司的简历，同时自己也铆足精神全心准备笔试和面试。
    
    </summary>
    
      <category term="日记" scheme="http://yoursite.com/categories/life/"/>
    
    
  </entry>
  
  <entry>
    <title>C++面试问题准备：linux cpu、系统性能调试相关命令</title>
    <link href="http://yoursite.com/2018/02/26/C-%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E5%87%86%E5%A4%87%EF%BC%9Alinux-cpu%E3%80%81%E7%B3%BB%E7%BB%9F%E6%80%A7%E8%83%BD%E8%B0%83%E8%AF%95%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/"/>
    <id>http://yoursite.com/2018/02/26/C-面试问题准备：linux-cpu、系统性能调试相关命令/</id>
    <published>2018-02-26T13:07:17.000Z</published>
    <updated>2018-02-26T16:07:24.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Linux下查看内存和CPU占用情况"><a href="#Linux下查看内存和CPU占用情况" class="headerlink" title="Linux下查看内存和CPU占用情况"></a>Linux下查看内存和CPU占用情况</h2><h3 id="ps-将某个时间点的进程运行情况选取下来"><a href="#ps-将某个时间点的进程运行情况选取下来" class="headerlink" title="ps:将某个时间点的进程运行情况选取下来"></a><strong><code>ps</code>:将某个时间点的进程运行情况选取下来</strong></h3><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ps</span> aux  &lt;== 查看系统所有进程数据</span><br><span class="line"><span class="keyword">ps</span> -lA &lt;== 也是能够查看所有系统的数据</span><br><span class="line"><span class="keyword">ps</span> axjf &lt;== 连同部分进程树状态</span><br></pre></td></tr></table></figure><a id="more"></a><p><code>ps</code>命令参数：</p><ul><li>-A ： 所有的进程都显示出来，与-e具有同样的作用</li><li>-a ： 有效用户（effective user）相关的进程</li><li>-u ： 不与terminal有关的所有进程</li><li>x ： 通常与 a 这个参数一起使用，可列出较完整的信息<br>输出格式规划</li><li>l ： 较长、较详细地将该PID的信息列出</li><li>j ： 工作的格式（jobs format）</li><li>-f ： 做一个更为完整的输出</li></ul><h3 id="仅查看自己的bash相关进程"><a href="#仅查看自己的bash相关进程" class="headerlink" title="仅查看自己的bash相关进程"></a><strong><font color="#DC143C">仅查看自己的bash相关进程</font></strong></h3><p><img src="/images/linuxImages/ps_l.png" alt=""></p><blockquote><p>仅列出自己操作环境下的进程，即最上层的父进程会是你自己的bash，而没有扩展到init这个进程中去</p></blockquote><p>显示出来的数据含义如下：</p><ul><li>F ： 代表这个进程标志，说明这个进程的权限，常见号码有：<ul><li>若为4标识此进程权限为root</li><li>若为1则表示此子进程仅可复制而无法实际执行</li></ul></li><li>S ： 代表这个进程状态，主要的状态有：<ul><li>R（Running）：该进程正在运行中</li><li>S（sleep）：该进程目前正在睡眠状态，但可以被唤醒</li><li>D：不可被唤醒状态，通常这个进程可能在等待I／O的情况</li><li>T：停止状态，可能是在工作控制或者除错状态</li><li>Z（Zombie）：”僵尸”状态，进程已经已经终止，但是无法被删除在内存之外</li></ul></li><li>UID／PID／PPID：代表此进程被该UID所拥有／进程的PID号码／此进程的父进程PID号码</li><li>C：代表CPU使用率，单位为百分比</li><li>PRI/NI：代表此进程被CPU执行的优先级，数值越小代表进程越快被CPU执行。</li><li>ADDR／SZ／WCHAN：都与内存有关，ADDR是kernel function，指出该进程在内存的哪个部分，如果是running的进程。一般就会显示”-“。SZ带表此进程用掉多少内存／WCHAN表示目前进程是否运行中，同样若为-表示正在运中</li><li>TTY： 登录者的终端机位置，若为远程登录，则使用动态终端接口</li><li>TIME：使用掉的CPU时间，此为<strong>花费CPU运行的时间，并非系统时间</strong></li><li>CMD： 即触发进程的命令</li></ul><blockquote><p>那么我们针对以上图片显示的命令做一个解释：它说明的是bash的进程属于UID为1000的用户，状态为睡眠（第二行），之所以为睡眠是因为它触发了ps（状态为run）的原因。此进程的PID为130209，优先执行顺序为80，执行bash所取得的终端接口为pts/6,运行状态为等待。</p></blockquote><h3 id="查看系统所有进程"><a href="#查看系统所有进程" class="headerlink" title="查看系统所有进程"></a><strong><font color="#DC143C">查看系统所有进程</font></strong></h3><p><img src="/images/linuxImages/ps_aux.png" alt=""></p><blockquote><p>该显示与<code>ps -l</code>内容并不相同</p></blockquote><p>该显示数据意义如下：</p><ul><li>USER：进程所属用户账号</li><li>PID：进程标识符</li><li>%CPU：该进程用掉的CPU资源百分比</li><li>%MEM：该进程所占用物理内存百分比</li><li>VSZ：该进程用掉的虚拟内存量</li><li>RSS：该进程占用的固定内存量</li><li>TTY：该进程所运行的终端机</li><li>STAT：该进程目前状态，与<code>ps -l</code>中 S 标识相同</li><li>TIME：该进程实际使用CPU运行时间</li><li>COMMAND：该进程实际命令</li></ul><h3 id="以ps-l所显示的数据格式显示所有进程"><a href="#以ps-l所显示的数据格式显示所有进程" class="headerlink" title="以ps -l所显示的数据格式显示所有进程"></a><strong><font color="#DC143C">以<code>ps -l</code>所显示的数据格式显示所有进程</font></strong></h3><p><img src="/images/linuxImages/ps_lA.png" alt=""></p><blockquote><p>该显示的数据字段是与<code>ps -l</code>所显示的相同，但是显示的是所有的</p></blockquote><h3 id="列出类似进程树的程序显示"><a href="#列出类似进程树的程序显示" class="headerlink" title="列出类似进程树的程序显示"></a><strong><font color="#DC143C">列出类似进程树的程序显示</font></strong></h3><p><img src="/images/linuxImages/ps_axjf.png" alt=""><br><img src="/images/linuxImages/ps_tree.png" alt=""></p><blockquote><p>要显示进程树最好的且最直观的命令就是pstree，同样我们可以从以上截图中看到我是通过运行中的bash执行ps axjf命令。<br>此外请大家注意 <strong><font color="#DC143C">僵尸进程：该进程已经执行完毕，或者是因为事故应该要终止，但是该进程的父进程却无法将该进程结束掉，造成该进程一直存在在内存当中。即如果发现某个进程CMD后面还接上<font size="6">\<defunct></defunct></font>时就代表该进程是僵尸进程</font></strong></p></blockquote><h3 id="top-动态查看进程的变化"><a href="#top-动态查看进程的变化" class="headerlink" title="top:动态查看进程的变化"></a><strong><code>top</code>:动态查看进程的变化</strong></h3><blockquote><p><code>ps</code>是选取一个时间点的进程状态，top则可以持续检测进程运行的状态</p></blockquote><p><code>top</code>命令参数如下：</p><ul><li>-d ： 后面可以接秒数，即整个系统界面更新的秒数</li><li>-b ： 以批次的方式执行 top，通常会搭配数据流重定向来将批处理的结果输出成文件</li><li>-n ： 与-b搭配，意义是，需要进行几次 top 的输出结果</li><li>-p ： 制定某些个PID来进行查看监测</li><li>在top执行过程中可以使用的按键命令：<ul><li>? ： 显示在top当中可以输入的按键命令</li><li>P ： 以CPU的使用资源排序显示</li><li>M ： 以内存的使用资源来排序显示</li><li>N ： 以PID来排序</li><li>T ： 由该进程使用的CPU 时间积累排序</li><li>k ： 给予某个PID一个信号</li><li>r ： 给予某个PID重新制定一个nice值；</li><li>q ： 离开top软件的按键</li></ul></li></ul><p>如下，我们使用命令<code>top -d 2</code>做一个显示:</p><p><img src="/images/linuxImages/top.png" alt=""></p><p>其中显示数据代表如下：</p><ul><li>第一行：<br>06:19:45 — 当前系统时间<br>3 days, 7:29 — 系统已经运行了3天7小时29分钟（在这期间没有重启过）<br>1 users — 当前有1个用户登录系统<br>load average: 0。00, 0。00, 0。00 — load average后面的三个数分别是1分钟、5分钟、15分钟的负载情况。<blockquote><p>load average数据是每隔5秒钟检查一次活跃的进程数，然后按特定算法计算出的数值。如果这个数除以逻辑CPU的数量，结果高于5的时候就表明系统在超负荷运转了。</p></blockquote></li><li>第二行：<br>Tasks — 任务（进程），系统现在共有249个进程，其中处于运行中的有1个，248个在休眠（sleep），stoped状态的有0个，zombie状态（僵尸）的有0个<blockquote><p>这里需重点关注zombie状态的进程，快速找出僵尸进程并对问题进行分析解决</p></blockquote></li><li>第三行：cpu状态<br>1.0% us — 用户空间占用CPU的百分比。<br>0.5% sy — 内核空间占用CPU的百分比。<br>0.0% ni — 改变过优先级的进程占用CPU的百分比<br>98.5% id — 空闲CPU百分比<br>0.0% wa — IO等待占用CPU的百分比<br>0.0% hi — 硬中断（Hardware IRQ）占用CPU的百分比<br>0.0% si — 软中断（Software Interrupts）占用CPU的百分比</li><li>第四行是第二个CPU的状态</li><li>第五行：内存状态<br>998260k total — 物理内存总量（998MB）<br>616476k used — 使用中的内存总量（616MB）<br>115876k free — 空闲内存总量（115MB）<br>265908k buffers — 缓存的内存量 （265MB）</li><li>第六行：swap交换分区<br>1046524k total — 交换区总量（1GB）<br>551864k used — 使用的交换区总量（551MB）<br>494660k free — 空闲交换区总量（494MB）<br>163172k cached — 缓冲的交换区总量（163MB）</li><li>第七行：空行，当在top进程中输入命令时显示状态的地方</li><li>第八行一下：各进程（任务）的状态监控<ul><li>PID — 进程id</li><li>USER — 进程所有者</li><li>PR — 进程优先级</li><li>NI — nice值。负值表示高优先级，正值表示低优先级</li><li>VIRT — 进程使用的虚拟内存总量，单位kb。VIRT=SWAP+RES</li><li>RES — 进程使用的、未被换出的物理内存大小，单位kb。RES=CODE+DATA</li><li>SHR — 共享内存大小，单位kb</li><li>S — 进程状态。D=不可中断的睡眠状态 R=运行 S=睡眠 T=跟踪/停止 Z=僵尸进程</li><li>%CPU — 上次更新到现在的CPU时间占用百分比</li><li>%MEM — 进程使用的物理内存百分比</li><li>TIME+ — 进程使用的CPU时间总计，单位1/100秒</li><li>COMMAND — 进程名称（命令名/命令行）</li></ul></li></ul><h3 id="将top的信息更新2次后结果输出到-tmp-top-txt"><a href="#将top的信息更新2次后结果输出到-tmp-top-txt" class="headerlink" title="将top的信息更新2次后结果输出到/tmp/top.txt"></a><strong><font color="#DC143C">将top的信息更新2次后结果输出到/tmp/top.txt</font></strong></h3><p><img src="/images/linuxImages/top_b.png" alt=""></p><blockquote><p>这样我们就可以将系统进程运行状态保存下来，从而方便进行之后的系统查错,而且该方法也可以得到全部的进程界面</p></blockquote><h3 id="对单一进程进行监测"><a href="#对单一进程进行监测" class="headerlink" title="对单一进程进行监测"></a><strong><font color="#DC143C">对单一进程进行监测</font></strong></h3><p>执行命令<code>top -d 2 -p 1282</code>显示结果如下： </p><p><img src="/images/linuxImages/top_p.png" alt=""></p><h3 id="利用pstree进程树命令查看指定进程的父子进程"><a href="#利用pstree进程树命令查看指定进程的父子进程" class="headerlink" title="利用pstree进程树命令查看指定进程的父子进程"></a><strong><font color="#DC143C">利用<code>pstree</code>进程树命令查看指定进程的父子进程</font></strong></h3><p><img src="/images/linuxImages/pstree_A.png" alt=""></p><blockquote><p>显示系统所有进程树的相关性，截图没办法全面截取，大家实践的时候将它重定向到一个文件</p></blockquote><p><img src="/images/linuxImages/pstree_Aup.png" alt=""></p><blockquote><p>其中1282PID 所对应的进程为<code>sudo</code>,其父进程为<code>bash</code>,子进程为<code>su</code></p></blockquote><h2 id="Linux下进行系统性能调试"><a href="#Linux下进行系统性能调试" class="headerlink" title="Linux下进行系统性能调试"></a>Linux下进行系统性能调试</h2><p>利用<code>iostat</code>监测IO状态</p><blockquote><p>这里需要先在系统执行命令<code>apt install sysstat</code>，这样才能正常使用iostat</p></blockquote><p><code>iostat</code>常用命令：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">iostat -d -k <span class="number">1</span> <span class="number">10</span>        #查看TPS和吞吐量信息</span><br><span class="line">iostat -d -x -k <span class="number">1</span> <span class="number">10</span>      #查看设备使用率（%util）、响应时间（await）</span><br><span class="line">iostat -c <span class="number">1</span> <span class="number">10</span>            #查看cpu状态</span><br></pre></td></tr></table></figure></p><p>参数使用如下：</p><ul><li>-c ：用来获取cpu部分状态值</li><li>-x ：获得更多统计信息</li><li>-d ：显示设备（磁盘）使用状态</li><li>-k ：某些使用block为单位的列强制使用Kilobytes为单位</li></ul><h3 id="显示磁盘使用状态，每隔一秒刷新一次，共显示十次"><a href="#显示磁盘使用状态，每隔一秒刷新一次，共显示十次" class="headerlink" title="显示磁盘使用状态，每隔一秒刷新一次，共显示十次"></a><strong><font color="#DC143C">显示磁盘使用状态，每隔一秒刷新一次，共显示十次</font></strong></h3><p><img src="/images/linuxImages/iostat_d.png" alt=""></p><p>以上显示字段代表含义如下：</p><ul><li>tps：该设备每秒的传输次数</li><li>kB_read/s：每秒从设备（drive expressed）读取的数据量</li><li>kB_wrtn/s：每秒向设备（drive expressed）写入的数据量</li><li>kB_read：读取的总数据量</li><li>kB_wrtn：写入的总数量数据量</li></ul><blockquote><p>这些单位都为Kilobytes</p></blockquote><h3 id="利用iostat获取更多的统计信息"><a href="#利用iostat获取更多的统计信息" class="headerlink" title="利用iostat获取更多的统计信息"></a><strong><font color="#DC143C">利用<code>iostat</code>获取更多的统计信息</font></strong></h3><p><img src="/images/linuxImages/iostat_x.png" alt=""></p><p>获取数据代表含义如下：</p><ul><li>rrqm/s：每秒这个设备相关的读取请求有多少被Merge了（当系统调用需要读取数据的时候，VFS将请求发到各个FS，如果FS发现不同的读取请求读取的是相同Block的数据，FS会将这个请求合并Merge）<strong><font color="#DC143C">主要是虚拟文件系统与文件系统的交互过程中一个防止重复访问的机制</font></strong></li><li>wrqm/s：每秒这个设备相关的写入请求有多少被Merge了</li><li>rsec/s：每秒读取的扇区数</li><li>wsec/：每秒写入的扇区数</li><li>r/s：每秒向设备发出的读请求次数</li><li>w/s：每秒向设备发出的写请求次数</li><li>await：每一个IO请求的处理的平均时间（单位是：毫秒）<strong>这里可以理解为IO的响应时间，一般地系统IO响应时间应该低于5ms，如果大于10ms就比较大了。</strong></li><li>%util：在统计时间内所有处理IO时间，除以总共统计时间</li></ul><h3 id="查看CPU状态"><a href="#查看CPU状态" class="headerlink" title="查看CPU状态"></a><strong><font color="#DC143C">查看CPU状态</font></strong></h3><p><img src="/images/linuxImages/iostat_c.png" alt=""></p><p>获取数据代表含义如下：</p><ul><li>%user:用户程序占用CPU的百分比</li><li>%nice：进程优先级调控指令占用CPU的百分比</li><li>%system：系统进程占用CPU的百分比</li><li>%ioWait:io设备占用占用CPU的百分比</li><li>%idle：CPU空闲状态的百分比</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Linux下查看内存和CPU占用情况&quot;&gt;&lt;a href=&quot;#Linux下查看内存和CPU占用情况&quot; class=&quot;headerlink&quot; title=&quot;Linux下查看内存和CPU占用情况&quot;&gt;&lt;/a&gt;Linux下查看内存和CPU占用情况&lt;/h2&gt;&lt;h3 id=&quot;ps-将某个时间点的进程运行情况选取下来&quot;&gt;&lt;a href=&quot;#ps-将某个时间点的进程运行情况选取下来&quot; class=&quot;headerlink&quot; title=&quot;ps:将某个时间点的进程运行情况选取下来&quot;&gt;&lt;/a&gt;&lt;strong&gt;&lt;code&gt;ps&lt;/code&gt;:将某个时间点的进程运行情况选取下来&lt;/strong&gt;&lt;/h3&gt;&lt;figure class=&quot;highlight vim&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;ps&lt;/span&gt; aux  &amp;lt;== 查看系统所有进程数据&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;ps&lt;/span&gt; -lA &amp;lt;== 也是能够查看所有系统的数据&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;ps&lt;/span&gt; axjf &amp;lt;== 连同部分进程树状态&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="面试" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>C++面试问题准备：关于命令--netstat tcpdump ipcs ipcrm的使用</title>
    <link href="http://yoursite.com/2018/02/26/C-%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E5%87%86%E5%A4%87%EF%BC%9A%E5%85%B3%E4%BA%8E%E5%91%BD%E4%BB%A4-netstat-tcpdump-ipcs-ipcrm%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2018/02/26/C-面试问题准备：关于命令-netstat-tcpdump-ipcs-ipcrm的使用/</id>
    <published>2018-02-26T05:34:33.000Z</published>
    <updated>2018-02-26T08:44:45.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="网络通信命令–netstat-tcpdump"><a href="#网络通信命令–netstat-tcpdump" class="headerlink" title="网络通信命令–netstat tcpdump"></a>网络通信命令–netstat tcpdump</h2><h3 id="netstat：查看网络连接状态"><a href="#netstat：查看网络连接状态" class="headerlink" title="netstat：查看网络连接状态"></a><strong>netstat：查看网络连接状态</strong></h3><blockquote><p>如果某一个网络服务已经启动，但是就是无法进行连接，这个时候就需要查询一下网络接口所监听的端口（port），来看看是否真的已经启动，因为有的时候屏幕上显示的OK并不一定真的就是”OK”。<a id="more"></a></p></blockquote><p>关于<code>netstat</code>的参数如下：</p><ul><li>-r : <font color="#FF7F50"> 列出路由表（route table），功能与route命令相似</font></li><li>-n : 不使用主机名与服务名称，使用IP与port number，如同route -n 与网络相关的参数</li><li>-a : <font color="#FF7F50">列出所有的链接状态，包括 tcp/udp/unix socket</font></li><li>-t : 仅列出TCP数据包的连接</li><li>-u : 仅列出UDP数据包的连接</li><li>-l : <font color="#FF7F50">仅列出已在Listen（监听）状态的服务的网络状态</font></li><li>-p : 列出PID与Program的文件名</li><li>-c : 可以设置几秒钟自动更新一次，例如 -c 5 为每5秒更新一次网络状态的显示</li></ul><p><strong><font color="#DC143C">列出当前路由表的状态</font></strong></p><p><img src="/images/linuxImages/net_rn.png" alt=""></p><p>其中显示参数含义如下：</p><p><strong>Destination(目标主机)</strong> : The destination network or destination host. 目标网络或目标主机.  </p><p><strong>GateWay（网关）</strong>:The gateway address or ‘*’ if none set. 网关地址，如果没有就显示星号  </p><p><strong>Genmask（网络掩码）</strong>: The  netmask  for  the  destination net; ‘255.255.255.255’ for a host destination and ‘0.0.0.0’ for the default route.  </p><p><strong>Flags：标志位</strong>:</p><ul><li>U (route is up)：该路由是启动的；</li><li>H (target is a host)：目标是一部主机 (IP) 而非网域；    </li><li>G (use gateway)：需要透过外部的主机 (gateway) 来转递封包</li><li>R (reinstate route for dynamic routing)：使用动态路由时，恢复路由资讯的旗标；</li><li>D (dynamically installed by daemon or redirect)：已经由服务或转 port 功能设定为动态路由</li><li>M (modified from routing daemon or redirect)：路由已经被修改了；</li><li>!  (reject route)：这个路由将不会被接受(用来抵挡不安全的网域！)</li><li>A (installed by addrconf)</li></ul><p><strong>Iface 接口</strong>:Interface to which packets for this route will be sent.比如eth0,eth1等网络接口名</p><p><strong><font color="#DC143C">列出当前所有网络连接状态</font></strong></p><p><img src="/images/linuxImages/net_an.png" alt=""></p><blockquote><p>这里建议使用命令参数的时候加上”-n”，可以避免主机名与服务名称的反查，直接以IP和端口号码显示，显示的速度会更快</p></blockquote><p>其中显示的参数的意义如下：</p><p><strong>Proto</strong>: 该连接的数据包协议，主要为TCP/UDP<br><strong>Recv-Q</strong>: 由非用户程序连接所复制而来的总bytes数<br><strong>Send-Q</strong>: 由远程主机发送而来，但是不具备ACK连接的总bytes数，一般指UDP连接<br><strong>Local Address</strong>: 本地地址，可以是IP（需要-n选项存在），也可以是主机名<br><strong>Foreign Address</strong>：远程主机IP与port number<br><strong>stat:状态栏</strong>：</p><ul><li>ESTABLISHED：已建立连接的状态</li><li>SYN_SENT：发出主动连接（SYN标志）的连接数据包</li><li>SYN_RECV: 接受到一个要求连接的主动连接数据包</li><li>FIN_WAIT1: 该套接字服务（socket）已中断，该连接正在断线中</li><li>FIN_WAIT2: 该连接已挂断，但正在等待对方相应断线确认的数据包</li><li>TIME_WAIT: 该连线已挂断，但socket还在网络上等待结束</li><li>LISTEN: 指该端口等待连接请求，可以使用”-l”参数查阅</li></ul><p><strong><font color="#DC143C">查看已经启动的网络服务</font></strong></p><p><img src="/images/linuxImages/net_tulp.png" alt=""></p><blockquote><p>可以发现很多网络服务仅仅针对本机的IO开放，因特网是连接不到该端口的</p></blockquote><p><strong><font color="#DC143C">查看本机上所有的网络连接状态</font></strong></p><p><img src="/images/linuxImages/net_atunp.png" alt=""></p><blockquote><p>这里注意：只有Client端是随机开放一个大于1024的port进行连接，此外只有root可以启动小于1024的port</p></blockquote><h3 id="tcpdump-文件接口数据包捕获器"><a href="#tcpdump-文件接口数据包捕获器" class="headerlink" title="tcpdump:文件接口数据包捕获器"></a><strong>tcpdump:文件接口数据包捕获器</strong></h3><blockquote><p>tcpdump这个软件是一个可以分析数据包流向，甚至可以对数据包内容进行监听。如果双方进行数据传输的时候是明文传输，那么在Router或者hub上就有可能被别人监听走<br><strong><font color="#DC143C">tcpdump必须使用root身份执行</font></strong></p></blockquote><p>关于<code>tcpdump</code>参数如下：</p><ul><li>-A ：<font color="#FF7F50">数据包内容以ASCII显示，通常用来抓取WWW的网页数据包</font></li><li>-e : 使用数据链路层的MAC数据包来显示</li><li>-nn : <font color="#FF7F50">直接以IP和port number显示，而非主机名与服务名称　</font></li><li>-q : 仅列出较为简短的数据包信息，每一行的内容比较精简</li><li>-X : 可以列出十六进制以及ASCII的数据包内容，对于监听数据包的内容很有用</li><li>-i : <font color="#FF7F50">后面接要监听的网络接口，例如 eth0,eth1等</font></li><li>-w : <font color="#FF7F50">将监听所得的数据包数据存储下来，用这个参数，后面接文件名</font></li><li>-r : 从后面接的文件将数据包读出来。这个文件是已经存在的文件且该文件是由-w参数生成的文件</li><li>-c : 监听的数据包数，如果没有该参数，tcpdump会持续不断的监听，直到用户输入ctrl+c为止</li></ul><p><strong><font color="#DC143C">监听指定的网络接口，设置监听数据包并存储到指定文件</font></strong></p><p><img src="/images/linuxImages/tcpdump_data.png" alt=""></p><blockquote><p>可以在当前目录下查看生成了一个名为 tcpdata的文件，但是使用常用的文本查看工具打开后是乱码，所以想要查看该文件需要一下命令</p></blockquote><p><strong><font color="#DC143C">查看以-w生成的网络数据内容</font></strong></p><p><img src="/images/linuxImages/tcpdump_read.png" alt=""></p><p>关于文件内容的含义(取第一条数据包进行分析)：</p><ul><li>23:17:13.858250：这是该数据包被捕获的时间，”时：分：秒”的单位</li><li>IP：通过的通信协议是IP</li><li>172.16.70.188.41658 &gt; ：传送端是172.16.70.188这个IP，传送的port number是<strong>41658</strong>，而大于(&gt;)的符号指的是<strong>数据包传输的方向</strong></li><li>117.18.237.29.http: 接收端的IP是117.18.237.29，且该主机开启的port是http端口</li><li>[.], ack 19640744：这里是ACK相关的资料（由于本人在截屏的时候没有操作浏览器，所以没有获取太多的主动连接数据包，仅仅是保持连接数据的数据包）</li></ul><h2 id="进程通信命令–ipcs-ipcrm"><a href="#进程通信命令–ipcs-ipcrm" class="headerlink" title="进程通信命令–ipcs ipcrm"></a>进程通信命令–ipcs ipcrm</h2><h3 id="ipcs-提供进程间通信方式"><a href="#ipcs-提供进程间通信方式" class="headerlink" title="ipcs:提供进程间通信方式"></a><strong>ipcs:提供进程间通信方式</strong></h3><blockquote><p>主要是提供查看linux/unix上提供的一些进程间通信方式的信息，包括：共享内存、消息队列、信号量的状态</p></blockquote><p>关于<code>ipcs</code>的参数如下：</p><ul><li>-a:显示所有的IPC设施</li><li>-q:显示所有的消息队列Message Queue</li><li>-s:显示所有的信号量</li><li>-m:显示所有的共享内存</li><li>-p:显示最近访问过IPC设施的进程ID</li><li>-c:显示IPC设施的权限关系</li><li>-t:显示IPC设施的最后操作时间</li><li>-u:显示IPC设施的当前状态</li></ul><p><strong><font color="#DC143C">查看目前为止主机的进程通信机制的内容：</font></strong></p><p><img src="/images/linuxImages/ipcs.png" alt=""></p><p>关于显示内容的含义（主要显示的共享内存的信息，在操作系统中主要通信方式是共享内存）：</p><ul><li>key: 应用程序定义的键值，如果是私有对象，则键值为0。即我们显示的</li><li>shmid：栏中列出共享内存的ID</li><li>owner：创建共享内存的用户是vigor</li><li>perms: 该通信机制的权限：600。即只有读的权限</li><li>bytes: 这块共享内存的大小</li><li>nattch: 连接在关联的共享内存段的进程数,所显示的都是两个</li><li>status: 列出当前共享内存的状态</li></ul><p><strong><font color="#DC143C">查看共享内存中进程对应的端口号</font></strong></p><p><img src="/images/linuxImages/ipcs_id.png" alt=""></p><h3 id="ipcrm-移除某一个进程通信机制"><a href="#ipcrm-移除某一个进程通信机制" class="headerlink" title="ipcrm:移除某一个进程通信机制"></a><strong>ipcrm:移除某一个进程通信机制</strong></h3><blockquote><p>ipcrm 用来删除一个或者更多消息队列、信号量或者共享内存标识</p></blockquote><p>关于<code>ipcrm</code>的参数如下：</p><ul><li>-m SharedMemory id 删除共享内存标识 SharedMemoryID。与 SharedMemoryID 有关联的共享内存段以及数据结构都会在最后一次拆离操作后删除。</li><li>-M SharedMemoryKey 删除用关键字 SharedMemoryKey 创建的共享内存标识。与其相关的共享内存段和数据结构段都将在最后一次拆离操作后删除。</li><li>-q MessageID 删除消息队列标识 MessageID 和与其相关的消息队列和数据结构。</li><li>-Q MessageKey 删除由关键字 MessageKey 创建的消息队列标识和与其相关的消息队列和数据结构。</li><li>-s SemaphoreID 删除信号量标识 SemaphoreID 和与其相关的信号量集及数据结构。</li><li>-S SemaphoreKey 删除由关键字 SemaphoreKey 创建的信号标识和与其相关的信号量集和数据结构。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;网络通信命令–netstat-tcpdump&quot;&gt;&lt;a href=&quot;#网络通信命令–netstat-tcpdump&quot; class=&quot;headerlink&quot; title=&quot;网络通信命令–netstat tcpdump&quot;&gt;&lt;/a&gt;网络通信命令–netstat tcpdump&lt;/h2&gt;&lt;h3 id=&quot;netstat：查看网络连接状态&quot;&gt;&lt;a href=&quot;#netstat：查看网络连接状态&quot; class=&quot;headerlink&quot; title=&quot;netstat：查看网络连接状态&quot;&gt;&lt;/a&gt;&lt;strong&gt;netstat：查看网络连接状态&lt;/strong&gt;&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;如果某一个网络服务已经启动，但是就是无法进行连接，这个时候就需要查询一下网络接口所监听的端口（port），来看看是否真的已经启动，因为有的时候屏幕上显示的OK并不一定真的就是”OK”。
    
    </summary>
    
      <category term="面试" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>2018-02-25</title>
    <link href="http://yoursite.com/2018/02/25/2018-02-25/"/>
    <id>http://yoursite.com/2018/02/25/2018-02-25/</id>
    <published>2018-02-25T15:33:45.000Z</published>
    <updated>2018-02-25T15:54:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天是一个离开家的日子，真的不知道下次回到家会是什么时候！母亲很早就帮我收拾东西，虽然我的东西并不是很多，而且我已经将大部分重要的东西放进了箱子里，但是她仍然四处走动，想要为我并不是很大的箱子中装入可以装入的东西。母亲只是想要通过这种繁忙的方式来弥补我即将离开后自己内心的孤独，想到每一个离开的孩子对于父母来说都会是那么痛苦，难受！随着年龄的增长，相见本就不易，且行且珍惜。<a id="more"></a>刚打扫完宿舍，脑袋有晕！</p><p>在火车上看完永永推荐的《灵契》，看到了可能是她哇一下（哭）的场景的时候，我有点感动，原来同志之间的爱情可以是这样的陪伴来做为爱的告白！</p><blockquote><font color="#DC143C">纵使天高地阔，我想去的地方，只有一个,您的身边</font> </blockquote><p>其实呢，我倒是挺想看看她”哇一下”是什么样子的呀!</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天是一个离开家的日子，真的不知道下次回到家会是什么时候！母亲很早就帮我收拾东西，虽然我的东西并不是很多，而且我已经将大部分重要的东西放进了箱子里，但是她仍然四处走动，想要为我并不是很大的箱子中装入可以装入的东西。母亲只是想要通过这种繁忙的方式来弥补我即将离开后自己内心的孤独，想到每一个离开的孩子对于父母来说都会是那么痛苦，难受！随着年龄的增长，相见本就不易，且行且珍惜。
    
    </summary>
    
      <category term="日记" scheme="http://yoursite.com/categories/life/"/>
    
    
  </entry>
  
  <entry>
    <title>2018-02-22</title>
    <link href="http://yoursite.com/2018/02/22/2018-02-22/"/>
    <id>http://yoursite.com/2018/02/22/2018-02-22/</id>
    <published>2018-02-22T13:25:27.000Z</published>
    <updated>2018-02-25T15:40:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近她回到她爹的老家啦—昭通，這還是她22年來第一次和爸爸回到老家，真的是很難得！<br>雖然信號不是很好，但是能夠看到那裏是個很安靜的地方，山很多，綿延不絕，遠處有朦朦朧朧的霧遮擋著若隱若現的群山！這個場景讓我想起了小佛在《苗疆蠱事》中對青山界的描述，十萬里大山！   <a id="more"></a><br>然後她奮勇得爬上了其中一座山，叫做觀音岩。遙望遠處大山，長舒一口氣，她發出了一聲感慨：<font color="#DC143C"><strong>我願此生遼闊高遠！</strong></font> 嗯，我看到之後默默得點了一個讚，支持你喔！^_^希望能夠帶你看變世間群山，讓你每一次的感慨都更高更遠！</p><p>然後又看到她門那裡的特色美食，什麼百花蜂蜜、還有滿滿（姑姑）做的米酒糖水雞蛋、還有酸笋烏雞鍋。滿滿得舌尖上的中國，看得我食慾大發！</p><p><img src="/images/yongyong/honey.jpg" alt="百花蜂蜜"></p><p><img src="/images/yongyong/chicken.jpg" alt="米酒糖水鸡蛋"></p><p><img src="/images/yongyong/water.jpg" alt="酸笋乌鸡锅"></p><p>糖小可怜被姐姐妈妈欺负了，睡觉的时候从一个小球被强行拉成一个树干，哎，可怜的小家伙在被强迫睡觉，过程中醒来了三次！最后产生的结果就是腰疼～～～心疼～～～</p><p>就快要开学了，过几天就要去学校了。很开心，自从2018.1.11之后一天比一天更想她，感觉到她开心我就很开心，她难过就有点不知所措！想到马上就能见到她，我就无比激动，不过最近有一件让我无比沮丧难过的事情，我。。。我把她送我的小人给弄丢啦,fuck!平时都随身携带，最近穿的衣服兜特别浅，出去玩的时候没有注意，拿出来看完之后装进去没有装好，可能掉出来了！气死我了，还回去找了好几次，愤怒啊！好可爱的一个小人，难过死了！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近她回到她爹的老家啦—昭通，這還是她22年來第一次和爸爸回到老家，真的是很難得！&lt;br&gt;雖然信號不是很好，但是能夠看到那裏是個很安靜的地方，山很多，綿延不絕，遠處有朦朦朧朧的霧遮擋著若隱若現的群山！這個場景讓我想起了小佛在《苗疆蠱事》中對青山界的描述，十萬里大山！
    
    </summary>
    
      <category term="日记" scheme="http://yoursite.com/categories/life/"/>
    
    
  </entry>
  
  <entry>
    <title>C++面试问题准备：辨认大小端以及系统位数</title>
    <link href="http://yoursite.com/2018/02/17/C-%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E5%87%86%E5%A4%87%EF%BC%9A%E8%BE%A8%E8%AE%A4%E5%A4%A7%E5%B0%8F%E7%AB%AF%E4%BB%A5%E5%8F%8A%E7%B3%BB%E7%BB%9F%E4%BD%8D%E6%95%B0/"/>
    <id>http://yoursite.com/2018/02/17/C-面试问题准备：辨认大小端以及系统位数/</id>
    <published>2018-02-17T08:33:17.000Z</published>
    <updated>2018-02-26T05:28:07.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是大小端-big-endian和small-endian"><a href="#什么是大小端-big-endian和small-endian" class="headerlink" title="什么是大小端(big-endian和small-endian)"></a>什么是大小端(big-endian和small-endian)</h2><p>即最高有效位(most significant)在低地址位就是大端，最低有效位(least significant)在低地址就是小端。<br>大概意思就是：我们取数据a = 0x12ff，那么最高有效位指的就是数字的0x12数据，最低有效位指的是0xff。<br><a id="more"></a></p><blockquote><p>即如果数据的最高有效位的数据0x12存放在内存中的低地址，那么该计算机存储的方式就是大端存储。相反就是小端存储。</p></blockquote><h2 id="如何用程序分辨大小端"><a href="#如何用程序分辨大小端" class="headerlink" title="如何用程序分辨大小端"></a>如何用程序分辨大小端</h2><p>根据上面大小端的定义，我们可以写出如下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> num1 = <span class="number">0x12FF</span>;</span><br><span class="line"><span class="keyword">char</span> * address = (<span class="keyword">char</span> *)&amp;num1;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"low bytes is %x , high bytes is %x"</span>,*address &amp; <span class="number">0xFF</span>,  *(address + <span class="number">1</span>) &amp; <span class="number">0xFF</span> );</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line">low bytes is ff , high bytes is <span class="number">12</span></span><br></pre></td></tr></table></figure><p>即数据<code>num1 = 0x12FF</code>的最高有效位<code>0x12</code>存储在存放该数据内存地址较高的位置，该程序可以做为验证计算机系统存储数据是大端还是小端。</p><h2 id="如何分辨计算机系统是32位还是64位"><a href="#如何分辨计算机系统是32位还是64位" class="headerlink" title="如何分辨计算机系统是32位还是64位"></a>如何分辨计算机系统是32位还是64位</h2><p>在32位系统中<code>int</code> 和 <code>long int</code>是4 字节，而64位系统中则变为8字</p><p>所以在以上代码中添加如下一行程序即可查看系统位数</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">0x80000000</span>;</span><br><span class="line"><span class="keyword">printf</span>(<span class="string">"\nos is%ld\t%ld\n"</span>,a,sizeof(<span class="keyword">int</span>));</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是大小端-big-endian和small-endian&quot;&gt;&lt;a href=&quot;#什么是大小端-big-endian和small-endian&quot; class=&quot;headerlink&quot; title=&quot;什么是大小端(big-endian和small-endian)&quot;&gt;&lt;/a&gt;什么是大小端(big-endian和small-endian)&lt;/h2&gt;&lt;p&gt;即最高有效位(most significant)在低地址位就是大端，最低有效位(least significant)在低地址就是小端。&lt;br&gt;大概意思就是：我们取数据a = 0x12ff，那么最高有效位指的就是数字的0x12数据，最低有效位指的是0xff。&lt;br&gt;
    
    </summary>
    
      <category term="面试" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
      <category term="OS" scheme="http://yoursite.com/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>C++面试问题准备：i++是否原子操作，为什么</title>
    <link href="http://yoursite.com/2018/02/17/C-%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E5%87%86%E5%A4%87%EF%BC%9Ai-%E6%98%AF%E5%90%A6%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88/"/>
    <id>http://yoursite.com/2018/02/17/C-面试问题准备：i-是否原子操作，为什么/</id>
    <published>2018-02-17T06:48:38.000Z</published>
    <updated>2018-02-22T12:54:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是操作系统原子操作"><a href="#什么是操作系统原子操作" class="headerlink" title="什么是操作系统原子操作"></a>什么是操作系统原子操作</h2><p><strong>原子操作是不可分割的，在执行完毕之前不会被任何其他事物或者事件中断，分为以下两种情况：</strong></p><ul><li>在单线程中， 能够在单条指令中完成的操作都可以认为是” 原子操作”，因为中断只能发生于指令之间</li><li>在多线程中，不能被其它进程（线程）打断的操作就叫原子操作 <a id="more"></a></li></ul><h2 id="i-分为三个阶段"><a href="#i-分为三个阶段" class="headerlink" title="i++分为三个阶段"></a>i++分为三个阶段</h2><ol><li>内存到寄存器</li><li>寄存器自增</li><li>写回内存</li></ol><p>一般的编译器会将i++翻译为</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="built_in">eax</span>,  <span class="built_in">dword</span> <span class="built_in">ptr</span>[i]</span><br><span class="line"><span class="keyword">inc</span> <span class="built_in">eax</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">dword</span> <span class="built_in">ptr</span>[i], <span class="built_in">eax</span></span><br></pre></td></tr></table></figure><p>但是在没有加锁的情况下不会产生互斥，所以这样肯定不是原子操作。除非编译器能够将第一第二步操作翻译为<code>lock inc dword ptr[i]</code>，那么该锁会锁住总线，从而保证无论多核还是单核CPU都只会自增一次。</p><blockquote><p>所以针对问题<strong>i++在两个线程里边分别执行100次，能得到的最大值和最小值分别是多少？</strong>的答案便是2-200<br>当两个线程每次执行完++之后不写入内存，最后一个较小的线程将值写入内存为2；相反，当两个线程每次读入寄存器并执行完操作之后都写入内存，且线程交叉执行，最后的结果就是200</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是操作系统原子操作&quot;&gt;&lt;a href=&quot;#什么是操作系统原子操作&quot; class=&quot;headerlink&quot; title=&quot;什么是操作系统原子操作&quot;&gt;&lt;/a&gt;什么是操作系统原子操作&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;原子操作是不可分割的，在执行完毕之前不会被任何其他事物或者事件中断，分为以下两种情况：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在单线程中， 能够在单条指令中完成的操作都可以认为是” 原子操作”，因为中断只能发生于指令之间&lt;/li&gt;
&lt;li&gt;在多线程中，不能被其它进程（线程）打断的操作就叫原子操作
    
    </summary>
    
      <category term="面试" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>2018-02-16</title>
    <link href="http://yoursite.com/2018/02/16/2018-02-16/"/>
    <id>http://yoursite.com/2018/02/16/2018-02-16/</id>
    <published>2018-02-16T15:05:27.000Z</published>
    <updated>2018-02-22T13:27:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天是大年初一，昨天收到很多祝福，发送了很多祝福，哈哈 还是糖永永同学的祝福让我印象深刻:<font color="#DC143C">巴啦啦小魔仙蹦沙卡拉卡二哈跳狗年事业旺旺旺旺旺旺!</font></p><p>哈哈 我想只有她能想出这样的祝福了～ 开心的。。。<a id="more"></a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天是大年初一，昨天收到很多祝福，发送了很多祝福，哈哈 还是糖永永同学的祝福让我印象深刻:&lt;font color=&quot;#DC143C&quot;&gt;巴啦啦小魔仙蹦沙卡拉卡二哈跳狗年事业旺旺旺旺旺旺!&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;哈哈 我想只有她能想出这样的祝福了～ 开心的。。。
    
    </summary>
    
      <category term="日记" scheme="http://yoursite.com/categories/life/"/>
    
    
  </entry>
  
  <entry>
    <title>2018-02-14</title>
    <link href="http://yoursite.com/2018/02/14/2018-02-14/"/>
    <id>http://yoursite.com/2018/02/14/2018-02-14/</id>
    <published>2018-02-14T06:12:16.000Z</published>
    <updated>2018-02-22T12:54:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天是情人节，我喜欢上糖永永的第34天，我用了一周的时间搜集了她朋友圈2017年所有有意义的照片为她做了一个电子相册，前后总共改了7次，做出来一个较为满意的结果，<a href="https://pan.baidu.com/s/1bqSVwQF" target="_blank" rel="noopener">TYY</a> 百度云密码:hhuw。<a id="more"></a>在今天凌晨12：06分发给她。我能感受得到她内心的激动与翻涌，她很开心，但是又很复杂。她对自己没有信心了，上一段感情让她收到了很大的伤害，她内心纠结要不要再将自己的安全感交由另一个男生。</p><p>我看到她这个样子真的是十分心痛，感情不是一个人的事情，如果只有单方向的付出，最后一道防线崩溃后内心所受的伤害就很难愈合。她到底被伤害成什么样子了才能如此痛苦难受，面对我的小礼物，从最开始的好奇、开心、激动、内心复杂、难过。她很犹豫到底该不该接受这样的喜欢～～～因为她对自己实在没有信心！所以我就鼓励她让她先不要想着接受，先用时间了解，等感觉时机成熟再作出选择。</p><p>对于我来说我又何尝对自己有信心，但是我知道喜欢她，她很独特，在我的内心已经是独一无二了，很少有心动的感觉，所以即使没有信心，我也会努力追逐！我希望能用自己的方式让她得到她想要的，无需担心会失去的依赖感。她说她是钻石心，不怕伤害，但是伤害了就碎了！我会努力去了解她，了解她在生活点点滴滴中所拥有的个性，内心深处的向往：爱情、亲情、友情、梦想。然后用自己的方式去帮助她去让自己变得更自信，内心更快乐，而不是表现出来的快乐！</p><p>突然好想她哦～<br>假期怎么这么长！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天是情人节，我喜欢上糖永永的第34天，我用了一周的时间搜集了她朋友圈2017年所有有意义的照片为她做了一个电子相册，前后总共改了7次，做出来一个较为满意的结果，&lt;a href=&quot;https://pan.baidu.com/s/1bqSVwQF&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;TYY&lt;/a&gt; 百度云密码:hhuw。
    
    </summary>
    
      <category term="日记" scheme="http://yoursite.com/categories/life/"/>
    
    
  </entry>
  
  <entry>
    <title>markdown字体、字号、字体颜色设置</title>
    <link href="http://yoursite.com/2018/02/11/markdown%E5%AD%97%E4%BD%93%E3%80%81%E5%AD%97%E5%8F%B7%E3%80%81%E5%AD%97%E4%BD%93%E9%A2%9C%E8%89%B2%E8%AE%BE%E7%BD%AE/"/>
    <id>http://yoursite.com/2018/02/11/markdown字体、字号、字体颜色设置/</id>
    <published>2018-02-11T13:06:37.000Z</published>
    <updated>2018-02-22T12:54:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>Markdown 是一种轻量级标记语言。<a id="more"></a>创始人为約翰·格魯伯（John Gruber）。它允许人们“使用易读易写的纯文本格式编写文档，然后转换成有效的XHTML（或者HTML）文档”。这种语言吸收了很多在电子邮件中已有的纯文本标记的特性。</p><p>关于MarkDown的基础语法可以参考它的官方文档<a href="https://www.appinn.com/markdown/" target="_blank" rel="noopener">MarkDown语法说明（中文版）</a><!--more--></p><p>这里说一下在用markdown写文档的时候如何设置字体颜色，字体大小以及字体形态。</p><p>在文本中添加\<font color="#ffffff" \="">文本\，这个就可以设置自己文本的颜色，关于具体文本颜色可以参考下图</font></p><p>设置字号同样\<font size="7\">文本\，这里一般浏览器默认的字号大小是3</font></p><p>设置字体形态同样\<font face="Adobe 黑体" \="">文本\，可以在face之后添加自己想要的形态.</font></p><blockquote><p>以上三者可以相互结合添加，对markdown中的文本进行设置</p></blockquote><p><img src="/images/fontColor.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Markdown 是一种轻量级标记语言。
    
    </summary>
    
      <category term="随笔" scheme="http://yoursite.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
</feed>
