<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>那一刻 风情万种</title>
  
  <subtitle>我喜欢看你笑的样子</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-01-31T03:42:01.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Mr.张</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>C++面试问题准备：const和static关键字</title>
    <link href="http://yoursite.com/2018/01/31/C-%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E5%87%86%E5%A4%87%EF%BC%9Aconst%E5%92%8Cstatic%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <id>http://yoursite.com/2018/01/31/C-面试问题准备：const和static关键字/</id>
    <published>2018-01-31T01:51:41.000Z</published>
    <updated>2018-01-31T03:42:01.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="常量-（const）"><a href="#常量-（const）" class="headerlink" title="常量 （const）"></a>常量 （const）</h2><ul><li><p>const类型值不能被修改，这里指的是const修饰的内容不能被修改，且const修饰的常量在超出其作用域之后会被释放 <a id="more"></a></p></li><li><p>在类中：const数据成员只在某个对象生存期是常量，而类可以创建很多的对象，所以不同对象类的const数据成员是可以不同的.</p></li><li><p>在类中：const数据成员的初始化只能在类的构造函数的初始化列表中进行。因为类的对象没有被创建时，编译器是不知道const数据成员的值是什么。</p></li></ul><blockquote><p>这里针对常量指针(int *const p)、指针常量(const int * p)、指向常量的常量指针(const int * const p)之间的区别做一个描述</p></blockquote><p>阐述一个概念</p><p><strong>顶层const</strong> :表示指针本身是一个常量（我们知道指针代表的一个地址，即此时这个地址是const，不能改变）</p><p><strong>底层const</strong> :表示指针的指向是一个常量（此时我们知道指针代表的地址所指的内容是常量）</p><p>综上：</p><h4 id="const-int-p"><a href="#const-int-p" class="headerlink" title="const int* p"></a><strong>const int* p</strong></h4><p> 可以通过*来看p的修饰成分，此时<em>的右边没有限定成分，那p就是一个普通的指针。而\</em>的左边是<code>const int</code>，那么此时p的指向是一个常量，此时的const 是底层const.可以不用初始化</p><p> 同时我们可以通过改变其地址来改变其所指的内容，但是不能直接更改其所指的内容。</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt; </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> d = <span class="number">200</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>* p = &amp;i;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *p &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">p = &amp;d; <span class="comment">//只能通过修改p的指向来更改p的内容</span></span><br><span class="line">*p = d;<span class="comment">//error!read-only variable is not assignable</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *p &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line"><span class="number">100</span></span><br><span class="line"><span class="number">200</span></span><br></pre></td></tr></table></figure><h4 id="int-const-p"><a href="#int-const-p" class="headerlink" title="int* const p"></a><strong>int* const p</strong></h4><p>此时*号的左边是const,那么说明该指针p是一个常量指针，即p的指向的地址是不能变的，但是我们可以更改其地址的内容。此时const是顶层const,而顶层 const必须初始化（总不可能让常量指针变量存储的是一个空内容）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> d = <span class="number">200</span>;</span><br><span class="line"><span class="keyword">int</span>* <span class="keyword">const</span> p = &amp;i;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *p &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">*p = d;<span class="comment">//直接更改其指向地址的内容</span></span><br><span class="line"><span class="comment">// p = &amp;d;//不能更改其指向的地址 ERROR:ariable 'p' declared const here</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *p &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">output :</span><br><span class="line"><span class="number">100</span></span><br><span class="line"><span class="number">200</span></span><br></pre></td></tr></table></figure><h4 id="const-int-const-p"><a href="#const-int-const-p" class="headerlink" title="const int* const p"></a><strong>const int* const p</strong></h4><p>*左边和右边都有const ,那么这个常量指针指向的是一个常量，所以语法是前两者的结合，显然地址和值都无法更改，真正做到了常量！</p><h2 id="静态变量-static"><a href="#静态变量-static" class="headerlink" title="静态变量(static)"></a>静态变量(static)</h2><ul><li><p>在类中：static变量是属于类的，不属于某个对象，它在整个程序的运行过程中只有一个副本，因此不能在定义对象时 对变量进行初始化，就是不能用构造函数进行初始化。初始化时在类外：数据类型 类名::静态数据成员名=值；static 成员函数作为类作用域的全局函数，不能访问类的非静态成员，没有this指针，不能被声明为virtual</p></li><li><p>全局静态变量：作用域内的所有函数都可以调用，一般可以用来做多线程程序的控制。</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> i  = <span class="number">100</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    i ++;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">output :</span><br><span class="line"><span class="number">100</span></span><br><span class="line"><span class="number">101</span></span><br></pre></td></tr></table></figure><ul><li>局部静态变量：同样该变量的内存在编译时只被分配一次，到整个程序结束的时候释放</li></ul><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line">using namespace std<span class="comment">;</span></span><br><span class="line"><span class="built_in">int</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">int</span> i  = <span class="number">100</span><span class="comment">;</span></span><br><span class="line">    i ++<span class="comment">;</span></span><br><span class="line">    <span class="keyword">return</span> i<span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">int</span> main ()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> a = <span class="function"><span class="keyword">func</span><span class="params">()</span>;</span></span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl<span class="comment">;</span></span><br><span class="line">    a = <span class="function"><span class="keyword">func</span><span class="params">()</span>;</span></span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl<span class="comment">;</span></span><br><span class="line">    a = <span class="function"><span class="keyword">func</span><span class="params">()</span>;</span></span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl<span class="comment">;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span><span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line">output :</span><br><span class="line"><span class="number">101</span></span><br><span class="line"><span class="number">102</span></span><br><span class="line"><span class="number">103</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;常量-（const）&quot;&gt;&lt;a href=&quot;#常量-（const）&quot; class=&quot;headerlink&quot; title=&quot;常量 （const）&quot;&gt;&lt;/a&gt;常量 （const）&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;const类型值不能被修改，这里指的是const修饰的内容不能被修改，且const修饰的常量在超出其作用域之后会被释放
    
    </summary>
    
      <category term="面试" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++ 面试问题准备：内存分配的方式</title>
    <link href="http://yoursite.com/2018/01/30/C-%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E5%87%86%E5%A4%87%EF%BC%9A%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%9A%84%E6%96%B9%E5%BC%8F/"/>
    <id>http://yoursite.com/2018/01/30/C-面试问题准备：内存分配的方式/</id>
    <published>2018-01-30T12:16:57.000Z</published>
    <updated>2018-01-30T13:36:01.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="C-中常见内存分配及其存储区域有以下几种"><a href="#C-中常见内存分配及其存储区域有以下几种" class="headerlink" title="C++ 中常见内存分配及其存储区域有以下几种"></a>C++ 中常见内存分配及其存储区域有以下几种</h3><ul><li>堆分配</li><li>栈分配</li><li>自由存储区</li><li>静态存储区</li><li>常量存储区<a id="more"></a></li></ul><p>这里首先描述以下除了堆和栈的三种存储方式：</p><h4 id="自由存储区"><a href="#自由存储区" class="headerlink" title="自由存储区"></a>自由存储区</h4><p>这个存储区是单独为C++ 中<code>new</code>运算符提出来的，该存储区是<code>new</code>和<code>delete</code>动态分配和释放对象的抽象概念。在《STL 源码剖析中》自由存储区是利用allocate空间配置器进行STL操作对象的空间分配，通过allocate ,deallocate,construct,destroy进行空间的分配和释放。详细可以参考文章<a href="http://vigortyy.com/2018/01/27/C-开发面试准备：STL-allocator/" target="_blank" rel="noopener">STL allocator</a></p><blockquote><p>别将自由存储区与堆分配等价，堆是由操作系统进行维护的一片内存区域</p></blockquote><h4 id="静态存储区"><a href="#静态存储区" class="headerlink" title="静态存储区"></a>静态存储区</h4><p>全局变量和静态变量的存储是放在同一块区域，初始化的静态变量和全局变量在一块，未初始化的在另一块，程序运行结束后由系统自动释放。</p><h4 id="常量存储区"><a href="#常量存储区" class="headerlink" title="常量存储区"></a>常量存储区</h4><p>这是一块比较特殊的存储区，是固化在执行文件上的数据，里面存放的是常量，不允许被修改。</p><p><strong>接下来我们看看堆和栈的区别</strong></p><ol><li><p>内存分配：</p><p> 堆：一般由程序员分配释放，若程序员不释放，程序结束后会由操作系统进行释放（这里主要是指局部变量使用堆分配的方式）。它的分配方式类似与链表，常用的关键字是：malloc,free</p><p> 栈：由系统自动飞配，结束后系统自动释放（局部变量）</p></li><li><p>申请方式：</p><p> 堆：需要程序员自己申请，并指明大小。</p><p> 栈：系统自动分配</p></li><li><p>大小限制：</p><p> 堆：是向高地址扩展的数据结构，是不连续的内存区域。这是由于系统是用链表来存储的空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大</p><p> 栈：在Windows下, 栈是向低地址扩展的数据结构，是一块连续的内存的区域。栈的大小是固定的（是一个编译时就确定的常数），如果申请的空间超过栈的剩余空间时，将提示overflow。因此，能从栈获得的空间较小。</p></li><li><p>效率方面：</p><p> 堆：分配空间需要使用malloc以及用free释放，这个过程需要调用操作系统的函数，由操作系统通过一定的内存分配算法分配空间，最后才由汇编器翻译为指令执行，效率较低。但是会造成大量的内存碎片，如果不合理进行释放，会导致系统运行缓慢甚至崩溃</p><p> 栈：栈是机器系统的数据结构，由与在操作系统中有栈操作的指令，所以执行起来较快。</p></li><li><p>存放内容方面：</p><p> 堆：一般情况堆顶使用一个字节的空间来存放堆的大小，而堆中具体存放内容是由程序员来完成的</p><p> 栈：栈存放的内容，一般来说是函数地址和相关参数。</p><blockquote><p>这里关于在栈中，函数调用过程栈帧的变化大家可以参考这篇文章<a href="http://blog.csdn.net/qq_29403077/article/details/53205010" target="_blank" rel="noopener">函数调用过程栈帧变化详解</a>.<strong>总之就是将控制进行跳转，同时对于控制中用到的变量以及函数地址分配相应的栈空间。</strong></p></blockquote></li></ol><p>这里是一些外国人的博客对于堆栈的描述</p><p><a href="http://www.learncpp.com/cpp-tutorial/79-the-stack-and-the-heap/" target="_blank" rel="noopener">The stack and the heap</a></p><p><a href="https://salilkapur.wordpress.com/2013/04/11/stack-memory-vs-heap-memory-in-cc/" target="_blank" rel="noopener">STACK MEMORY VS HEAP MEMORY IN C/C++</a></p><p>个人感觉写的比较浅，当然常用到的主要区别都写到了</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;C-中常见内存分配及其存储区域有以下几种&quot;&gt;&lt;a href=&quot;#C-中常见内存分配及其存储区域有以下几种&quot; class=&quot;headerlink&quot; title=&quot;C++ 中常见内存分配及其存储区域有以下几种&quot;&gt;&lt;/a&gt;C++ 中常见内存分配及其存储区域有以下几种&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;堆分配&lt;/li&gt;
&lt;li&gt;栈分配&lt;/li&gt;
&lt;li&gt;自由存储区&lt;/li&gt;
&lt;li&gt;静态存储区&lt;/li&gt;
&lt;li&gt;常量存储区
    
    </summary>
    
      <category term="面试" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>2018-01-29</title>
    <link href="http://yoursite.com/2018/01/29/2018-01-29/"/>
    <id>http://yoursite.com/2018/01/29/2018-01-29/</id>
    <published>2018-01-29T12:14:13.000Z</published>
    <updated>2018-01-29T12:28:59.000Z</updated>
    
    <content type="html"><![CDATA[<p>天哪，这也太难了吧！—-为我的脑细胞默哀30秒<a id="more"></a></p><p>今天早上看了一早上的LSTM，对RNN结构终于有了点了解了（该模型也就是对序列化数据进行训练，训练过程是根据上一个的状态来对下一个状态产生影响，通过一系列的状态训练，得到它们结果的相关性，但是普通的RNN模型因为梯度爆炸（descent exploding）无法预测非上下文相关的数据，所以LSTM就出来啦），但是在看莫烦写代码的时候我就很痛苦，虽然是按照RNN模型的三个层来写的，但是就是看不懂中间的状态层的处理。看视频教程睡着了好几次，醒来继续看，然后又睡着了。这还没有上升到内部实现和程序设计上，现在还仅仅是平台应用都这么困难，以后可咋办呀！</p><p>下午又看了一下午的STL源码剖析，说实话，有点体会到了C++的复杂，泛型编程想要掌握真心不容易，模版机制用得也不是很熟练，看代码看得云里雾里。有一些地方侯捷老师讲得是真详细，而且看到了STL的实现代码真得已经上升到了艺术境界，不论是鲁棒性，安全性，可读性（这个是我的原因读不懂，就不说了）真心没得说。难是难了，但是不能就这么放弃，前辈们绞尽脑汁为我们创造的便利不能这么丢掉，一定要一点一点啃下来，到时候相信自己对C++整个语言以及编程思维都会有一个质的提升。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;天哪，这也太难了吧！—-为我的脑细胞默哀30秒
    
    </summary>
    
      <category term="日记" scheme="http://yoursite.com/categories/life/"/>
    
    
  </entry>
  
  <entry>
    <title>东方月初：你的梦想我帮你承担</title>
    <link href="http://yoursite.com/2018/01/28/%E4%B8%9C%E6%96%B9%E6%9C%88%E5%88%9D%EF%BC%9A%E4%BD%A0%E7%9A%84%E6%A2%A6%E6%83%B3%E6%88%91%E5%B8%AE%E4%BD%A0%E6%89%BF%E6%8B%85/"/>
    <id>http://yoursite.com/2018/01/28/东方月初：你的梦想我帮你承担/</id>
    <published>2018-01-28T04:16:20.000Z</published>
    <updated>2018-01-28T06:32:44.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="那一刻，你的背影如此高大"><a href="#那一刻，你的背影如此高大" class="headerlink" title="那一刻，你的背影如此高大"></a>那一刻，你的背影如此高大</h2><p><img src="/images/yongyong/beiying1.png" alt=""></p><p>我叫东方月初，是东方灵族的人， <a id="more"></a>因为我们血脉的原因导致我们家族的嫡系永远被人争抢，只为我们天生灵力且身怀灭妖神火。</p><p>而我很小的时候因为家族被灭成为了孤儿，整日在人类的贪婪之间东躲西藏。直到那天遇见了你。。。。。我被一气道盟追杀到了涂山，当时我身受重伤，我也道涂山是狐妖的地盘，是不允许人类踏足。我心怀忐忑，实在没法逃脱这些混蛋的追捕，只能选择到这里了。</p><p>在即将被他们抓走的那一刻，一个背影从我头上飘过，优雅、安静、那么高大。霎那间，整个世界都安静了，眼睛里只有你的背影。</p><h2 id="那一刻，我的眼泪里融化进了心里"><a href="#那一刻，我的眼泪里融化进了心里" class="headerlink" title="那一刻，我的眼泪里融化进了心里"></a>那一刻，我的眼泪里融化进了心里</h2><p><img src="/images/yongyong/liulei.png" alt=""></p><p>之后我死皮赖脸待在涂山，也很感谢你愿意收留我，原来你是涂山的妖王涂山红红，很开心认识了涂山的其他伙伴，还有雅雅姐和容容姐。结果没多长时间，一气道盟的人又来涂山，其中还有名震天下的金面火神，还是为了我的血脉。金面火神这个混蛋为了得到东方神脉，杀掉了他的师父也就是我们族长，自称正道，在人间混迹，道貌岸然的家伙！</p><p>经历了一番大战，你看到了他们对我血脉的渴望。他们甚至为了得到我要灭掉涂山，而你不仅没有将我交出去，还为了保护我做了一出戏：”从此世间再无，东方月初”。我是一个孤儿，母亲有限的爱早已随时间忘却，所以我从来没有体会过有人这样对我好，从来没有体会过那种被人无私保护的感觉。那一刻，我的眼泪融化进了心里，我爱上了你！</p><h2 id="那一刻，我的离开只为你的梦想"><a href="#那一刻，我的离开只为你的梦想" class="headerlink" title="那一刻，我的离开只为你的梦想"></a>那一刻，我的离开只为你的梦想</h2><p><img src="/images/yongyong/likai.png" alt=""></p><p>因为你的保护将东方月初从天下抹去，从此我可以在涂山快乐的生活了。想起来，那段时光应该是我一生中最为快乐的呢。当然我给自己定了一个小目标，哈哈，我要追你，反正就是喜欢你，不管在哪里都会想到你呢。所以用自己的方式想尽一切办法来让你开心，当然也是为了报答那份恩情。知道你怕灭妖神火，我用自己稀释了的血让你洗手，三个月后你终于不用担心纯质阳炎对你的伤害啦。</p><p>那一天情人节，我想给你一个惊喜，我要让你看到涂山最美的场景。让整个涂山的花都为你盛开，想到你看到这个场景的时候肯定被我感动得涕泗横流就很开心啊。直到我听到了你的对那个已经死去的人类的肺腑之言，后来也知道了你是给我说的。你因为对人类的偏见误杀了一个善良的人类，那种愧疚封闭了你的内心，你选择用自己的一生去实现一个理想：让人和妖在这个世界和平相处！而你也告诉了我，你在实现这个理想期间不会向任何人再展现自己内心的柔软。</p><p>听到这段话沉默了很久，我内心有点失落，可是我不愿意看到你因为愧疚，因为那份恩情就把自己画一个圈圈了起来，既然你不愿意跳出来，那我陪你一起钻进去。所以我选择离开，只有站在人类世界权利的最高峰我才能够有足够大的话语权，才能更好得帮助你，那么先从一气道盟开始吧！</p><p><img src="/images/yongyong/yongyuan.png" alt=""></p><h2 id="那一刻，我笑了"><a href="#那一刻，我笑了" class="headerlink" title="那一刻，我笑了"></a>那一刻，我笑了</h2><p><img src="/images/yongyong/xiangsishu.png" alt=""></p><p>从此我们陷入世俗的漩涡，但我知道我们都为了同一个梦想时时刻刻在努力。所以我们最后在别人眼里的自相残杀，其实只是更好得掩盖我们最后的目的。时光流逝，我希望用自己的方式打开你内心的那个心结，没有什么理由，没有什么目的，只是想看到你发自心底的笑。终于，我用自己顽强的意志与不懈的努力走进了你的内心，看到了你内心融化，我笑了，很开心。相思树下我们用虚空之泪做为转世续缘的定情信物，那个洁白流光如皓月般明亮的水珠将成为我们一生的回忆。</p><p><strong>相思树下，我们来世再见！</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;那一刻，你的背影如此高大&quot;&gt;&lt;a href=&quot;#那一刻，你的背影如此高大&quot; class=&quot;headerlink&quot; title=&quot;那一刻，你的背影如此高大&quot;&gt;&lt;/a&gt;那一刻，你的背影如此高大&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/images/yongyong/beiying1.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;我叫东方月初，是东方灵族的人，
    
    </summary>
    
      <category term="随笔" scheme="http://yoursite.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
  <entry>
    <title>C++面试问题准备：STL--allocator</title>
    <link href="http://yoursite.com/2018/01/27/C-%E5%BC%80%E5%8F%91%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87%EF%BC%9ASTL-allocator/"/>
    <id>http://yoursite.com/2018/01/27/C-开发面试准备：STL-allocator/</id>
    <published>2018-01-27T15:02:40.000Z</published>
    <updated>2018-01-31T01:50:24.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>最近在读侯捷老师的《STL源码剖析》，写写总结。他的STL主要是SGI 版本的，也就是我们常用的GCC编译器支持 <a id="more"></a></p></blockquote><h4 id="什么是allocator"><a href="#什么是allocator" class="headerlink" title="什么是allocator"></a>什么是allocator</h4><p>相信对C++感兴趣的伙伴肯定对STL这个模版库情有独钟，但是当站在STL的角度来看这些容器的实现那么第一个需要知道的就是allocator</p><p>allocator是空间适配器，即为STL容器产生的各种对象（所有的数值）分配存储空间的接口。</p><p>注意这里的存储空间指的并不一定是内存，还可以有硬盘哦！当然本章主要介绍的是allocator为STL配置内存空间。如果大家对allocator获取硬盘空间的方式感兴趣的话可以浏览该源码<a href="http://www.drdobbs.com/disk-based-container-objects/" target="_blank" rel="noopener">Disk-Based Container Objects</a>(这里需要翻墙，我是真没看懂，基础有点差)</p><h4 id="allocator-如何分配空间"><a href="#allocator-如何分配空间" class="headerlink" title="allocator 如何分配空间"></a>allocator 如何分配空间</h4><p>关于allocator 在STL中的规范接口大家可以参考文档<a href="http://zh.cppreference.com/w/cpp/memory/allocator" target="_blank" rel="noopener">allocator</a></p><p>其中SGI的默认allocator的源码可以参考<a href="https://afsws.rpi.edu/dept/acm/packages2/egcs/1.1.2/common/include/g++/defalloc.h" target="_blank" rel="noopener">defalloc.h</a></p><p>其中关于内存分配以及释放的源码如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">T</span>* <span class="title">allocate</span>(<span class="title">ptrdiff_t</span> <span class="title">size</span>, <span class="title">T</span>*) &#123;</span></span><br><span class="line">    set_new_handler(<span class="number">0</span>);</span><br><span class="line">    T* tmp = (T*)(::<span class="keyword">operator</span> <span class="keyword">new</span>((<span class="keyword">size_t</span>)(size * <span class="keyword">sizeof</span>(T)))); <span class="comment">//由全局操作符::operator new分配指定类型T大小的内存</span></span><br><span class="line">    <span class="keyword">if</span> (tmp == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">cerr</span> &lt;&lt; <span class="string">"out of memory"</span> &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">deallocate</span>(<span class="title">T</span>* <span class="title">buffer</span>) &#123;</span></span><br><span class="line">    ::<span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(buffer)</span></span>; <span class="comment">//由全局操作符::operator delete来释放类T的对象的内存</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们根据自己平时代码习惯，对内存的分配以及释放是以下的方式：<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class <span class="type">Foo</span><span class="meta">&#123;...&#125;</span></span><br><span class="line"><span class="type">Foo</span>* a = new <span class="type">Foo</span>;</span><br><span class="line">delete a;</span><br></pre></td></tr></table></figure></p><p>底层的new 分配方式是</p><ol><li>调用::operator new 配置内存</li><li>调用Foo::Foo()构造对象内容</li></ol><p>底层的delete分配方式是</p><ol><li>调用Foo::~Foo() 析构对象</li><li>调用::operator delete 释放内存</li></ol><blockquote><p>说到new ,简单说一下C++中new 和 malloc的区别<br><br><strong>1.new是C++的一种内存分配的关键字，malloc是C语言特有的内存非配函数，也可以为C++使用</strong><br><br><strong>2.new分配内存的大小由编译器来指定，即SGI 的GCC指定，开发者不需要考虑分配的大小计算。而malloc则需要显示计算大小</strong><br><br><strong>3.new会先调用operator new函数，申请足够的内存（通常底层使用malloc实现）。然后调用类型的构造函数，初始化成员变量，最后返回自定义类型指针。delete先调用析构函数，然后调用operator delete函数释放内存（通常底层使用free实现）</strong><br><br><strong>4.new 分配失败会返回bac_alloc异常，可由以上源码看出。而malloc分配失败会返回NULL</strong><br><br><strong>5.new可以被重载，malloc不允许</strong><br><br><strong>6.new分配的内存在自由存储区上，malloc分配的空间是在堆上，而堆是操作系统维护的一块特殊内存。</strong></p></blockquote><p>在SGI STL中默认的allocator，但是因为封装过于简单，没有考虑效率的强化，因为之后会说道trivial destructor(保证析构时候是执行释放内存的操作，而非无关痛痒的析构)，所以一般SGI会将以上的两个操作分开。</p><p>为了实现这个功能，STL标准规范 将以上总共四个操作分别封装在<code>alloc::allocate()</code>执行内存分配，<code>alloc::deallocate()</code> 执行内存释放，<code>::construct()</code>执行对象构造，<code>::destroy()</code>执行对象析构。</p><p>以上四个函数分别在以下两个文件：</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stl_alloc.h&gt;</span> //负责空间的分配和释放</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stl_construt.h&gt;</span> //负责对象的构造和析构，construc 和destroy是全局函数，所以调用的时候用::construct()</span></span><br></pre></td></tr></table></figure><h5 id="关于构造与析构的过程"><a href="#关于构造与析构的过程" class="headerlink" title="关于构造与析构的过程"></a>关于构造与析构的过程</h5><p>关于<a href="http://gcc.gnu.org/onlinedocs/gcc-4.9.0/libstdc++/api/a01502_source.html" target="_blank" rel="noopener">stl_construct.h的源码</a></p><p>在<code>&lt;stl_construct.h&gt;</code>中的构造的过程如下 </p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;new.h&gt;</span></span></span><br><span class="line"><span class="keyword">template</span> &lt;class T1,class T2&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> construct(T1 *p,<span class="keyword">const</span> T2&amp; value) &#123;</span><br><span class="line">    <span class="keyword">new</span> (p) T1(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重点是进行对象析构的操作</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对单指针对象进行析构</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="title">void_Destroy</span><span class="params">(_Tp* __pointer)</span></span>&#123;</span><br><span class="line">    __pointer-&gt;~_Tp(); &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//对两个指针进行析构，即参数接受两个迭代器，此时我们需要判断迭代器之间元素的数值型别，即是否执行有意义的析构，即释放会释放内存</span></span><br><span class="line"><span class="comment">//主要析构函数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">ForwardIterator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">destroy</span>(<span class="title">ForwardIterator</span> <span class="title">first</span>,<span class="title">ForwardIterator</span> <span class="title">last</span>) &#123;</span></span><br><span class="line">    _destroy(first,last,value_type(first))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断元素的数值型别 注意，这里的has_trivial_destructor可以对析构函数的执行是否有意义进行判断，采取不同的执行方式来提升析构效率</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">ForwardIterator</span>,<span class="title">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> _<span class="title">destroy</span>(<span class="title">ForwardIterator</span> <span class="title">first</span>,<span class="title">ForwardIterator</span> <span class="title">last</span>,<span class="title">T</span>*) &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> _type_traits&lt;T&gt;::has_trivial_destructor trivial_destructor;</span><br><span class="line">    _destroy_aux(first,last,trivial_destructor);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果元素的数值型别有non-trivial destructor</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">ForwardIterator</span>&gt;</span></span><br><span class="line"><span class="class">_<span class="title">destroy_aux</span>(<span class="title">ForwardIterator</span> <span class="title">first</span>,<span class="title">ForwardIterator</span> <span class="title">last</span>,_<span class="title">false_type</span>) &#123;</span> </span><br><span class="line">    <span class="keyword">for</span> (; first &lt; last; ++first)</span><br><span class="line">        destroy(&amp;*first); <span class="comment">//调用一个指针的析构函数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果元素的数值型别有trivial destructor （即此时执行的该对象的析构函数是无意义的，不释放任何内存）</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">ForwardIterator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> _<span class="title">destroy_aux</span>(<span class="title">ForwardIterator</span>,<span class="title">ForwardIterator</span>,_<span class="title">true_type</span>)&#123;</span>&#125; <span class="comment">//该函数什么也不做，不执行析构操作</span></span><br></pre></td></tr></table></figure><p>综上我们就很容易看出SGI STL的开发者们是真生得站在系统效率的角度上进行的开发，一切只为了安全快捷。</p><blockquote><p>大量的inline函数使得我们系统执行的效率更快，在函数体运行的时候inline函数会在函数体内展开，而不需要在去由编译器去保存函数内容以及实参到内存，从而降低系统效率。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;最近在读侯捷老师的《STL源码剖析》，写写总结。他的STL主要是SGI 版本的，也就是我们常用的GCC编译器支持
    
    </summary>
    
      <category term="面试" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++开发面试问题</title>
    <link href="http://yoursite.com/2018/01/26/C-%E5%BC%80%E5%8F%91%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2018/01/26/C-开发面试问题/</id>
    <published>2018-01-26T14:47:27.000Z</published>
    <updated>2018-01-30T12:17:30.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="语言基础"><a href="#语言基础" class="headerlink" title="语言基础"></a>语言基础</h4><ul><li>OOP（封装、继承、多态） + V func 的实现，V table 的原理</li><li>const static的各种情况，分清const pointer 和pointer to const以及两者合体的形式<a id="more"></a></li><li>内存泄漏 三条规则。注意exception safe和smart pointer（提到思想：谁拥有这个指针）的解决方式</li><li>STL 至少了解allocator，常用的一些容器以及其实现原理</li><li>rail 了解一下，用来做什么</li></ul><h4 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h4><ul><li>进程管理 <ol><li>什么是进程</li><li>什么是context switch（上下文相关），干什么会触发它</li><li>cost是什么</li><li>虚拟内存和物理内存是什么</li><li>进程竞争的条件</li></ol></li><li>文件系统<ol><li>MVC 了解</li><li>堆栈的区别，给一个程序，要能够画出内存里程序运行的经过</li><li>并发编程，了解.管道的概念</li><li>cpu cache的运作，为什么很多数据结构或算法很好，运行却很慢</li><li>动态链接和静态链接的优缺点</li><li>编译的过程，从complie到linking. 做的事情</li><li>如何避免环形依赖</li></ol></li></ul><h4 id="编程习惯"><a href="#编程习惯" class="headerlink" title="编程习惯"></a>编程习惯</h4><ul><li>敏捷开发要了解，至少知道过程中有那些阶段code review,以及测试流程</li><li>如何manage大型C++code,怎么分模块合理得继承，怎么分模块测试</li><li>template以及metaprogramming了解</li><li>现场写程序能加const就加const,小程序全inline,能传ref就传ref,开头一定要有哨兵#ifndef #define #endif</li><li>出手要有namespace</li><li>STL能用就用，tranform的使用以及自己会写comparator</li></ul><h4 id="基础数据结构以及算法—-《剑指-offer》《编程之美》《程序员面试指南》内容搞懂足够面对BAT"><a href="#基础数据结构以及算法—-《剑指-offer》《编程之美》《程序员面试指南》内容搞懂足够面对BAT" class="headerlink" title="基础数据结构以及算法—-《剑指 offer》《编程之美》《程序员面试指南》内容搞懂足够面对BAT"></a>基础数据结构以及算法—-《剑指 offer》《编程之美》《程序员面试指南》内容搞懂足够面对BAT</h4>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;语言基础&quot;&gt;&lt;a href=&quot;#语言基础&quot; class=&quot;headerlink&quot; title=&quot;语言基础&quot;&gt;&lt;/a&gt;语言基础&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;OOP（封装、继承、多态） + V func 的实现，V table 的原理&lt;/li&gt;
&lt;li&gt;const static的各种情况，分清const pointer 和pointer to const以及两者合体的形式
    
    </summary>
    
      <category term="面试" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Python爬虫 爬取批量图片</title>
    <link href="http://yoursite.com/2018/01/26/Python%E7%88%AC%E8%99%AB-%E7%88%AC%E5%8F%96%E6%89%B9%E9%87%8F%E5%9B%BE%E7%89%87/"/>
    <id>http://yoursite.com/2018/01/26/Python爬虫-爬取批量图片/</id>
    <published>2018-01-26T10:40:37.000Z</published>
    <updated>2018-01-26T12:07:09.000Z</updated>
    
    <content type="html"><![CDATA[<p>本部分的主要代码在<br><a href="https://github.com/BaronStack/Python-Reptitle/tree/master/reptitle_trying" target="_blank" rel="noopener">爬取批量图片到本地</a></p><h4 id="如何用python-爬取图片网站的图片"><a href="#如何用python-爬取图片网站的图片" class="headerlink" title="如何用python 爬取图片网站的图片"></a>如何用python 爬取图片网站的图片</h4><blockquote><p>这里的图片是按页显示的，所以它爬取的是每一页的图片</p></blockquote><ul><li>获取网页链接</li><li>利用正则提取以页为单位的html内容</li><li>获取每一页中图片的存储链接</li><li>利用循环下载保存<a id="more"></a></li></ul><p>导入的包如下：<br><figure class="highlight capnproto"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup <span class="comment"># 方便提取标签中的内容</span></span><br><span class="line"><span class="keyword">import</span> requests <span class="comment"># 向网页发送请求的包，获取网页内容</span></span><br><span class="line"><span class="keyword">import</span> re <span class="comment"># 正则表达式的包</span></span><br><span class="line"><span class="keyword">from</span> urllib.request <span class="keyword">import</span> urlopen <span class="comment"># 也是用来获取网页内容</span></span><br><span class="line"><span class="keyword">import</span> os <span class="comment"># 文件目录操作</span></span><br></pre></td></tr></table></figure></p><h5 id="获取网页链接，利用正则提取以页为单位的html链接"><a href="#获取网页链接，利用正则提取以页为单位的html链接" class="headerlink" title="获取网页链接，利用正则提取以页为单位的html链接"></a>获取网页链接，利用正则提取以页为单位的html链接</h5><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这里也可以用语句 html = requests.get("http://www.ivsky.com/tupian/xuejing_t36/index_2.html").text来获取网页内容</span></span><br><span class="line"><span class="attr">html</span> = urlopen(<span class="string">"http://www.ivsky.com/tupian/xuejing_t36/index_2.html"</span>).read().decode(<span class="string">'utf-8'</span>) </span><br><span class="line"><span class="comment">#利用BeautifulSoup对html进行解析，从而可以获取网页的节点属性</span></span><br><span class="line"><span class="attr">soup</span> = BeautifulSoup(html, features=<span class="string">'lxml'</span>)</span><br><span class="line"><span class="comment">#找到以'panelist'为class的div标签的内容（这里存储的不同页面的html链接）</span></span><br><span class="line"><span class="attr">img_links</span> = soup.find_all(<span class="string">"div"</span>, &#123;<span class="string">"class"</span>: <span class="string">'pagelist'</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">#利用正则表达式，将标签中的链接取出来，形成列表。这里可以打开链接</span></span><br><span class="line"><span class="attr">course_links</span> = soup.find_all(<span class="string">'a'</span>, &#123;<span class="string">'href'</span>: re.compile(<span class="string">'/tupian/.*index_.\.html$'</span>)&#125;)</span><br><span class="line"><span class="comment">#这里的链接是没有http://跳转的，所以给其中每个链接都加上这样的跳转</span></span><br><span class="line"><span class="attr">resultURL</span> = [<span class="string">"%s%s"</span> %(<span class="string">'http://www.ivsky.com'</span>,links[<span class="string">'href'</span>]) for links in course_links]</span><br></pre></td></tr></table></figure><h5 id="获取每一页中图片的存储链接"><a href="#获取每一页中图片的存储链接" class="headerlink" title="获取每一页中图片的存储链接"></a>获取每一页中图片的存储链接</h5><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#取得当前页面的URL</span><br><span class="line"><span class="selector-tag">html</span> = requests.get(URL).text</span><br><span class="line">#解析</span><br><span class="line">soup = BeautifulSoup(<span class="selector-tag">html</span>, <span class="string">'lxml'</span>)</span><br><span class="line">#找到以il_img为class的div标签</span><br><span class="line">img_ul = soup.find_all(<span class="string">'div'</span>, &#123;<span class="string">'class'</span>: <span class="string">"il_img"</span>&#125;)</span><br><span class="line">#查看找到的区域数量</span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(len(img_ul)</span></span>)</span><br></pre></td></tr></table></figure><p>这里在利用浏览器的检查元素进行查找，在找的过程中尽可能将当前页面图片进行归类分析，找出其共有的标签属性，方便将所有的图片进行爬取</p><h5 id="利用循环下载保存"><a href="#利用循环下载保存" class="headerlink" title="利用循环下载保存"></a>利用循环下载保存</h5><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">os.makedirs(<span class="string">'./img/'</span>, exist_ok=True)<span class="comment">#创建保存的文件夹及存储目录，可以自行更改</span></span><br><span class="line">    <span class="keyword">for</span> ul <span class="keyword">in</span> img_ul:</span><br><span class="line">        imgs = ul.find_all(<span class="string">'img'</span>)<span class="comment">#找到 img标签</span></span><br><span class="line">        <span class="keyword">for</span> img <span class="keyword">in</span> imgs:</span><br><span class="line">            url = img[<span class="string">'src'</span>] <span class="comment">#找到src标签，因为其后跟着图片链接</span></span><br><span class="line">            r = requests.<span class="built_in">get</span>(url, stream=True)</span><br><span class="line">            image_name = url.<span class="built_in">split</span>(<span class="string">'/'</span>)[<span class="number">-1</span>] <span class="comment">#图片以最后一个'／'右边的内容明名，也可以自行命名</span></span><br><span class="line">            <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">'./img/%s'</span> % image_name, <span class="string">'wb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">                <span class="keyword">for</span> chunk <span class="keyword">in</span> r.iter_content(chunk_size=<span class="number">128</span>): <span class="comment">#将图片分块以数据流的方式直接写入到本地</span></span><br><span class="line">                    f.<span class="built_in">write</span>(chunk)</span><br><span class="line">            print(<span class="string">'Saved %s'</span> % image_name) <span class="comment">#打印保存的进度</span></span><br></pre></td></tr></table></figure><p>最后看看我们的结果：</p><p><img src="/images/python/scrap_images.png" alt="运行结果"></p><p><img src="/images/python/scrap_images_d.png" alt="保存结果"></p><p>所以<strong>妈妈再也不用担心我没有素材啦</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本部分的主要代码在&lt;br&gt;&lt;a href=&quot;https://github.com/BaronStack/Python-Reptitle/tree/master/reptitle_trying&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;爬取批量图片到本地&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;如何用python-爬取图片网站的图片&quot;&gt;&lt;a href=&quot;#如何用python-爬取图片网站的图片&quot; class=&quot;headerlink&quot; title=&quot;如何用python 爬取图片网站的图片&quot;&gt;&lt;/a&gt;如何用python 爬取图片网站的图片&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;这里的图片是按页显示的，所以它爬取的是每一页的图片&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;获取网页链接&lt;/li&gt;
&lt;li&gt;利用正则提取以页为单位的html内容&lt;/li&gt;
&lt;li&gt;获取每一页中图片的存储链接&lt;/li&gt;
&lt;li&gt;利用循环下载保存
    
    </summary>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
      <category term="爬虫" scheme="http://yoursite.com/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>2018-01-25</title>
    <link href="http://yoursite.com/2018/01/25/2018-01-25/"/>
    <id>http://yoursite.com/2018/01/25/2018-01-25/</id>
    <published>2018-01-25T01:57:43.000Z</published>
    <updated>2018-01-25T12:03:40.000Z</updated>
    
    <content type="html"><![CDATA[<h5 id="向死而生：我修的死亡学分—–李开复"><a href="#向死而生：我修的死亡学分—–李开复" class="headerlink" title="向死而生：我修的死亡学分—–李开复"></a>向死而生：我修的死亡学分—–李开复</h5><p>昨天晚上开始读这本书，内心一直很纠结。<a id="more"></a>虽然我现在并没有取得像李开复这样的专业成果，但是当我想出这个问题的一瞬间我知道我是急功近利的。</p><p>李开复在事业的最顶峰，人生的最高点遇到了淋巴癌第四期，因为他过于繁杂的工作压力以及对自己近乎苛刻的要求拖垮了他的身体。当他听到这个消息的时候经历了生死哲学大师伊丽莎白·库伯勒·罗斯指出的人类面对重大磨难时会经历的五个重要阶段：否认、愤怒、讨价还价、沮丧和接受。</p><p>然而凭借自己的不懈努力从第一阶段的化疗中挺了过来的时候，星云大师问他：你的人生目标是什么？李开复毫不犹豫的说：提高自己在这个世界的影响力，改变世界。星云大师摇头了。</p><p>看到这个问题我也在想我的人生目标是是什么，然而从脑海中划过无数念头依旧茫然一片（成为行业大佬，以后能够在互联网世界创下一片天地？开着豪车回到家乡，扬起额头让那些曾经瞧不起我们家的人知道自己有多傻？努力完成父母对自己的期盼，成为人中龙凤？努力完成朋友对自己的期盼，成为一个他们心中优秀的人？。。。。。。），可是我为什么要将自己的努力去放在别人心中的那个目标上。</p><p>昨晚我很用心得思考过倘若我的生命再剩下100天，我会做一些什么？（其实有点可笑，至少现在我没有经历很多事情，谈不上什么情怀之类的东西，但我不想活得这么累，为了得到别人的赞扬，别人的羡慕而让我将自己变得急功近利，渴望快速取得成就好去实现他们心中的目标）脑袋很痛，完全没法集中精神去进入场景。在梦里，我看到了，我还原了那个设想，做了以下的事情：</p><ul><li>和以前失去联系的兄弟一起喝酒，一起聊天，一起去回忆初中、高中时代的搞怪时光（大晚上去上网，十几个人被老师抓到，在教室外罚站；宿舍之间的混战昏天黑地，每天晚上进攻一个宿舍，我是主力；一同为了一个题目的解法奋战到凌晨三点；。。。）。</li><li>和失去联系的同桌道了一声”你应该瘦下来了吧！”，然后就被甩了一拳过来！</li><li>和现在喜欢的姑娘躺在草地上分辨天上的星座，然后第二天牵着她的手去看了埃菲尔铁塔，感受爱的宏伟与壮阔；在凯旋门下体会纳粹的嚣张；在巴黎圣母院瞻仰一代圣女的风采；踩在伦敦的本初子午线上嚣张得笑着，掌控时间；然后去非洲大草原一同蹦哒；在刚果盆地看到了非洲的热带雨林；在好望角为迪亚士加油助威；登上马达加斯看看那里的企鹅；再走一场郑和的归程，看看印度CHADAR的人坚强得活着；最后去夏威夷潜水。。。（貌似是穷游，因为没钱）</li><li>最后的时光就是为自己的父母洗脚，为他们做饭，为他们梳头，教他们健身运动，教他们上网（遇到问题怎么处理），挽着他们的手去开开心心得逛一整天的街，一直走，不再愁眉苦脸！</li></ul><p>醒来之后很晕，我想我最近需要放下手头的一切事情，搞清楚这个问题，不要自认为很明确的目标，确是自欺欺人得努力。</p><p>直到刚才读完这本书，我对自己人生重新有了定义：</p><ul><li><strong>拥有健康</strong></li><li><strong>对自己的亲人、爱人一定倍加珍惜</strong></li><li><strong>做真正的自己，在每一个阶段做让自己开心的事情，并绝对专注</strong></li><li><strong>活在当下，坦诚待人</strong></li></ul><p>以下是我读他这本书的过程中认为很好的一些话</p><blockquote><p>珍贵的生命旅程，应该抱着初学者的心态，对世界保持儿童般的好奇心，好好体验人生；让自己每天都比前一天有进步、有成长，不必改变别人，只要做事问心无愧、对人真诚平等，这就足够了。</p><p>与其让千万人过目即忘，不如让一两个人铭记在心。</p><p>眼不见，心不烦，不见可欲，使人心不乱；不烦不乱，就不会带来身心的压力，不然，压力是一切致病之源。</p><p>成功的定义因人而异，没有一定的标准，不需要和别人竞赛，你竞赛的对象是你自己，每天让自己比昨天更好一点，更积极得面对挑战，让内心更加平静。</p><p>再也不要把好东西留到特别的日子才用，你活着的每一天都是特别的日子</p><p>你若盛开，蝴蝶自来；你若精彩，天自安排。</p><p>能力越大，责任越大</p><p>成为某个特殊领域又有用领域的顶尖人才</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;向死而生：我修的死亡学分—–李开复&quot;&gt;&lt;a href=&quot;#向死而生：我修的死亡学分—–李开复&quot; class=&quot;headerlink&quot; title=&quot;向死而生：我修的死亡学分—–李开复&quot;&gt;&lt;/a&gt;向死而生：我修的死亡学分—–李开复&lt;/h5&gt;&lt;p&gt;昨天晚上开始读这本书，内心一直很纠结。
    
    </summary>
    
      <category term="日记" scheme="http://yoursite.com/categories/life/"/>
    
    
  </entry>
  
  <entry>
    <title>2018-01-24</title>
    <link href="http://yoursite.com/2018/01/24/2018-01-24/"/>
    <id>http://yoursite.com/2018/01/24/2018-01-24/</id>
    <published>2018-01-24T12:40:04.000Z</published>
    <updated>2018-01-24T13:19:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天我看到了西安本年度的第一场雪，柔和而又不失优雅。</p><p><img src="/images/FirstSnowIn2018.jpg" alt=""><a id="more"></a></p><p>老师今天给我指点了开题报告，嗯，问题还挺多的。但是我个人实在没法用心去做这个感觉没什么用的开题报告，不就是一个毕业论文的准备嘛，我想不通为什么要花费这么大的精力去搞这个开题报告呢。</p><p>老师用他最擅长的股票黑屏软件给我分析股市动向，当然个人觉得这个东西如果能好好钻研一番以后对理财肯定有大用，不过目前我是没什么太大的兴趣，目前我的学习重点是为了一份好的工作，所以基础的知识得搞懂，还得把Tensorflow相关内容好好学学，这样下学期的比赛如果可以的话说不定还能够拿一些奖励。</p><p>对于股票这里实在是没法兴趣驱动了，而且老师真的是好啰嗦，你说你问题说完了好吧，为什么还要给我讲一些你也不是很擅长的东西，而且没有很强的逻辑，让我们双方都这么辛苦，你嗓子疼，我也耳朵累。</p><p>元谋竟然这么暖呀，天气还特好，那里真的是很舒服的一个地方呢。躺在吊床上，看着星星，感受着带有植物香味的微风吹过耳旁、发梢，然后在鼻梁停一会，轻轻得钻进了我的鼻孔-^_^-。那我就安静得做个美男子，当然旁边有美人陪就更好啦。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天我看到了西安本年度的第一场雪，柔和而又不失优雅。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/FirstSnowIn2018.jpg&quot; alt=&quot;&quot;&gt;
    
    </summary>
    
      <category term="日记" scheme="http://yoursite.com/categories/life/"/>
    
    
  </entry>
  
  <entry>
    <title>Tensorflow 训练变量的存储与加载</title>
    <link href="http://yoursite.com/2018/01/23/Tensorflow-%E8%AE%AD%E7%BB%83%E5%8F%98%E9%87%8F%E7%9A%84%E5%AD%98%E5%82%A8%E4%B8%8E%E5%8A%A0%E8%BD%BD/"/>
    <id>http://yoursite.com/2018/01/23/Tensorflow-训练变量的存储与加载/</id>
    <published>2018-01-23T13:23:20.000Z</published>
    <updated>2018-01-23T13:47:36.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/BaronStack/tensorflow_learning/tree/master/莫烦TensorflowProgram_Learning/implement_store_and_restore_saver" target="_blank" rel="noopener">TF代码</a></p><h4 id="本篇主要讲的是利用TensorFlow将我们训练好的变量-Weights-和-biases-或者loss…-存储下来，下次训练加载这次的存储"><a href="#本篇主要讲的是利用TensorFlow将我们训练好的变量-Weights-和-biases-或者loss…-存储下来，下次训练加载这次的存储" class="headerlink" title="本篇主要讲的是利用TensorFlow将我们训练好的变量(Weights 和 biases 或者loss…)存储下来，下次训练加载这次的存储 "></a>本篇主要讲的是利用TensorFlow将我们训练好的变量(Weights 和 biases 或者loss…)存储下来，下次训练加载这次的存储 <a id="more"></a></h4><p>存储主要利用函数<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">save_path = saver.save(sess, <span class="string">"my_net/save_net.ckpt"</span>)<span class="comment">#定义变量结果的存储位置,可放在程序最后位置</span></span><br></pre></td></tr></table></figure></p><p>存储结果运行如下（运行代码build_new_network.py）结果如下，<strong>该结果显示的是误差，即预测结果与真实结果之间的误差，越小说明预测结果约精确</strong>：</p><p><img src="/images/TensorflowImages/store.png" alt=""></p><p>加载主要利用函数：<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">saver = tf.train.Saver()</span><br><span class="line">sess = tf.Session() <span class="comment">#需要先定义Session()</span></span><br><span class="line">saver.restore(sess, <span class="string">"my_net/save_net.ckpt"</span>) <span class="comment">#从存储目录加载加载</span></span><br></pre></td></tr></table></figure></p><p>加载运行结果如下（运行代码build_network_restore.py，这个代码和上一个代码的功能一样，注意：<strong>变量初始化函数</strong>在加载的时候不需要添加），结果如下：</p><p><img src="/images/TensorflowImages/restore.png" alt=""></p><p>可以看到虽然并没又从上一个结果紧跟着开始运行，而训练依旧可以认为是接着上一次的运行结果开始训练</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://github.com/BaronStack/tensorflow_learning/tree/master/莫烦TensorflowProgram_Learning/implement_store_and_restore_saver&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;TF代码&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;本篇主要讲的是利用TensorFlow将我们训练好的变量-Weights-和-biases-或者loss…-存储下来，下次训练加载这次的存储&quot;&gt;&lt;a href=&quot;#本篇主要讲的是利用TensorFlow将我们训练好的变量-Weights-和-biases-或者loss…-存储下来，下次训练加载这次的存储&quot; class=&quot;headerlink&quot; title=&quot;本篇主要讲的是利用TensorFlow将我们训练好的变量(Weights 和 biases 或者loss…)存储下来，下次训练加载这次的存储 &quot;&gt;&lt;/a&gt;本篇主要讲的是利用TensorFlow将我们训练好的变量(Weights 和 biases 或者loss…)存储下来，下次训练加载这次的存储
    
    </summary>
    
      <category term="tensor flow" scheme="http://yoursite.com/categories/tensor-flow/"/>
    
    
      <category term="machine learning" scheme="http://yoursite.com/tags/machine-learning/"/>
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>2018-01-23</title>
    <link href="http://yoursite.com/2018/01/23/2018-01-23/"/>
    <id>http://yoursite.com/2018/01/23/2018-01-23/</id>
    <published>2018-01-23T11:30:14.000Z</published>
    <updated>2018-01-23T12:07:06.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>无善无恶心之体，有善有恶意之动。知善知恶是良知，为善去恶是格物。</p></blockquote><p>最近状态不是很好，内心有点浮躁了。昨天晚上做梦竟然做了一晚上的语文试卷，我都不知道自己在干什么，就坐在那努力得理解题目，看一个不知道怎么写，看一个不知道怎么写。今天早上起床让永永给分析了一下，<a id="more"></a>我去，她竟然还有相关的书籍，不愧是耳濡目染的唐小仙。然后她说得很有道理，总之我联想了一下最近状态，确实是压力有点大。</p><p>分析了一下，原因有三：</p><ul><li>在专业学习（tensorFlow）上太急，毕竟这个需要大量时间的积累与理解，而我想要用仅仅一个月时间达到别人花费那么长时间才达到的程度，根本就是自找苦吃。</li><li>缺少锻炼，压力无从释放。因为健身房关门了，最近也就回归到了三点一线的生活，回宿舍也就锻炼那么20来分钟，根本没有办法让压力很好得释放</li><li>强行给自己添加压力。看到身边一些伙伴进入到了BAT，我表示不服，北京的互联网公司还是很不错的，但是这种大厂毕竟需要很长时间的准备，所以就发现自己还有很多东西不会（C++语言基础，数据结构（手写代码），操作系统，计算机网络理论方面都欠缺很多），所以心慌慌。</li></ul><p>那么知道了原因，还是得调整调整，就像唐小仙说的：平和一点对待着急和紧张的心情。</p><p>解决办法：</p><ul><li>增加锻炼时间（每天150俯卧撑）</li><li>经常向唐小仙请教一些心理上的问题，她对心理学还真的是有点了解呢</li><li>素描得提上日程了，可以先学习一些基础的物体画—回家了再好好学习人物素描</li></ul><p>永永是个好菇凉，我该怎么才能更加深入她的内心呢，怎么才能体会她到底是一个什么样子的人呢。她喜欢狐妖之类的动漫，我看了几部感觉还真不错。我猜她喜欢涂山苏苏的形象，做事情笨笨的，看起来傻傻的，但是选择了一件事情就那么执着，对待身边的人又那么善良，渴望用自己微弱的力量成为一名合格的涂山狐妖，一次次的失败与打击都无法阻挠她对理想的追求，而涂山红红则是理性得执着得追求自己的理想。<strong>嗯，我貌似懂了一点什么，那是她自己。如果我对苏苏的分析没错的话我希望成为那个白（东方）月初！她这么笨，哪天把自己丢了，怎么去当老师，还是得看紧一点好呢</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;无善无恶心之体，有善有恶意之动。知善知恶是良知，为善去恶是格物。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;最近状态不是很好，内心有点浮躁了。昨天晚上做梦竟然做了一晚上的语文试卷，我都不知道自己在干什么，就坐在那努力得理解题目，看一个不知道怎么写，看一个不知道怎么写。今天早上起床让永永给分析了一下，
    
    </summary>
    
      <category term="日记" scheme="http://yoursite.com/categories/life/"/>
    
    
  </entry>
  
  <entry>
    <title>2018-01-21</title>
    <link href="http://yoursite.com/2018/01/21/2018-01-21/"/>
    <id>http://yoursite.com/2018/01/21/2018-01-21/</id>
    <published>2018-01-21T13:43:30.000Z</published>
    <updated>2018-01-22T07:23:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>废话不多说，先上一个关于人工智能以及深度学习入门的一个大佬的博客链接<a href="https://morvanzhou.github.io/" target="_blank" rel="noopener">莫烦</a>，这两天一直在看他的教学视频，真的是受益匪浅。<a id="more"></a></p><p>我从他的视频讲解中了解到的一些理论知识如下：</p><ul><li>什么是神经网络</li><li>什么是梯度下降</li><li>什么是激励函数</li></ul><p>这一些基础且重要的概念，让我在实践过程中对神经网络有了更深一步的了解</p><p><strong>神经网络（NEURAL NETS）</strong> ：计算机中的神经网络是模拟人的神经网络的形成和功能的一种基于统计学、数学、计算机科学的模型。它可以对输入和输出数据之间的关系进行建模，从而产生特定且有用的概率数据。当然，神经网络通过很多层的数据处理，将输入的大量数据通过不断的反馈优化，降低其与真实值之间的差距，产生一个较高概率的结果。</p><p><strong>梯度下降 (GRADIENT DESCENT)</strong> ：神经网络在进行数据预测的时候会有一个误差方程，来降低真实结果与预测结果之间的误差，这个降低误差的过程就叫做梯度下降。当然Tensorflow中所拥有的API可以进类似于梯度下降的功能！</p><p><strong>激励函数（ACTIVATION FUNCTION）</strong> ：为了解决日常生活中不能用线性方程解决的问题（一般神经网络中数值关系理想状态下都是线性的，但是理想是美好的，现实是残酷的，那么就需要激励函数将理想中的数值关系强行掰弯），从而使得训练的输出结果拥有非线性的关系，提升预测结果概率。（TENSORFLOW 官网有大量的激励函数，在神经网CNN一般使用relu,在神经网络RNN常使用relu和tanh）</p><p>一些实际的Tensor flow程序可以参考莫烦的github，而且他的视频对程序的讲解很详细，一定要耐心琢磨。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;废话不多说，先上一个关于人工智能以及深度学习入门的一个大佬的博客链接&lt;a href=&quot;https://morvanzhou.github.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;莫烦&lt;/a&gt;，这两天一直在看他的教学视频，真的是受益匪浅。
    
    </summary>
    
      <category term="日记" scheme="http://yoursite.com/categories/life/"/>
    
    
  </entry>
  
  <entry>
    <title>Sat Jan 20 2018 00:00:00 GMT+0800 (CST)</title>
    <link href="http://yoursite.com/2018/01/20/2018-01-20/"/>
    <id>http://yoursite.com/2018/01/20/2018-01-20/</id>
    <published>2018-01-20T09:36:54.000Z</published>
    <updated>2018-01-23T12:23:39.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天和学长学姐参加了一个关于人工智能的讲座，虽然听的过程中收获不是很多，但是在结束后和直系学长的聊天过程中让我受益匪浅。这个学长本科是在我们学校，不过他在牛津大学上过两年的博士，对于人工智能领域中的深度学习领域中的图像分割、识别、分类了解较为清楚。<a id="more"></a></p><p>当然今天是他做为主讲人，对我这种刚入门的小白来说所讲的内容让我云里雾里，因为很多东西都有涉及到极为深刻的理论，想要理解必须自己动手去尝试，同时对代数以及数理统计也要有足够的基础，听起来才不会很吃力。当然，目前我的状态是排除在外的。</p><p>学长讲完之后，我将自己这两天基础学习过程中遇到的问题进行了总结，在结束的时候就请教了学长。学长人很好，他应该算是很早进入人工智能领域的那部分人，我所遇到的这些基础问题（大多是关于程序上的问题）可能对学长来说很low,但是学长还是很耐心得给我分析讲解。告诉我神经网络无非就是通过输入的数据进行不同隐藏层的，经过训练，得到一个w值和b值，这两个值经过处理可以做为我们想要的数据结果。Tensorflow这个平台在前期学习的时候遇到的问题一定要多的google，去理解构建图的过程是什么样子的，为什么要这样构建，以及卷积在图中的作用是什么。只要把这些程序框架搞清楚，再去看程序就容易很多了，而程序中遇到的较难理解的函数就去查文档。</p><p>之后学长又给我分析了深度学习领域在行业中的广大前景，因为这个领域在当下火起来也就两年时间，它能够应用到社会生活的各行各业（工业：开矿—》钻机通过对前方矿藏的图片分析，自动调整挖掘方向。。。商业：股票市场：—》通过LSTM对股票走势进行分析，自动买入卖出，解放人力交易员。。。医学：病变部位识别—》通过CNN对病人的生病部位进行识别分类，更精确得检测病变部位。。。）的应用。但是目前各行各业还处于瓶颈期，因为这个深度学习领域的人才是在太少，当然该领域的门槛也是较高的（即使是学习计算机的，没有数学基础很难精通。学习过程中需要极大的耐心去一点点得优化学习）。</p><p>所以坚持这条路相对于去做软件开发，去搞网站后端之类的前人已经做得很多的方面实在是没有可以创新的地方，还不如去聚焦当下这个领域努力学习几年。至少这个领域是在为社会前沿做真正的有用的贡献。然后他又提到他以前在牛津学习的时候，周围很多行业大佬，但是大家在学习上那叫一个用功呀，他那个时候每天也是三点一线，晚上2.00多睡觉，早上6.00起床，之后去图书馆看书查资料或者跟着团队做事情。下午就会去健身房锻炼锻炼，他说学习计算机的人一定要有一个好身体，不然熬夜3天要休息一个月，这样就会损失很多。他觉得这段时间是他学习进步最快的一段时间，当时满脑子只有一个东西，只去想一个东西，然后自然而然就更加深入了。</p><p>现在他说如果他愿意，华为会给他40W年薪，并立即分给他一个50W预付的房子，如果在工作中做出成绩，2年房子就归他了。但是他想留校，他不愿意花费时间经历去做一些业务的事情，干几十年依旧是那么个职位，更愿意去在学校做做项目，全心投入领域的学习过程中。哎，这可能就是现在的高帅即将富的人吧：学长185的个子，长得很帅，又有能力，待人又好。</p><p>听了学长一番经历和未来专业的发展我感慨良多，虽然学长比我大6岁，但是6年后我能有他这样的自信嘛！我相信可以有的，我会扎根现在，不会去想什么专业上的假大空的事情，一步一个脚印扎扎实实得坚持走下去。 </p><p>接下来的时间就是要好好参考一下北京的公司了，同时学习deep learning之外要刷刷牛客网上的题目，如果她愿意和我在一起，为了她的好生活至少拼一把。昨天在牛客网上看到一个研三的大佬，很多大企的offer，原因是：工作易找，佳人难求。他是为了和他女朋友在一个地方，才会广投简历。那我也相信我不差，佳人难求呀！</p><p>昨天晚上又给她要了一些她以前的照片，笑死我了。她的小肥脸一直陪伴了她好久呢，虽然现在好像不明显了。。。</p><p><img src="/images/yongyong/senior01.jpg" alt="高中"></p><p><img src="/images/yongyong/senior02.jpg" alt="高中"></p><p><img src="/images/yongyong/baseball.jpg" alt="高中"></p><p><img src="/images/yongyong/serious.jpg" alt="大学，大二或者大三"></p><p><img src="/images/yongyong/swim.jpg" alt="游泳"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天和学长学姐参加了一个关于人工智能的讲座，虽然听的过程中收获不是很多，但是在结束后和直系学长的聊天过程中让我受益匪浅。这个学长本科是在我们学校，不过他在牛津大学上过两年的博士，对于人工智能领域中的深度学习领域中的图像分割、识别、分类了解较为清楚。
    
    </summary>
    
      <category term="日记" scheme="http://yoursite.com/categories/life/"/>
    
    
  </entry>
  
  <entry>
    <title>恋爱经验得提升了</title>
    <link href="http://yoursite.com/2018/01/19/%E6%81%8B%E7%88%B1%E7%BB%8F%E9%AA%8C%E5%BE%97%E6%8F%90%E5%8D%87%E4%BA%86/"/>
    <id>http://yoursite.com/2018/01/19/恋爱经验得提升了/</id>
    <published>2018-01-19T01:34:54.000Z</published>
    <updated>2018-01-20T07:33:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近被Tensorflow快逼疯了，没有想到这个东西这么难，可能是自己的数学基础还不够吧。自从上次永永说我每天找一个时间段和她聊天可能会烦到她，感觉和她聊天没有以前那种轻松了。<a id="more"></a>我思考了一下我的心理，因我我太过于急躁，太过于盲目表达，她的内心比较纠结，还不愿意上一段感情没有缓过来就很快得接受下一段的感情，这让她体会到两个人在一起相互了解是有多么重要。</p><p>待在家里这件事情本来就是平淡，在家里如果不是什么特殊的日子，应该就是三点一线的生活形式，不需要每天都聊那么长时间，最后无话可说岂不是很尴尬。又想起给她看了我写的那篇日记，真是不理智，我不是一个愿意作空头承诺的人，我更希望拿出一个让她开心的结果再加上我对她的喜欢来打动她，而不是让她先看到一个承诺～～</p><p>尤其是在家里，一定要有个人的生活空间，我们现在还不够了解，还达不到那种随意展现自己不好一面的程度，所以想了一下这段时间我还是不要主动联系她的好。<br>昨天晚上给她发晚安 谁知道她竟然没睡，玩了一局万恶的贪吃蛇没有回复她消息，导致她整晚失眠。但是我一到晚上大脑就处于停滞状态，根本想不出怎么让她<br>睡觉的法子，fucked.</p><p>此外，女生心里好难猜啊，看她的朋友圈我只能看出她表达的表面内容，但是我看不出她想要表达的深层意思以及她的心情，这可能就是直男的悲哀吧，好难受～～～</p><p>算了，假期要好好提升恋爱经验了，回去好好问问同学，不要再错过了。至少让她感觉和我在一起很舒服就行，别压力山大或者心情不好。</p><p>对了，今天无意中看到朋友圈有人晒健身照，我当时就怒了，敢在我这健身老手的朋友圈晒健身照，要不要给她秀一波，最后惊出一身冷汗，不行，永永说不要看到我不穿衣服的照片，哎，那就算了。小子，我忍了，等什么时候她愿意看了我就要秀死你！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近被Tensorflow快逼疯了，没有想到这个东西这么难，可能是自己的数学基础还不够吧。自从上次永永说我每天找一个时间段和她聊天可能会烦到她，感觉和她聊天没有以前那种轻松了。
    
    </summary>
    
      <category term="日记" scheme="http://yoursite.com/categories/life/"/>
    
    
  </entry>
  
  <entry>
    <title>最后的健身房之日</title>
    <link href="http://yoursite.com/2018/01/18/%E6%9C%80%E5%90%8E%E7%9A%84%E5%81%A5%E8%BA%AB%E6%88%BF%E4%B9%8B%E6%97%A5/"/>
    <id>http://yoursite.com/2018/01/18/最后的健身房之日/</id>
    <published>2018-01-18T12:33:07.000Z</published>
    <updated>2018-01-20T07:34:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天是在学校待在健身房的最后一天，相对来说我的心里还是极度开心的。因为我看到我自身两个月的变化，从找完工作11月份开始到现在，平均每周去健身房6次，从减脂到增肌，这里的两个月对我的身体来说是变化最大的,这里给大家看看我的目前的健身结果。<a id="more"></a></p><p><img src="/images/健身02.jpg" alt="目前的上身"></p><p>我看到了自己推举的重量的提升，我看到了自己胸肌、背肌、腹肌的点点滴滴的变化。每一份部分肌肉群的增长都是我的悉心培育，就跟父母看着优秀的孩子长大一样，那种莫名自豪由衷而发。</p><p>那接下来我会更加努力去提升自己的自律性，尽可能得保证接下来以及回家的日子不胖就好，不过难度很大，毕竟吃得多啊～～～</p><p>最近发现处于恋爱中的人，对方的每一个动作每一个与自己相关的事情都会牵动我的心弦。</p><p>我将她置顶，这样我就可以在自己空闲时候第一个点开她的朋友圈，看看她在做什么，蓦然发现自己已经对其他人的推文毫不关心了，朋友圈里只有她。比如：今天她听了周杰伦的新歌《等你下课》，貌似她挺喜欢周杰伦的（以后有机会确认一下）。然后她下午又给妈妈做了个醋溜白菜的菜，看起来还挺辣的，不过感觉色香味俱全呢，</p><p><img src="/images/yongyongdecai.jpg" alt="辣椒拌白菜"></p><p>哎～～～不知道以后我能吃到不。最近不怎么看微信读书了，不过我喜欢发想法，就是不让自己以前看的书给忘了。然后永永给我点赞，很开心很开心呢。她说她回家也要像我一样制定一个时间计划表，那就说明她是比较赞同我现在的生活的。想到昨天晚上12.00多了她还要去学习专八，我都吓到了，太努力了吧，不过她说她爸爸对她要求比较高呢，那我感觉压力更大了，对她要求都这么高，那对她的男朋友呢？我靠，我在想什么呢，这是以后的事情，只要我能吸引住她，那我一定会成为她爸爸心中的女婿的。</p><p>是时候做一波总结啦，永永喜欢什么呢，有一些还不确定，我只能先列出来，以后再改善吧：</p><blockquote><ul><li>萌萌哒的小动物肯定是第一个（皮卡丘、黑15）</li><li>她喜欢粉色（上次一起吃饭她说把蓝色的餐巾纸换成粉色的的就好啦）</li><li>她喜欢樱花（她说交大春天的樱花开了，她自己去看），不对不对，貌似这句话我没有记忆正确（<strong>不确定</strong>），不过她肯定喜欢美丽的花</li><li>她喜欢一些可爱的小植物(宿舍里养了一堆，假期回家前还专门给它们做了供水装置，真是用心呢，我喜欢)</li><li>她喜欢吃蓝莓（蓝莓冰淇淋，蓝莓酸奶）</li><li>她喜欢吃橙子</li><li>她喜欢尝试新的事物（吃的、玩的）</li><li>她其实并不喜欢说太多的话</li><li>她喜欢人类学，她的梦想是去做一名老师</li><li>她喜欢周杰伦（<strong>不确定有多喜欢</strong>）</li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天是在学校待在健身房的最后一天，相对来说我的心里还是极度开心的。因为我看到我自身两个月的变化，从找完工作11月份开始到现在，平均每周去健身房6次，从减脂到增肌，这里的两个月对我的身体来说是变化最大的,这里给大家看看我的目前的健身结果。
    
    </summary>
    
      <category term="日记" scheme="http://yoursite.com/categories/life/"/>
    
    
  </entry>
  
  <entry>
    <title>linux下压缩命令`gizp`,`bzip2`,打包命令`tar`以及三个变动时间的意义</title>
    <link href="http://yoursite.com/2018/01/18/linux%E4%B8%8B%E6%89%93%E5%8C%85%E5%91%BD%E4%BB%A4tar%E4%BB%A5%E5%8F%8A%E4%B8%89%E4%B8%AA%E5%8F%98%E5%8A%A8%E6%97%B6%E9%97%B4%E7%9A%84%E6%84%8F%E4%B9%89/"/>
    <id>http://yoursite.com/2018/01/18/linux下打包命令tar以及三个变动时间的意义/</id>
    <published>2018-01-18T08:25:27.000Z</published>
    <updated>2018-01-18T09:58:39.000Z</updated>
    
    <content type="html"><![CDATA[<h5 id="常见的压缩文件扩展名有以下几个"><a href="#常见的压缩文件扩展名有以下几个" class="headerlink" title="常见的压缩文件扩展名有以下几个"></a>常见的压缩文件扩展名有以下几个</h5><ol><li><font color="#0099ff">*.z    <strong>compress程序压缩文件</strong></font></li><li><font color="#0099ff">*.gz     <strong>gzip程序压缩文件</strong></font></li><li><font color="#0099ff">*.bz2    <strong>bzip2程序压缩文件</strong></font></li><li><font color="#0099ff">*.tar    <strong>tar程序打包数据，没有压缩</strong>        </font></li><li><font color="#0099ff">*.tar.gz <strong>tar打包的数据，经过gzip压缩</strong></font></li><li><font color="#0099ff">*.tar.bz2 <strong>tar打包的文件，经过bzip2压缩</strong><a id="more"></a></font></li></ol><h5 id="利用gzip和bzip2进行单个文件的压缩与解压缩"><a href="#利用gzip和bzip2进行单个文件的压缩与解压缩" class="headerlink" title="利用gzip和bzip2进行单个文件的压缩与解压缩"></a>利用<code>gzip</code>和<code>bzip2</code>进行单个文件的压缩与解压缩</h5><p>命令如下（建议大家在自己的终端上进行实践）：</p><p>描述：<strong>将文件<code>/etc/manpath.config</code>复制到<code>/tmp</code>目录下，进行<code>gzip</code>压缩，显示压缩比，并查看压缩后的文件内容。最后进行解压缩</strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cp /etc/manpath<span class="selector-class">.config</span> /tmp</span><br><span class="line">cd /tmp</span><br><span class="line">gzip -v manpath<span class="selector-class">.config</span>  #-v参数是显示压缩比</span><br><span class="line">ll /etc/manpath<span class="selector-class">.config</span> ./manpath<span class="selector-class">.config</span><span class="selector-class">.gz</span> #查看压缩前后文件的大小变化</span><br><span class="line">zcat manpath<span class="selector-class">.config</span> #查看被压缩的文件内容</span><br><span class="line">gzip -d manpanth<span class="selector-class">.config</span><span class="selector-class">.gz</span> #-d参数是解压缩</span><br><span class="line"></span><br><span class="line">gzip -<span class="number">9</span> -c manpath<span class="selector-class">.config</span> &gt; manpath<span class="selector-class">.config</span><span class="selector-class">.gz</span> #-<span class="number">9</span> 是压缩等级最慢，但是压缩比最高 -c参数将压缩的结果输出到屏幕，这里用到了重定向符号<span class="string">"&gt;"</span></span><br></pre></td></tr></table></figure><p>以上过程中可以利用命令<code>ll</code>查看文件属性（关注它与原来文件相比的大小变化）</p><p>描述：<strong>利用上面的文件<code>manpath.config</code>文件，用bzip2进行压缩，同时对比它与gzip压缩结果的不同，查看它的压缩文件内容</strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bzip2 -v manpath.config</span><br><span class="line">ll /etc/manpath<span class="selector-class">.config</span> ./manpath<span class="selector-class">.config</span><span class="selector-class">.gz</span> ./manpath<span class="selector-class">.config</span><span class="selector-class">.bz2</span> #查看两个压缩文件相比与原文件的大小变化</span><br><span class="line">bzcat manpath<span class="selector-class">.config</span><span class="selector-class">.bz2</span> #查看bz2压缩文件的内容</span><br><span class="line">bzip2 -d manpath<span class="selector-class">.config</span><span class="selector-class">.bz2</span> #解压缩</span><br></pre></td></tr></table></figure><h5 id="利用tar命令对多个文件进行打包，压缩，解压缩"><a href="#利用tar命令对多个文件进行打包，压缩，解压缩" class="headerlink" title="利用tar命令对多个文件进行打包，压缩，解压缩"></a>利用<code>tar</code>命令对多个文件进行打包，压缩，解压缩</h5><p>一般<code>bzip2</code>和<code>gzip</code>只能对单个文件进行进行压缩，但是<code>tar</code>可以对多个文件进行操作</p><p>命令：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tar -jcv -f /root/etc<span class="selector-class">.tar</span><span class="selector-class">.bz2</span> /etc #将/etc打包为etc<span class="selector-class">.tar</span><span class="selector-class">.bz2</span>,并且存放在/root下 -j参数表示以bzip2压缩程序压缩 -c进行打包，-v显示打包的文件</span><br><span class="line">tar -jtv -f /root/etc<span class="selector-class">.tar</span><span class="selector-class">.bz2</span> #查询打包中的文件名。可以配合grep命令进行查找</span><br><span class="line">tar -jxv -f /root/etc<span class="selector-class">.tar</span><span class="selector-class">.bz2</span> #直接解压到本地目录</span><br><span class="line">tar -jxv -f /root/etc<span class="selector-class">.tar</span><span class="selector-class">.bz2</span> -C /tmp #-C参数是解压到指定目录</span><br></pre></td></tr></table></figure><p>如果想要将以bzip2进行压缩的文件改为以gzip进行压缩的话只需要将参数j换为z即可</p><p>可以利用<code>grep</code>命令进行查找，在压缩文中查找指定文件，然后解压的时候只需要解压我们需要的文件就可以</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tar -jtv -f <span class="regexp">/root/</span>etc.tar.bz2 | grep <span class="string">'shadow'</span> <span class="comment">#找到shadow文件</span></span><br><span class="line">tar -jxv -f <span class="regexp">/root/</span>etc.tar.bz2 etc<span class="regexp">/shadow #解压出单独的shadow文件</span></span><br></pre></td></tr></table></figure><p>基本上常用的tar命令这么多，如果大家还想要了解更多tar 相关的内容，可以参考<a href="https://www.cnblogs.com/xiaochina/p/5801959.html" target="_blank" rel="noopener">tar命令详解</a></p><h5 id="最后说一下Linux系统中三个主要的时间参数"><a href="#最后说一下Linux系统中三个主要的时间参数" class="headerlink" title="最后说一下Linux系统中三个主要的时间参数"></a>最后说一下Linux系统中三个主要的时间参数</h5><p><code>mtime</code> <strong>modification time</strong></p><p>当该文件内容修改时，就会更新这个时间。内容数据值的是文件的内容，不是文件的属性或者权限</p><p><code>ctime</code> <strong>status time</strong></p><p>当文件”状态”改变时就会更新这个时间，状态指的是：权限，属性</p><p><code>atime</code> <strong>access time</strong></p><p>当该文件的”内容”被取用的时候会更新这个时间，比如我们使用<code>cat</code>去查看该文件的时候就会更新该文件的atime,即文件被读的时候会更改该时间</p>]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;常见的压缩文件扩展名有以下几个&quot;&gt;&lt;a href=&quot;#常见的压缩文件扩展名有以下几个&quot; class=&quot;headerlink&quot; title=&quot;常见的压缩文件扩展名有以下几个&quot;&gt;&lt;/a&gt;常见的压缩文件扩展名有以下几个&lt;/h5&gt;&lt;ol&gt;
&lt;li&gt;&lt;font color=&quot;#0099ff&quot;&gt;*.z    &lt;strong&gt;compress程序压缩文件&lt;/strong&gt;&lt;/font&gt;&lt;/li&gt;
&lt;li&gt;&lt;font color=&quot;#0099ff&quot;&gt;*.gz     &lt;strong&gt;gzip程序压缩文件&lt;/strong&gt;&lt;/font&gt;&lt;/li&gt;
&lt;li&gt;&lt;font color=&quot;#0099ff&quot;&gt;*.bz2    &lt;strong&gt;bzip2程序压缩文件&lt;/strong&gt;&lt;/font&gt;&lt;/li&gt;
&lt;li&gt;&lt;font color=&quot;#0099ff&quot;&gt;*.tar    &lt;strong&gt;tar程序打包数据，没有压缩&lt;/strong&gt;        &lt;/font&gt;&lt;/li&gt;
&lt;li&gt;&lt;font color=&quot;#0099ff&quot;&gt;*.tar.gz &lt;strong&gt;tar打包的数据，经过gzip压缩&lt;/strong&gt;&lt;/font&gt;&lt;/li&gt;
&lt;li&gt;&lt;font color=&quot;#0099ff&quot;&gt;*.tar.bz2 &lt;strong&gt;tar打包的文件，经过bzip2压缩&lt;/strong&gt;
    
    </summary>
    
      <category term="linux" scheme="http://yoursite.com/categories/linux/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>关于tensor flow废弃的API</title>
    <link href="http://yoursite.com/2018/01/18/%E5%85%B3%E4%BA%8Etensor-flow%E5%BA%9F%E5%BC%83%E7%9A%84API/"/>
    <id>http://yoursite.com/2018/01/18/关于tensor-flow废弃的API/</id>
    <published>2018-01-18T03:39:19.000Z</published>
    <updated>2018-01-18T03:48:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天开始写一些tensor flow 的代码，发现官网上的一些样例程序无法运行，会出现一些找不到函数的情况。查阅之后发现原来是官网对tensor flow 包进<br>行了更新，只是还没有将官网的程序进行更新。<a id="more"></a></p><p>主要是以下几个API： </p><p><code>tf.mul</code>和<code>tf.sub</code>和<code>tf.neg</code> 取乘运算，取减运算，取负运算</p><p>更改为</p><p><code>tf.multiply</code>和<code>tf.subtract</code>和<code>tf.negative</code>，这样在进行基础矩阵运算的时候就可以使用这些函数正常进行运算    </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天开始写一些tensor flow 的代码，发现官网上的一些样例程序无法运行，会出现一些找不到函数的情况。查阅之后发现原来是官网对tensor flow 包进&lt;br&gt;行了更新，只是还没有将官网的程序进行更新。
    
    </summary>
    
      <category term="tensor flow" scheme="http://yoursite.com/categories/tensor-flow/"/>
    
    
      <category term="machine learning" scheme="http://yoursite.com/tags/machine-learning/"/>
    
  </entry>
  
  <entry>
    <title>今天有点累</title>
    <link href="http://yoursite.com/2018/01/17/%E4%BB%8A%E5%A4%A9%E6%9C%89%E7%82%B9%E7%B4%AF/"/>
    <id>http://yoursite.com/2018/01/17/今天有点累/</id>
    <published>2018-01-17T15:25:10.000Z</published>
    <updated>2018-01-17T15:57:43.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天又有点累，真是对自己无语了。<br>看到妹妹在家里吃着妈妈做的大餐，我却只能在学校啃着干面包，心里不平衡呀。<a id="more"></a>而且她竟然给我发她吃饭时候的疯狂状态，哎呀，我都难受死了。<br>不过谁让这是咱自己的选择嘞，那就要坚持下去，毕竟每天还是挺充实的。心里有了一个人，做事情的时候总是会比以前多付出一些努力。</p><p>妈妈说爱一个人是一件很幸福的事情，这句话我体会到了。很感谢有一个这样的妈妈，虽然妈妈是农民，但是她以前是可以上大学的，只是因为没有后台被别人<br>给代替了，这是她一生最为遗憾的事情！她从来没有强迫我做一些不喜欢的事情，随着年龄和学历的增长，妈妈再也不能对我的学习进行辅导了，但是她却可以<br>辅导我的人生。她总告诉我和妹妹：先学会做人，再去学做事。我从妈妈的身上看到了做为一名传统中国女性所拥有的傲气与坚韧，她支持我去做我喜欢的事情，<br>追求我心中所喜欢的人，可能这是天下所有母亲内心的写照：希望自己的孩子开心快乐。<br>想回家吃饭，吃妈妈做的炒土豆丝，煎豆腐，醋溜白菜。。。。。。不过现在还是得努力学习。</p><p>下午本来想给学长秀一波操作，在Linux下配置pycharm的tensor flow开发环境。因为我是在自己电脑上配置好了的，结果发现问题完全不一样，自信满满得<br>上去，最后赤裸裸得打脸，解决不了。妈蛋，谁让自己作，还好学长人比较好，要不然我就得受点打击了。不过还好，一些linux的基础命令掌握还算牢固，没有<br>出什么差错。</p><p>小小的总结一下：</p><ul><li>做事情三思而后行，每一次在大众面前的呈现都是自己一段时间的积累，万不可掉以轻心</li><li>重要的知识一定要掌握牢固，最好让它成为自己的潜意识，所以这里就需要多得实践（linux:解压命令，打开指定软件的命令，下载安装命令，卸载命令）</li><li>不会的要多请教（针对今天出现的问题是因为：1.程序写的不对 2.文件存放的位置不对（可能是，明天得再去看看））</li></ul><p>好啦，今天就写到这里。以前没有想过写日记，发现其实还是蛮有意思的，古人问：我日三省我身，高否？富否？帅否？我答：否 古人云：该睡觉啦<br>嗯～～～有道理，那就去做呗。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天又有点累，真是对自己无语了。&lt;br&gt;看到妹妹在家里吃着妈妈做的大餐，我却只能在学校啃着干面包，心里不平衡呀。
    
    </summary>
    
      <category term="日记" scheme="http://yoursite.com/categories/life/"/>
    
    
  </entry>
  
  <entry>
    <title>Mac将tensorflow的python环境配置到pycharm</title>
    <link href="http://yoursite.com/2018/01/17/Mac%E5%B0%86python%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E5%88%B0pycharm/"/>
    <id>http://yoursite.com/2018/01/17/Mac将python环境配置到pycharm/</id>
    <published>2018-01-17T12:56:00.000Z</published>
    <updated>2018-01-17T13:29:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>当我们开始学习tensor flow的时候，环境有了，但是没有一个好的python运行环境会很难受，所以在这里推荐几个很受用的python运行环境。今天是第一次<br>接触pycharm，正如它所起的名字一样”迷人的python”,你会在见到它的第一眼就被深深得吸引。<br>以下是它的运行环境：</p><p><img src="/images/pycharm.png" alt=""><a id="more"></a></p><p>使用起来的感觉就和做前端开发对webstorm的感觉一样，快捷，功能强大（支持各种插件：terminal,git…）</p><p>在搭建好tensor flow运行环境之后我们想要让pycharm 拥有一样的tensor flow开发环境，那么需要做一个很简单的路径配置。大家先在<a href="https://www.tensorflow.org" target="_blank" rel="noopener">tersor flow</a><br>官网,按照教程搭建好自己的开发环境。此外安装破解版<a href="http://www.sdifen.com/phpstorm201623.html" target="_blank" rel="noopener">pycharm</a>.</p><p>接下来按照如下操作步骤配置自己的pycharm的tensor flow开发环境 </p><ol><li>终端下进入tersor flow运行脚本，输入<code>which python</code>之后，复制得到的python路径</li><li>打开pycharm–》preferences–》在左侧搜索栏中搜索project interpreter –》点击一个设置图标，点击”Add Local” –》将复制的python路<br>径输入进去–》点击OK</li></ol><p>大功告成，截图如下<br><img src="/images/project_interpreter.png" alt=""></p><p><img src="/images/printCutSet.png" alt=""></p><p><img src="/images/addLocal.png" alt=""></p><p><img src="/images/inputPath.png" alt=""></p><p><img src="/images/successOutput.png" alt=""></p><p>大家就可以开心得在一个优雅的编译器下尽情做tensor flow尝试啦 </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当我们开始学习tensor flow的时候，环境有了，但是没有一个好的python运行环境会很难受，所以在这里推荐几个很受用的python运行环境。今天是第一次&lt;br&gt;接触pycharm，正如它所起的名字一样”迷人的python”,你会在见到它的第一眼就被深深得吸引。&lt;br&gt;以下是它的运行环境：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/pycharm.png&quot; alt=&quot;&quot;&gt;
    
    </summary>
    
      <category term="tensor flow" scheme="http://yoursite.com/categories/tensor-flow/"/>
    
    
      <category term="machine learning" scheme="http://yoursite.com/tags/machine-learning/"/>
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Python 中出现Non-ASCII character的解决办法</title>
    <link href="http://yoursite.com/2018/01/17/Python-%E4%B8%AD%E5%87%BA%E7%8E%B0Non-ASCII-character%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"/>
    <id>http://yoursite.com/2018/01/17/Python-中出现Non-ASCII-character的解决办法/</id>
    <published>2018-01-17T02:17:25.000Z</published>
    <updated>2018-01-18T06:19:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天开始为深度学习的基础做准备，遇到python的一个编码问题：</p><p><img src="/images/Non-ASCII_Character.png" alt=""><a id="more"></a></p><p>python解释器脚本默认编码是ASCII码的形式，而你却输入了汉字，即将文件格式转换为utf-8的形式了，当下的解释器无法正确翻译这样的格式</p><p>解决办法：(在程序源文件<strong>开头</strong> 加上以下任意一个转码方式)</p><ul><li><p>#coding=uft-8</p></li><li><p>#_*<em>coding:UTF-8\</em>*_</p></li></ul><p>这样就可以愉快得输出想要的结果了</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天开始为深度学习的基础做准备，遇到python的一个编码问题：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/Non-ASCII_Character.png&quot; alt=&quot;&quot;&gt;
    
    </summary>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
</feed>
