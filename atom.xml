<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>那一刻 风情万种</title>
  
  <subtitle>我喜欢看你笑的样子</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-03-12T17:28:06.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>那一刻 风情万种</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>C++面试问题准备：KMP算法</title>
    <link href="http://yoursite.com/2018/03/13/C-%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E5%87%86%E5%A4%87%EF%BC%9AKMP%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2018/03/13/C-面试问题准备：KMP算法/</id>
    <published>2018-03-12T16:35:13.000Z</published>
    <updated>2018-03-12T17:28:06.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在说KMP算法之前先说一下普通的模式匹配算法</p></blockquote><h2 id="BF蛮力算法–字符串匹配"><a href="#BF蛮力算法–字符串匹配" class="headerlink" title="BF蛮力算法–字符串匹配"></a>BF蛮力算法–字符串匹配</h2><font size="5">算法思想：</font><br><font color="#DC143C">从目标串T的的第一个字符起与模式串P的第一个字符比较<br>若相等，则继续对字符进行后续的比较<br>否则目标串从第二个字符起与模式串的第一个字符重新比较<br>直至模式串中的每个字符依次和目标串中的一个连续的字符序列相等为止，此时称为匹配成功，否则匹配失败</font> <a id="more"></a><br><br><font size="5">算法性能：</font><br><font color="#DC143C">假设模式串的长度是m，目标串的长度是n.<br>最坏情况即每次模式串都是在最后一个出现不等，最坏的时间复杂度为O(mn),因为其回溯比较，从而影响效率。<br><br>代码如下：<br><br><figure class="highlight hsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> bf_match(char *target,char * pattern) &#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">pos</span> = <span class="number">-1</span><span class="comment">;</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, k = <span class="number">0</span><span class="comment">;</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">pos</span> == <span class="number">-1</span> &amp;&amp; i &lt; <span class="keyword">strlen</span>(target)) &#123;</span><br><span class="line">        <span class="keyword">while</span>(j &lt; <span class="keyword">strlen</span>(pattern) &amp;&amp; target[i] == pattern[j]) &#123;</span><br><span class="line">            i ++<span class="comment">;</span></span><br><span class="line">            j ++<span class="comment">;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="keyword">strlen</span>(pattern)) <span class="comment">//扫描完，匹配成功，则让pos为开始匹配的下标</span></span><br><span class="line">            <span class="keyword">pos</span> = k<span class="comment">;</span></span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">//未扫描完，则模式串从头开始，目标串从下一个字符开始</span></span><br><span class="line">            j = <span class="number">0</span><span class="comment">;</span></span><br><span class="line">            k++<span class="comment">;</span></span><br><span class="line">            i = k<span class="comment">;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">pos</span><span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>## KMP–Knuth-Morris-Pratt算法：消除BF中的回溯<br><br><font size="5">算法思想：</font><br><font color="#DC143C"><br>(1) 计算跳转位置信息，这里我们称之为部分匹配表。<br>(2) 后移到指定位置，重新开始匹配。</font><p>这里 <strong><font color="#DC143C">部分匹配表</font></strong>的含义是在目标字符串中最大前缀和最大后缀所拥有相同字符的最大长度。</p><p>next数组的计算代码如下:</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> cal_next(<span class="keyword">char</span> *<span class="keyword">str</span>, <span class="keyword">int</span> *next, <span class="keyword">int</span> len)</span><br><span class="line">&#123;</span><br><span class="line">    next[<span class="number">0</span>] = <span class="number">-1</span>;<span class="comment">//next[0]初始化为-1，-1表示不存在相同的最大前缀和最大后缀</span></span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">-1</span>;<span class="comment">//k初始化为-1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> q = <span class="number">1</span>; q &lt;= len<span class="number">-1</span>; q++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (k &gt; <span class="number">-1</span> &amp;&amp; <span class="keyword">str</span>[k + <span class="number">1</span>] != <span class="keyword">str</span>[q])<span class="comment">//如果下一个不同，那么k就变成next[k]，注意next[k]是小于k的，无论k取任何值。</span></span><br><span class="line">        &#123;</span><br><span class="line">            k = next[k];<span class="comment">//往前回溯</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">str</span>[k + <span class="number">1</span>] == <span class="keyword">str</span>[q])<span class="comment">//如果相同，k++</span></span><br><span class="line">        &#123;</span><br><span class="line">            k = k + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        next[q] = k;<span class="comment">//这个是把算的k的值（就是相同的最大前缀和最大后缀长）赋给next[q]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>KMP代码如下:</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> KMP(<span class="keyword">char</span> *<span class="keyword">str</span>, <span class="keyword">int</span> slen, <span class="keyword">char</span> *ptr, <span class="keyword">int</span> plen)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> *next = <span class="keyword">new</span> <span class="keyword">int</span>[plen];</span><br><span class="line">    cal_next(ptr, next, plen);<span class="comment">//计算next数组</span></span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; slen; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (k &gt;<span class="number">-1</span>&amp;&amp; ptr[k + <span class="number">1</span>] != <span class="keyword">str</span>[i])<span class="comment">//ptr和str不匹配，且k&gt;-1（表示ptr和str有部分匹配）</span></span><br><span class="line">            k = next[k];<span class="comment">//往前回溯</span></span><br><span class="line">        <span class="keyword">if</span> (ptr[k + <span class="number">1</span>] == <span class="keyword">str</span>[i])</span><br><span class="line">            k = k + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (k == plen<span class="number">-1</span>)<span class="comment">//说明k移动到ptr的最末端</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//cout &lt;&lt; "在位置" &lt;&lt; i-plen+1&lt;&lt; endl;</span></span><br><span class="line">            <span class="comment">//k = -1;//重新初始化，寻找下一个</span></span><br><span class="line">            <span class="comment">//i = i - plen + 1;//i定位到该位置，外层for循环i++可以继续找下一个（这里默认存在两个匹配字符串可以部分重叠），感谢评论中同学指出错误。</span></span><br><span class="line">            <span class="keyword">return</span> i-plen+<span class="number">1</span>;<span class="comment">//返回相应的位置</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></font>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;在说KMP算法之前先说一下普通的模式匹配算法&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;BF蛮力算法–字符串匹配&quot;&gt;&lt;a href=&quot;#BF蛮力算法–字符串匹配&quot; class=&quot;headerlink&quot; title=&quot;BF蛮力算法–字符串匹配&quot;&gt;&lt;/a&gt;BF蛮力算法–字符串匹配&lt;/h2&gt;&lt;font size=&quot;5&quot;&gt;算法思想：&lt;/font&gt;&lt;br&gt;&lt;font color=&quot;#DC143C&quot;&gt;从目标串T的的第一个字符起与模式串P的第一个字符比较&lt;br&gt;若相等，则继续对字符进行后续的比较&lt;br&gt;否则目标串从第二个字符起与模式串的第一个字符重新比较&lt;br&gt;直至模式串中的每个字符依次和目标串中的一个连续的字符序列相等为止，此时称为匹配成功，否则匹配失败&lt;/font&gt;
    
    </summary>
    
      <category term="面试" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++面试问题准备：剑指 offer--丑数和两个链表的第一个公共结点</title>
    <link href="http://yoursite.com/2018/03/12/C-%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E5%87%86%E5%A4%87%EF%BC%9A%E5%89%91%E6%8C%87-offer-%E4%B8%91%E6%95%B0%E5%92%8C%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E7%BB%93%E7%82%B9/"/>
    <id>http://yoursite.com/2018/03/12/C-面试问题准备：剑指-offer-丑数和两个链表的第一个公共结点/</id>
    <published>2018-03-12T10:01:41.000Z</published>
    <updated>2018-03-12T16:15:11.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="两个链表的第一个公共结点"><a href="#两个链表的第一个公共结点" class="headerlink" title="两个链表的第一个公共结点"></a>两个链表的第一个公共结点</h2><blockquote><p>问题描述：输入两个链表，找出它们的第一个公共结点。</p></blockquote><p>这道题第一次很容易想到，在第一个链表上遍历每个结点的时候再在第二个链表顺序遍历所有的结点，如果第二个链表上有一个结点和第一个链表上的结点一样，则返回该结点。但是这样的遍历方式会导致时间复杂度为O(mn);<a id="more"></a></p><p>这样显然是不能让面试官满意的，那么分析两个链表具有公共结点的特点，即从该公共结点之后它们所有的结点都是重合的。我们可以考虑从后往前遍历链表，只需要找到最后一个不相同的结点，则该结点就是第一个公共结点。</p><p>代码如下:</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">listNode * findFirstCommonNode(listNode * head1, listNode * head2) &#123;</span><br><span class="line">    <span class="keyword">if</span> (head1 == <span class="keyword">NULL</span> || head2 == <span class="keyword">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">NULL</span>;</span><br><span class="line">    stack &lt;listNode &gt; s1,s2;</span><br><span class="line">    <span class="keyword">while</span>(head1 -&gt; <span class="keyword">next</span> != <span class="keyword">NULL</span>) &#123;</span><br><span class="line">        s1.<span class="keyword">push</span>(head1);</span><br><span class="line">        head1 = head1 -&gt; <span class="keyword">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="keyword">while</span>(head2 -&gt; <span class="keyword">next</span> != <span class="keyword">NULL</span>) &#123;</span><br><span class="line">         s1.<span class="keyword">push</span>(head2);</span><br><span class="line">         head1 = head2 -&gt; <span class="keyword">next</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">while</span>(!s1.empty() &amp;&amp; !s2.empty()) &#123;</span><br><span class="line">          <span class="keyword">int</span> result;</span><br><span class="line">          <span class="keyword">if</span> (s1.top() == s2.top()) &#123;</span><br><span class="line">            s1.<span class="keyword">pop</span>();</span><br><span class="line">            result = s2.top();</span><br><span class="line">            s2.<span class="keyword">pop</span>()</span><br><span class="line">          &#125; </span><br><span class="line">          <span class="keyword">else</span> </span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上一个方法需要两个辅助栈，如果链表的长度分别为m和n，那么空间复杂度是O(m+n)。这种思路的时间复杂度也是O(m+n)。和最开始的蛮力法相比，时间效率得到了提高，相当于是空间换时间。</p><p>接下来有一个更简单的办法：首先遍历两个链表得到它们的长度，就能知道哪个链表比较长，以及长的链表比短的链表多几个结点。在第二次遍历的时候，在较长的链表上先走若干步，接着同时在两个链表上遍历，找到的第一个相同的结点就是它们的第一个公共结点。</p><p>代码如下：<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">listNode * findFirstCommonNode(listNode * head1, listNode * head2) &#123;</span><br><span class="line">    unsigned <span class="keyword">int</span> length1 = getListLength(head1);</span><br><span class="line">    unsigned <span class="keyword">int</span> length2 = getListLength(head2);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> nLengthDif = length1 -length2;</span><br><span class="line">    listNode * listLong = head1;</span><br><span class="line">    listNode * listShort = head2;</span><br><span class="line">    <span class="keyword">if</span> (length2 &gt; length1) &#123;</span><br><span class="line">        listLong = head2;</span><br><span class="line">        listShort = head1;</span><br><span class="line">        nLengthDif = length2 -length1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//先从长链表走几步</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; nLengthDif; ++i) </span><br><span class="line">        listLong = listLong -&gt; <span class="keyword">next</span>;</span><br><span class="line">    <span class="keyword">while</span>(listLong != <span class="keyword">NULL</span> &amp;&amp; listShort != <span class="keyword">NULL</span> &amp;&amp; listLong != listShort) &#123;</span><br><span class="line">        listLong = listLong -&gt; <span class="keyword">next</span>;</span><br><span class="line">        listShort = listShort -&gt; <span class="keyword">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    listNode *first = listLong;</span><br><span class="line">     <span class="keyword">return</span> first;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> getListLength(listNode * head) &#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">NULL</span>) </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">count</span> = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(head -&gt; <span class="keyword">next</span> != <span class="keyword">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">count</span> ++;</span><br><span class="line">        head = head -&gt; <span class="keyword">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">count</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="丑数"><a href="#丑数" class="headerlink" title="丑数"></a>丑数</h2><blockquote><p>题目描述：我们把只包含因子2、3、5的数称作丑数。求按从小到大的顺序第1500个丑数。例如6、8都是丑数，但14不是，因为它包含因子7。习惯上我们把1当作第一个丑数。</p></blockquote><p>显然我们可以得到一个数如果能够连续被2整除、被3整除或者被5整除，最后结果余1，那么它就是丑数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isUgly</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(n % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">        n /= <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span>(n % <span class="number">3</span> == <span class="number">0</span>)</span><br><span class="line">        n /= <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">while</span>(n % <span class="number">5</span> == <span class="number">0</span>)</span><br><span class="line">        n /= <span class="number">5</span>;</span><br><span class="line">     <span class="keyword">if</span> (n == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getUglyNumber</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> uglyFound = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(uglyFound &lt; n) &#123;</span><br><span class="line">        i ++;</span><br><span class="line">        <span class="keyword">if</span> (isUgly(i))</span><br><span class="line">            uglyFound ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上段代码很直观得告诉我们指定题目的第n个丑数的计算过程。但是由于它会对每个非丑数也进行丑数的判断，从而导致算法效率不高。</p><p>此时我们可以采用方法2:<strong><font color="#DC143C">创建数组保存已经找到的丑数，用空间换时间的解法。</font></strong></p><p>即找到如何计算丑数的方法，而非判断丑数。我们可以创建一个数组，里面的数字是排好序的丑数，每一个丑数都是前面的丑数乘以2、3或5得到的。</p><p>这种思路的关键在于怎样确保数组里面的丑数是排好序的。假设数组中已经由若干丑数排好序后存放在数组中，并且已有最大的丑数计作M，我们接下来分析如何生成下一个丑数。该丑数一定是前面某一个丑数乘以2、3或5的结果，所以我们首先考虑把已有的每个丑数乘以2。在乘以2的时候，能得到若干个小于或等于M的结果。</p><p>代码如下：</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> getUglyNumber_Solution2(<span class="built_in">int</span> <span class="built_in">index</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">index</span> &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">int</span> *uglyNumbers = new <span class="built_in">int</span>[<span class="built_in">index</span>];</span><br><span class="line">    uglyNumbers[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">int</span> nextUglyIndex = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">int</span> *multiply2 = uglyNumbers;</span><br><span class="line">    <span class="built_in">int</span> *multiply3 = uglyNumbers;</span><br><span class="line">    <span class="built_in">int</span> *multiply5 = uglyNumbers;</span><br><span class="line">    <span class="keyword">while</span>(nextUglyIndex &lt; <span class="built_in">index</span>) &#123;</span><br><span class="line">        <span class="built_in">int</span> <span class="built_in">min</span> = <span class="built_in">Min</span>(*multiply2 * <span class="number">2</span> ,*multiply3 * <span class="number">3</span> ,*multiply5 * <span class="number">5</span>);</span><br><span class="line">        uglyNumbers[nextUglyIndex] = <span class="built_in">min</span>;</span><br><span class="line">        <span class="keyword">while</span>(*multiply2 * <span class="number">2</span> &lt;= uglyNumbers[nextUglyIndex])</span><br><span class="line">             multiply2 ++;</span><br><span class="line">        <span class="keyword">while</span>(*multiply3 * <span class="number">3</span> &lt;= uglyNumbers[nextUglyIndex])</span><br><span class="line">             multiply3 ++;</span><br><span class="line">        <span class="keyword">while</span>(*multiply5 * <span class="number">5</span> &lt;= uglyNumbers[nextUglyIndex])</span><br><span class="line">             multiply5 ++;</span><br><span class="line">        nextUglyIndex++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">int</span> ugly = uglyNumbers[nextUglyIndex - <span class="number">1</span>];</span><br><span class="line">    delete[] uglyNumbers;</span><br><span class="line">    <span class="keyword">return</span> ugly;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> <span class="built_in">min</span>(<span class="built_in">int</span> number1,<span class="built_in">int</span> number2,<span class="built_in">int</span> number3) &#123;</span><br><span class="line">    <span class="built_in">int</span> <span class="built_in">min</span> = (number1 &lt; number2) ? number1:number2;</span><br><span class="line">    <span class="built_in">min</span> = (<span class="built_in">min</span> &lt; number3) ? <span class="built_in">min</span>:number3;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">min</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;两个链表的第一个公共结点&quot;&gt;&lt;a href=&quot;#两个链表的第一个公共结点&quot; class=&quot;headerlink&quot; title=&quot;两个链表的第一个公共结点&quot;&gt;&lt;/a&gt;两个链表的第一个公共结点&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;问题描述：输入两个链表，找出它们的第一个公共结点。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这道题第一次很容易想到，在第一个链表上遍历每个结点的时候再在第二个链表顺序遍历所有的结点，如果第二个链表上有一个结点和第一个链表上的结点一样，则返回该结点。但是这样的遍历方式会导致时间复杂度为O(mn);
    
    </summary>
    
      <category term="面试" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>2018-03-11</title>
    <link href="http://yoursite.com/2018/03/11/2018-03-11/"/>
    <id>http://yoursite.com/2018/03/11/2018-03-11/</id>
    <published>2018-03-11T15:33:03.000Z</published>
    <updated>2018-03-12T01:36:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天是喜欢糖永永同学的第60天，在这60天里我知道了她的很多故事和经历。看到了她的各种表情，生气、难过、开心、犹豫、纠结、茫然、撒娇。。。我知道了她是一个非常非常感性的姑娘。<a id="more"></a></p><p>有人说，真正的爱是不会计算的。从来没有全心全意爱过一个人，从来没有想过一个人可以让我无时无刻不充满动力，又无时无刻不想念纠结。她在这60天里做到了，是的呢，虽然时间有点短，但是在这段时里我真正得陷入了她的漩涡。<br>我欣赏她对生活的态度，即使自己遍历鳞伤也不忘微笑对待这个世界；我喜欢她那种安静，表面平平淡淡，内心星月沉浮；我喜欢她洒脱的微笑，所有眼泪与痛苦都一笑而过（其实并没有-_-）；我喜欢她吃饭的样子，很慢很慢得吃了很多^_^。我特别喜欢看她，她笑起来很自然，如沐春风。<br>她现在能够接受我，但是她还没有答应我，因为她需要时间去淡化之前那段刻骨铭心的经历。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天是喜欢糖永永同学的第60天，在这60天里我知道了她的很多故事和经历。看到了她的各种表情，生气、难过、开心、犹豫、纠结、茫然、撒娇。。。我知道了她是一个非常非常感性的姑娘。
    
    </summary>
    
      <category term="日记" scheme="http://yoursite.com/categories/life/"/>
    
    
  </entry>
  
  <entry>
    <title>C++面试问题准备：如何实现守护进程</title>
    <link href="http://yoursite.com/2018/03/11/C-%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E5%87%86%E5%A4%87%EF%BC%9A%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B/"/>
    <id>http://yoursite.com/2018/03/11/C-面试问题准备：如何实现守护进程/</id>
    <published>2018-03-11T11:27:06.000Z</published>
    <updated>2018-03-12T01:36:58.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h3><p>守护进程也称精灵进程(Daemon)，是运行在后台的一种特殊进程。它独立于控制终端并且周期性的执行某种任务或等待处理某些发送的事件。Linux上的大多数服务器就是用守护进程实现的。 <a id="more"></a></p><blockquote><p>守护进程可以解决产生死锁的一个必要条件，资源独占问题。即可以实现间接线程资源共享，对于打印机来说我们不允许任何线程直接占有，而是设计一个”精灵程序”（守护进程）来管理。这个进程独占打印机，所有的打印任务都由它发出，任何一个线程想要打印，不是直接请求打印机，而是将打印要求发给这个守护进程指定的地方，这个守护进程将负责完成任务打印。</p></blockquote><p>Linux系统启动时会启动很多系统服务进程，这些系统服务进程没有控制终端，不能直接和用户交互。其他进程启东市都是在用户登录或运行程序是创建，在运行结束或用户注销时终止，但系统服务进程不受用户登录注销影响，他们一直运行着。这种进程就叫做守护进程(精灵进程)（Deamon）。 </p><p>如下图，一般守护进程会在程序运行名后面多一个d,但不是所有尾字母是d的都是守护进程。</p><p><img src="/images/linuxImages/deamon.png" alt=""></p><h3 id="创建守护进程"><a href="#创建守护进程" class="headerlink" title="创建守护进程"></a>创建守护进程</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">pid_t</span> setsid(<span class="keyword">void</span>); <span class="comment">//setid()创建成功后返回新建的会话ID，出错返回-1;</span></span><br></pre></td></tr></table></figure><p>所以我们在调用setsid()函数之前，必须先fork()创建父子进程，父子进程在同一个进程组中，父进程是组长进程，所以子进程符合条件，将父进程退出即可满足要求； </p><p>步骤：</p><p>1、调用umask()将文件模式创建屏蔽字设置为0；<br>2、调用fork，父进程退出。//1、保证守护进程不是进程组长<br>3、调用setsid创建一个会话。//setsid会导致：1、调用进程成为新会话的首进程，2、调用进程成为一个进程组的组长进程，3、调用进程没有控制终端。<br>4、将当前工作目录更改我根目录。//系统中除了跟目录都可以被删除<br>5、关闭不在需要的文件描述符<br>6、忽略SIGCHLD信号；</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;守护进程&quot;&gt;&lt;a href=&quot;#守护进程&quot; class=&quot;headerlink&quot; title=&quot;守护进程&quot;&gt;&lt;/a&gt;守护进程&lt;/h3&gt;&lt;p&gt;守护进程也称精灵进程(Daemon)，是运行在后台的一种特殊进程。它独立于控制终端并且周期性的执行某种任务或等待处理某些发送的事件。Linux上的大多数服务器就是用守护进程实现的。
    
    </summary>
    
      <category term="面试" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="OS" scheme="http://yoursite.com/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>C++面试问题准备：什么函数不能作为虚函数</title>
    <link href="http://yoursite.com/2018/03/11/C-%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E5%87%86%E5%A4%87%EF%BC%9A%E4%BB%80%E4%B9%88%E5%87%BD%E6%95%B0%E4%B8%8D%E8%83%BD%E4%BD%9C%E4%B8%BA%E8%99%9A%E5%87%BD%E6%95%B0/"/>
    <id>http://yoursite.com/2018/03/11/C-面试问题准备：什么函数不能作为虚函数/</id>
    <published>2018-03-11T07:22:28.000Z</published>
    <updated>2018-03-11T07:57:47.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong><font color="#DC143C">虚函数</font></strong></p><p>虚函数必须是类的非静态成员，即在类的成员函数生命中前面关键字为<code>virtual</code>的是虚函数。虚函数是为了实现的面向对象的多态（动态绑定）机制而提出来的。<br>即在程序运行过程中，进行对象所属类型的匹配，也是父类对象访问子类成员的方式。本质上还是为了实现代码复用以及项目的鲁棒性。<a id="more"></a></p><p>不能作为虚函数的函数如下：</p><ul><li>普通函数（非成员函数）</li></ul><blockquote><p>因为普通函数只能被overload，不能被override，也不能被继承，所以在编译的时候就绑定函数，所以不能申明为virtual，没有意义！</p></blockquote><ul><li>构造函数</li></ul><blockquote><p>主要因为构造函数是用来确定初始化对象的,virtual主要是为了在不了解具体的情况下实现动态绑定，调用不同类型中合适的成员函数而存在的，现在对象都没产生，怎么能实现多态呢。<br>构造函数不能被继承，所以不能virtual；</p></blockquote><ul><li>内联函数</li></ul><font color="#DC143C"><br>inline函数在编译时被展开，在调用处将整个函数替换为代码块，省去了函数跳转的时间，提高了SD，减少函数调用的开销，虚函数是为了继承后对象能够准确的调用自己的函数，执行相应的动作。</font><blockquote><p>inline函数是在编译时期展开的，而virtual函数是在运行时期进行动态绑定，所以两者执行时期不一样。、</p></blockquote><ul><li>静态成员函数</li></ul><blockquote><p>静态成员函数是类的组成部分，但是不是任何对象的组成部分，所有对象共享一份，没有必要动态绑定.而且静态成员函数只能访问静态变量，虽然说是可以继承，但是编译器却不会让它真正的继承，它只能作为整个类共有的成员。</p></blockquote><ul><li>友元函数</li></ul><blockquote><p>友员函数不是类的成员函数，C++不支持友员被继承，所以不能为virtual</p></blockquote><h5 id="综上可以作为虚函数的条件是"><a href="#综上可以作为虚函数的条件是" class="headerlink" title="综上可以作为虚函数的条件是"></a><strong>综上可以作为虚函数的条件是</strong></h5><font color="#DC143C"><br><br>1. 类的成员函数<br>2. 能被继承<br>3. 动态编译 </font><blockquote><p>空指针不能调用虚函数，因为虚指针（指向虚函数表）在类实例化时创建，没有创建对象就没有虚指针，那么用空指针调用虚函数就会崩溃。</p></blockquote><p>空指针可以访问普通的成员函数，但是该成员函数中不能调用类的成员变量，因为虽然知道了函数的入口地址，但是成员变量是在实例化的时候分配地址和空间的。所以如果该函数调用成员变量，指针会因为找不到而崩溃。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;&lt;font color=&quot;#DC143C&quot;&gt;虚函数&lt;/font&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;虚函数必须是类的非静态成员，即在类的成员函数生命中前面关键字为&lt;code&gt;virtual&lt;/code&gt;的是虚函数。虚函数是为了实现的面向对象的多态（动态绑定）机制而提出来的。&lt;br&gt;即在程序运行过程中，进行对象所属类型的匹配，也是父类对象访问子类成员的方式。本质上还是为了实现代码复用以及项目的鲁棒性。
    
    </summary>
    
      <category term="面试" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++面试问题准备:C++类的大小--sizeof(class)</title>
    <link href="http://yoursite.com/2018/03/11/C-%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E5%87%86%E5%A4%87-C-%E7%B1%BB%E7%9A%84%E5%A4%A7%E5%B0%8F-sizeof-class/"/>
    <id>http://yoursite.com/2018/03/11/C-面试问题准备-C-类的大小-sizeof-class/</id>
    <published>2018-03-11T06:18:40.000Z</published>
    <updated>2018-03-11T08:00:16.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="空类的大小"><a href="#空类的大小" class="headerlink" title="空类的大小"></a>空类的大小</h3><p><img src="/images/emptyClass.png" alt=""></p><p>为什么空的什么都没有是1呢？<a id="more"></a></p><blockquote><p>类的实例化就是在内存中分配一块地址，每个实例在内存中都有独一无二的地址。同样空类也会被实例化，所以编译器会给空类隐含的添加一个字节，这样空类实例化之后就有了独一无二的地址了。所以空类的sizeof为1。</p></blockquote><h3 id="一般非空类大小"><a href="#一般非空类大小" class="headerlink" title="一般非空类大小"></a>一般非空类大小</h3><p><img src="/images/generalNo.png" alt=""></p><blockquote><p>编译器为类中的数据成员分配一定的存储空间。实例化时类的地址拥有指向将数据成员的空间。同时因为内存对齐，所以该类的大小就是16(我电脑是64位系统，char * 大小为8字节)</p></blockquote><p>这里简单提一下32位和64位机器中数据类型的长度大小的不同</p><p>32位：</p><ul><li>char 1个字节</li><li>short 2个字节</li><li>int 4个字节</li><li>long 4个字节</li><li>long long 8个字节</li><li>指针  4个字节</li></ul><p>64位：</p><ul><li>char 1个字节</li><li>short 2个字节</li><li>int 4个字节</li><li>long 8个字节</li><li><font color="#DC143C">long long 8个字节</font></li><li><font color="#DC143C">指针 8个字节</font></li></ul><h3 id="有虚函数的类"><a href="#有虚函数的类" class="headerlink" title="有虚函数的类"></a>有虚函数的类</h3><p><img src="/images/virtualNo.png" alt=""></p><blockquote><p>这里类中如果有虚函数，编译器在类实例化的时候会创建一个虚函数表。所以此时该类实例的大小又多了一个指向虚函数表的指针。</p></blockquote><h3 id="有虚函数类的继承"><a href="#有虚函数类的继承" class="headerlink" title="有虚函数类的继承"></a>有虚函数类的继承</h3><p><img src="/images/virtualExtend.png" alt=""></p><blockquote><p>可见子类的大小是本身成员变量的大小加上父类的大小。</p></blockquote><h3 id="拥有静态变量的类"><a href="#拥有静态变量的类" class="headerlink" title="拥有静态变量的类"></a>拥有静态变量的类</h3><p><img src="/images/staticVariable.png" alt=""></p><blockquote><p>看到添加了静态变量的显示结果是和上一个显示的结果一样的。因为static变量对于整个类只有一份拷贝，且静态成员被编译器放在内存空间的全局存储区，但是在类实例化的时候只为类中的成员变量分配存储空间，所以它不会影响类的大小。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;空类的大小&quot;&gt;&lt;a href=&quot;#空类的大小&quot; class=&quot;headerlink&quot; title=&quot;空类的大小&quot;&gt;&lt;/a&gt;空类的大小&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;/images/emptyClass.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;为什么空的什么都没有是1呢？
    
    </summary>
    
      <category term="面试" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++面试问题准备：tcp/udp通信过程以及局域网内非阻塞的通信</title>
    <link href="http://yoursite.com/2018/03/11/C-%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E5%87%86%E5%A4%87%EF%BC%9Atcp-udp%E9%80%9A%E4%BF%A1%E8%BF%87%E7%A8%8B%E4%BB%A5%E5%8F%8A%E5%B1%80%E5%9F%9F%E7%BD%91%E5%86%85%E9%9D%9E%E9%98%BB%E5%A1%9E%E7%9A%84%E9%80%9A%E4%BF%A1/"/>
    <id>http://yoursite.com/2018/03/11/C-面试问题准备：tcp-udp通信过程以及局域网内非阻塞的通信/</id>
    <published>2018-03-11T04:52:45.000Z</published>
    <updated>2018-03-11T06:12:39.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="TCP和UDP协议的特点"><a href="#TCP和UDP协议的特点" class="headerlink" title="TCP和UDP协议的特点"></a>TCP和UDP协议的特点</h2><p><strong><font color="#DC143C">TCP</font></strong></p><ul><li>支持面向链接的传输服务（相当于人们打电话，需要先建立一个用来传输双方信息的链接）</li><li>支持字节流的传输（流模式 stream socket）</li><li>支持全双工通信（允许通信双方的应用程序在任何时候都可以发送数据）</li><li>支持建立多个并发的TCP链接</li><li>支持可靠的传输服务（提供确认／重传与拥塞控制功能）<a id="more"></a></li></ul><p><strong><font color="#DC143C">UDP</font></strong></p><ul><li>无连接、不可靠的传输层协议<ol><li>UDP协议在传输报文之前不需要在通信双方之间建立连接，因此减少了协议开销与传输延迟</li><li>UDP对报文除了提供一种可选的校验和之外，几乎没有提供其他的保证数据传输可靠性的措施</li><li>如果UDP协议检测处收到的分组出错，它就丢弃这个分组，既不确认，也不通知发送端和要求重传</li></ol></li><li>面向报文（数据报模式 datagram socket）<ol><li>UDP协议对于提交的报文，在添加了UDP头部，构成一个TPDU之后就向下提交给IP层</li><li>UDP协议对应用程序提交的报文既不合并，也不拆分，而是保留原报文的长度与格式。</li><li>对于UDP提交的报文长度应该设置合理，太短会使协议开销太大；太长，则UDP向IP层提交的TPDU可能在IP层会被分片，这样也会降低协议效率。</li></ol></li></ul><h2 id="TCP和UDP通信实现"><a href="#TCP和UDP通信实现" class="headerlink" title="TCP和UDP通信实现"></a>TCP和UDP通信实现</h2><p><strong><font color="#DC143C">TCP</font></strong></p><p><img src="/images/tcp.png" alt=""></p><blockquote><p>三次握手:<br>1.客户端发送一个syn段（同步序号）指明客户打算连接的服务器端口，以及初始化序号(ISN)，同时客户端进入”SYN-SEND”（状态）<br>2.服务器发回包含服务器的初始序号的SYN报文段作为应答。同时，将确认序号(ACK)设置为客户的ISN加1以对客户的SYN 报文段进行确认，同时服务端进入”SYN-RCVD”状态<br>3.客户必须将确认序号设置为服务器的ISN加1以对服务器的SYN报文段进行确认。此时客户端进入”ESTABLISHED”，而且服务端在接收到”ACK”报文之后也进入”ESTABLISHED”</p></blockquote><p><img src="/images/tcpThree.png" alt=""></p><p>TCP编程的服务器端一般步骤是： </p><ul><li>创建一个socket，用函数socket()； </li><li>设置socket属性，用函数setsockopt(); 可选</li><li>绑定IP地址、端口等信息到socket上，用函数bind(); </li><li>开启监听，用函数listen()； </li><li>接收客户端上来的连接，用函数accept()； </li><li>收发数据，用函数send()和recv()，或者read()和write(); </li><li>关闭网络连接； </li><li>关闭监听；</li></ul><p>TCP编程的客户端一般步骤是： </p><ul><li>创建一个socket，用函数socket()； </li><li>设置socket属性，用函数setsockopt();* 可选 </li><li>绑定IP地址、端口等信息到socket上，用函数bind();* 可选 </li><li>设置要连接的对方的IP地址和端口等属性； </li><li>连接服务器，用函数connect()； </li><li>收发数据，用函数send()和recv()，或者read()和write(); </li><li>关闭网络连接；</li></ul><p><strong><font color="#DC143C">UDP</font></strong></p><p><img src="/images/udp.png" alt=""></p><p>UDP编程的服务器端一般步骤是： </p><ul><li>创建一个socket，用函数socket()； </li><li>设置socket属性，用函数setsockopt();* 可选 </li><li>绑定IP地址、端口等信息到socket上，用函数bind(); </li><li>循环接收数据，用函数recvfrom(); </li><li>关闭网络连接；</li></ul><p>UDP编程的客户端一般步骤是： </p><ul><li>创建一个socket，用函数socket()； </li><li>设置socket属性，用函数setsockopt();* 可选 </li><li>绑定IP地址、端口等信息到socket上，用函数bind();* 可选 </li><li>设置对方的IP地址和端口等属性; </li><li>发送数据，用函数sendto(); </li><li>关闭网络连接</li></ul><p><strong><font color="#DC143C">TCP 连接实现代码</font></strong></p><p>server</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;//包含socket函数使用的各种协议族，send(),recv()  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;//调用linux系统函数的头文件(read(),write(),send()，select())  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PORT 7000  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IP <span class="meta-string">"127.0.0.1"</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">int</span> s;  </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servaddr</span>;</span>  </span><br><span class="line"><span class="keyword">socklen_t</span> len;  </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; li;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getConn</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;  </span><br><span class="line">        <span class="keyword">int</span> conn = accept(s, (struct sockaddr*)&amp;servaddr, &amp;len);<span class="comment">//第二个参数保存客户端套接字对应的IP地址和port 端口信息  </span></span><br><span class="line">        li.push_back(conn);  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, conn);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getData</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>;</span>  </span><br><span class="line">    tv.tv_sec = <span class="number">2</span>;  </span><br><span class="line">    tv.tv_usec = <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;  </span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator it;  </span><br><span class="line">        <span class="keyword">for</span>(it=li.begin(); it!=li.end(); ++it)&#123;  </span><br><span class="line">            fd_set rfds;  </span><br><span class="line">            FD_ZERO(&amp;rfds);  </span><br><span class="line">            <span class="keyword">int</span> maxfd = <span class="number">0</span>;  </span><br><span class="line">            <span class="keyword">int</span> retval = <span class="number">0</span>;  </span><br><span class="line">            FD_SET(*it, &amp;rfds);  </span><br><span class="line">            <span class="keyword">if</span>(maxfd &lt; *it)&#123;  </span><br><span class="line">                maxfd = *it;  </span><br><span class="line">            &#125;  </span><br><span class="line">            retval = select(maxfd+<span class="number">1</span>, &amp;rfds, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;tv);<span class="comment">//实现非阻塞式的通信，即需要等待时间的发生，一旦执行一定返回，返回的结果不同以表示函数执行的结果  </span></span><br><span class="line">            <span class="keyword">if</span>(retval == <span class="number">-1</span>)&#123;  </span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"select error\n"</span>);  </span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(retval == <span class="number">0</span>) &#123;  </span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;  </span><br><span class="line">                <span class="keyword">char</span> buf[<span class="number">1024</span>];  </span><br><span class="line">                <span class="built_in">memset</span>(buf, <span class="number">0</span> ,<span class="keyword">sizeof</span>(buf));  </span><br><span class="line">                <span class="keyword">long</span> len = recv(*it, buf, <span class="keyword">sizeof</span>(buf), <span class="number">0</span>);  </span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%s"</span>, buf);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        sleep(<span class="number">1</span>);  </span><br><span class="line">          </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sendMess</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;  </span><br><span class="line">        <span class="keyword">char</span> buf[<span class="number">1024</span>];  </span><br><span class="line">        fgets(buf, <span class="keyword">sizeof</span>(buf), <span class="built_in">stdin</span>);<span class="comment">//从文件流读取一行，送到缓冲区，使用时注意以下几点  </span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator it;  </span><br><span class="line">        <span class="keyword">for</span>(it=li.begin(); it!=li.end(); ++it)&#123;  </span><br><span class="line">            send(*it, buf, <span class="keyword">sizeof</span>(buf), <span class="number">0</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    s = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);  </span><br><span class="line">    <span class="built_in">memset</span>(&amp;servaddr, <span class="number">0</span>, <span class="keyword">sizeof</span>(servaddr));  </span><br><span class="line">    servaddr.sin_family = AF_INET;  </span><br><span class="line">    servaddr.sin_port = htons(PORT);  </span><br><span class="line">    servaddr.sin_addr.s_addr = inet_addr(IP);  </span><br><span class="line">    <span class="keyword">if</span>(bind(s, (struct sockaddr* ) &amp;servaddr, <span class="keyword">sizeof</span>(servaddr))==<span class="number">-1</span>) &#123;  </span><br><span class="line">        perror(<span class="string">"bind"</span>);  </span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">if</span>(listen(s, <span class="number">20</span>) == <span class="number">-1</span>) &#123;  </span><br><span class="line">        perror(<span class="string">"listen"</span>);  </span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    len = <span class="keyword">sizeof</span>(servaddr);  </span><br><span class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">t</span><span class="params">(getConn)</span></span>;  </span><br><span class="line">    t.detach();  </span><br><span class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">t1</span><span class="params">(sendMess)</span></span>;  </span><br><span class="line">    t1.detach();  </span><br><span class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">t2</span><span class="params">(getData)</span></span>;  </span><br><span class="line">    t2.detach();  </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;  </span><br><span class="line">          </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>client</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MYPORT  7000  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFFER_SIZE 1024  </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> sock_cli;  </span><br><span class="line">    fd_set rfds;  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>;</span><span class="comment">//设置时间  </span></span><br><span class="line">    <span class="keyword">int</span> retval, maxfd;  </span><br><span class="line">      </span><br><span class="line">    <span class="comment">///定义sockfd  </span></span><br><span class="line">    sock_cli = socket(AF_INET,SOCK_STREAM, <span class="number">0</span>);  </span><br><span class="line">    <span class="comment">///定义sockaddr_in  </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servaddr</span>;</span>  </span><br><span class="line">    <span class="built_in">memset</span>(&amp;servaddr, <span class="number">0</span>, <span class="keyword">sizeof</span>(servaddr));  </span><br><span class="line">    servaddr.sin_family = AF_INET;  </span><br><span class="line">    <span class="keyword">char</span> s[<span class="number">1024</span>];  </span><br><span class="line">    <span class="keyword">int</span> a;  </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"输入想要建立连接的端口号以及IP地址:"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;  </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a);  </span><br><span class="line">    getchar();  </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>,s);  </span><br><span class="line">    servaddr.sin_port = htons(a);  <span class="comment">///服务器端口，利用htons将主机字节顺序转换为网路字节数序从而进行数据包的传送  </span></span><br><span class="line">    servaddr.sin_addr.s_addr = inet_addr(s);  <span class="comment">///服务器ip  </span></span><br><span class="line">      </span><br><span class="line">    <span class="comment">//连接服务器，成功返回0，错误返回-1  </span></span><br><span class="line">    <span class="keyword">if</span> (connect(sock_cli, (struct sockaddr *)&amp;servaddr, <span class="keyword">sizeof</span>(servaddr)) &lt; <span class="number">0</span>)  </span><br><span class="line">    &#123;  </span><br><span class="line">        perror(<span class="string">"connect"</span>);  </span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;  </span><br><span class="line">        <span class="comment">/*把可读文件描述符的集合清空*/</span>  </span><br><span class="line">        FD_ZERO(&amp;rfds);  </span><br><span class="line">        <span class="comment">/*把标准输入的文件描述符加入到集合中*/</span>  </span><br><span class="line">        FD_SET(<span class="number">0</span>, &amp;rfds);  </span><br><span class="line">        maxfd = <span class="number">0</span>;  </span><br><span class="line">        <span class="comment">/*把当前连接的文件描述符加入到集合中*/</span>  </span><br><span class="line">        FD_SET(sock_cli, &amp;rfds);  </span><br><span class="line">        <span class="comment">/*找出文件描述符集合中最大的文件描述符*/</span>  </span><br><span class="line">        <span class="keyword">if</span>(maxfd &lt; sock_cli)  </span><br><span class="line">            maxfd = sock_cli;  </span><br><span class="line">        <span class="comment">/*设置超时时间*/</span>  </span><br><span class="line">        tv.tv_sec = <span class="number">5</span>;  </span><br><span class="line">        tv.tv_usec = <span class="number">0</span>;  </span><br><span class="line">        <span class="comment">/*等待聊天*/</span>  </span><br><span class="line">        retval = select(maxfd+<span class="number">1</span>, &amp;rfds, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;tv);<span class="comment">//int select(int maxfdp,fd_set *readfds,fd_set *writefds,fd_set *errorfds,struct timeval*timeout);  监视我们需要的文件的文件描述符的变化情况——读写或是异常  </span></span><br><span class="line">        <span class="keyword">if</span>(retval == <span class="number">-1</span>)&#123;  </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"select出错，客户端程序退出\n"</span>);  </span><br><span class="line">            <span class="keyword">break</span>;  </span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(retval == <span class="number">0</span>)&#123;<span class="comment">//超时  </span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"客户端没有任何输入信息，并且服务器也没有信息到来，waiting...\n"</span>);  </span><br><span class="line">            <span class="keyword">continue</span>;  </span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">//文件可进行读写或者出错  </span></span><br><span class="line">            <span class="comment">/*服务器发来了消息*/</span>  </span><br><span class="line">            <span class="keyword">if</span>(FD_ISSET(sock_cli,&amp;rfds))&#123;  </span><br><span class="line">                <span class="keyword">char</span> recvbuf[BUFFER_SIZE];  </span><br><span class="line">                <span class="keyword">long</span> len;  </span><br><span class="line">                len = recv(sock_cli, recvbuf, <span class="keyword">sizeof</span>(recvbuf),<span class="number">0</span>);  </span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%s"</span>, recvbuf);  </span><br><span class="line">                <span class="built_in">memset</span>(recvbuf, <span class="number">0</span>, <span class="keyword">sizeof</span>(recvbuf));  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="comment">/*用户输入信息了,开始处理信息并发送*/</span>  </span><br><span class="line">            <span class="keyword">if</span>(FD_ISSET(<span class="number">0</span>, &amp;rfds))&#123;  </span><br><span class="line">                <span class="keyword">char</span> sendbuf[<span class="number">1024</span>];  </span><br><span class="line"><span class="comment">//                scanf("%s",sendbuf);  </span></span><br><span class="line">                fgets(sendbuf, <span class="keyword">sizeof</span>(sendbuf), <span class="built_in">stdin</span>);  </span><br><span class="line">                send(sock_cli, sendbuf, <span class="built_in">strlen</span>(sendbuf),<span class="number">0</span>); <span class="comment">//发送  </span></span><br><span class="line">                <span class="built_in">memset</span>(sendbuf, <span class="number">0</span>, <span class="keyword">sizeof</span>(sendbuf));  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    close(sock_cli);  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在终端下分别编译运行结果显示如下：</p><p><img src="/images/result.png" alt=""></p><blockquote><p>安利一个函数，<code>int select(int maxfdp,fd_set *readfds,fd_set *writefds,fd_set *errorfds,struct timeval *timeout);</code>.也是以上程序用到的函数。<br>因为在TCP通信中所用到的accept(),connect(),recv(),send()函数都是阻塞式通信（虽然阻塞的概念是针对S端,但是我们在建立连接后都可以作为发送端和接受端，所以这个概念是可以用在这里的），即我必须在这里等待我的调用结果，也就是如果S端没有发送信息，我的进程就会一直等待，直到recv()可以接受到结果才开始继续运行。<br>但是select()函数确可以让我们进行不用等待的通信，即程或线程执行此函数时不必非要等待接受消息。一旦该函数执行肯定返回，以返回值的不同来反映函数的执行情况，如果有接受到消息则与阻塞方式相同，若没有接收到消息则返回一个代码来告知事件未发生，而进程或线程继续执行。它的最后一个参数可以用来作为超时检测，即很长时间没有信息互动，那么接受端会弹出一条信息来告知目前你没有发送信息，是否发送端出现传输问题。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;TCP和UDP协议的特点&quot;&gt;&lt;a href=&quot;#TCP和UDP协议的特点&quot; class=&quot;headerlink&quot; title=&quot;TCP和UDP协议的特点&quot;&gt;&lt;/a&gt;TCP和UDP协议的特点&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;&lt;font color=&quot;#DC143C&quot;&gt;TCP&lt;/font&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;支持面向链接的传输服务（相当于人们打电话，需要先建立一个用来传输双方信息的链接）&lt;/li&gt;
&lt;li&gt;支持字节流的传输（流模式 stream socket）&lt;/li&gt;
&lt;li&gt;支持全双工通信（允许通信双方的应用程序在任何时候都可以发送数据）&lt;/li&gt;
&lt;li&gt;支持建立多个并发的TCP链接&lt;/li&gt;
&lt;li&gt;支持可靠的传输服务（提供确认／重传与拥塞控制功能）
    
    </summary>
    
      <category term="面试" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="网络通信" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/"/>
    
  </entry>
  
  <entry>
    <title>C++面试问题准备：阻塞和非阻塞、同步和异步</title>
    <link href="http://yoursite.com/2018/03/10/C-%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E5%87%86%E5%A4%87%EF%BC%9A%E9%98%BB%E5%A1%9E%E5%92%8C%E9%9D%9E%E9%98%BB%E5%A1%9E%E3%80%81%E5%90%8C%E6%AD%A5%E5%92%8C%E5%BC%82%E6%AD%A5/"/>
    <id>http://yoursite.com/2018/03/10/C-面试问题准备：阻塞和非阻塞、同步和异步/</id>
    <published>2018-03-10T14:11:46.000Z</published>
    <updated>2018-03-11T08:01:28.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="同步和异步主要针对C端"><a href="#同步和异步主要针对C端" class="headerlink" title="同步和异步主要针对C端"></a>同步和异步主要针对C端</h2><h3 id="同步"><a href="#同步" class="headerlink" title="同步"></a><strong><font color="#DC143C">同步</font></strong></h3><p>所谓同步，就是在c端发出一个功能调用时，在没有得到结果之前，该调用就不返回。也就是必须一件一件事做,等前一件做完了才能做下一件事。 <a id="more"></a></p><blockquote><p>例如普通B/S模式（同步）：提交请求-&gt;等待服务器处理-&gt;处理完毕返回 这个期间客户端浏览器不能干任何事</p></blockquote><h3 id="异步"><a href="#异步" class="headerlink" title="异步"></a><strong><font color="#DC143C">异步</font></strong></h3><p>当c端一个异步过程调用发出后，调用者不能立刻得到结果。实际处理这个调用的部件在完成后，通过状态、通知和回调来通知调用者。</p><blockquote><p>例如 ajax请求（异步）: 请求通过事件触发-&gt;服务器处理（这时浏览器仍然可以作其他事情）-&gt;处理完毕</p></blockquote><h2 id="阻塞和非阻塞针对S端"><a href="#阻塞和非阻塞针对S端" class="headerlink" title="阻塞和非阻塞针对S端"></a>阻塞和非阻塞针对S端</h2><h3 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a><strong><font color="#DC143C">阻塞</font></strong></h3><p>阻塞调用是指调用结果返回之前，当前线程会被挂起（线程进入非可执行状态，在这个状态下，cpu不会给线程分配时间片，即线程暂停运行）。函数只有在得到结果之后才会返回</p><blockquote><p>比如到你某个时候到A楼一层（假如是内核缓冲区）取快递，但是你不知道快递什么时候过来，你又不能干别的事，只能死等着。但你可以睡觉（进程处于休眠状态），因为你知道快递把货送来时一定会给你打个电话（假定一定能叫醒你）。</p></blockquote><h3 id="非阻塞"><a href="#非阻塞" class="headerlink" title="非阻塞"></a><strong><font color="#DC143C">非阻塞</font></strong></h3><p>在不能立刻得到结果之前，该函数不会阻塞当前线程，而会立刻返回</p><blockquote><p>还是等快递的例子：如果用忙轮询的方法，每隔5分钟到A楼一层(内核缓冲区）去看快递来了没有。如果没来，立即返回。而快递来了，就放在A楼一层，等你去取</p></blockquote><p>综上：</p><p>同步  就是我客户端（c端调用者）调用一个功能，该功能没有结束前，我（c端调用者）死等结果<br>异步  就是我（c端调用者）调用一个功能，不需要知道该功能结果，该功能有结果后通知我（c端调用者）即回调通知。<br>阻塞  就是调用我（s端被调用者，函数），我（s端被调用者，函数）没有接收完数据或者没有得到结果之前，我不会返回。<br>非阻塞 就是调用我（s端被调用者，函数），我（s端被调用者，函数）立即返回，通过select通知调用者</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;同步和异步主要针对C端&quot;&gt;&lt;a href=&quot;#同步和异步主要针对C端&quot; class=&quot;headerlink&quot; title=&quot;同步和异步主要针对C端&quot;&gt;&lt;/a&gt;同步和异步主要针对C端&lt;/h2&gt;&lt;h3 id=&quot;同步&quot;&gt;&lt;a href=&quot;#同步&quot; class=&quot;headerlink&quot; title=&quot;同步&quot;&gt;&lt;/a&gt;&lt;strong&gt;&lt;font color=&quot;#DC143C&quot;&gt;同步&lt;/font&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;所谓同步，就是在c端发出一个功能调用时，在没有得到结果之前，该调用就不返回。也就是必须一件一件事做,等前一件做完了才能做下一件事。
    
    </summary>
    
      <category term="面试" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="OS" scheme="http://yoursite.com/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>C++面试问题准备：Linux下GDB命令调试程序</title>
    <link href="http://yoursite.com/2018/03/10/C-%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E5%87%86%E5%A4%87%EF%BC%9ALinux%E4%B8%8BGDB%E5%91%BD%E4%BB%A4%E8%B0%83%E8%AF%95%E7%A8%8B%E5%BA%8F/"/>
    <id>http://yoursite.com/2018/03/10/C-面试问题准备：Linux下GDB命令调试程序/</id>
    <published>2018-03-10T12:46:32.000Z</published>
    <updated>2018-03-10T14:36:25.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>GDB是一个由GNU开源组织发布的、UNIX/LINUX操作系统下的、基于命令行的、功能强大的程序调试工具。<br> GDB中的命令固然很多，但我们只需掌握其中十个左右的命令，就大致可以完成日常的基本的程序调试工作</p></blockquote> <a id="more"></a><p>命令参数：</p><ul><li>file &lt;文件名&gt;：加载被调试的可执行程序文件。因为一般都在被调试程序所在目录下执行GDB，因而文本名不需要带路径。</li><li>r：Run的简写，运行被调试的程序。如果此前没有下过断点，则执行完整个程序；如果有断点，则程序暂停在第一个可用断点处</li><li>c：Continue的简写，继续执行被调试程序，直至下一个断点或程序结束。</li><li>b：Breakpoint的简写，设置断点。两可以使用“行号”“函数名称”“执行地址”等方式指定断点位置。</li><li>s, n：s–执行一行源程序代码，如果此行代码中有函数调用，则进入该函数，相当于其他调试器中的”step into”（单步跟踪进入)<br>n–执行一行源程序代码，此行代码中的函数调用也一并执行。相当于其它调试器中的“Step Over (单步跟踪)”</li><li>si, ni：si命令类似于s命令，ni命令类似于n命令。所不同的是，这两个命令（si/ni）所针对的是汇编指令，而s/n针对的是源代码。</li><li>display／undisplay：display，设置程序中断后欲显示的数据及其格式。例如，如果希望每次程序中断后可以看到即将被执行的下一条汇编指令，可以使用命令<code>display /i $pc</code>.其中 $pc 代表当前汇编指令，/i 表示以十六进行显示。当需要关心汇编代码时，此命令相当有用</li><li>i：Info的简写，用于显示各类信息，详情请查阅“help i”。例如查看添加断点信息命令：<code>i b</code></li><li>q：Quit的简写，退出GDB调试环境。</li><li>help：GDB帮助命令，提供对GDB名种命令的解释说明。如果指定了“命令名称”参数，则显示该命令的详细说明；如果没有指定参数，则分类显示所有GDB命令，供用户进一步浏览和查询。<code>help display</code></li></ul><p>接下来进行实践，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">andFunction</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Andfunction is called,a = %d,b = %d"</span>,a,b);</span><br><span class="line">    <span class="keyword">return</span> (a + b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> n = andFunction(a,b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"main is called. result is %d"</span>,n);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将该函数在终端下编译：</p><p><code>vim testGDBFunction.c</code> 创建’.c’文件</p><p><img src="/images/linuxImages/vim.png" alt=""></p><p><code>gcc -g -Wall -o testGDBFunction testGDBFunction.c</code> 以’-g’形式编译，结果方便gdb调试。或者也可以运行命令<code>gcc -g testGDBFunction.c -o testGDBFunction</code></p><p><img src="/images/linuxImages/gcc.png" alt=""></p><p><code>gdb testGDBFunction</code></p><p><img src="/images/linuxImages/gdbProgram.png" alt=""></p><p><code>r</code>运行’-r’</p><p><img src="/images/linuxImages/run.png" alt=""></p><p><code>b main</code>和<code>b addFunction</code> 在该函数处设置断点</p><p><img src="/images/linuxImages/breakDown.png" alt=""></p><p><code>info b</code>显示断点信息</p><p><img src="/images/linuxImages/info.png" alt=""></p><p><code>s</code> step单步进入跟踪</p><p><img src="/images/linuxImages/step.png" alt=""></p><p><code>si</code>和<code>ni</code>单步执行且显示汇编指令</p><p><img src="/images/linuxImages/siAdnNi.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;GDB是一个由GNU开源组织发布的、UNIX/LINUX操作系统下的、基于命令行的、功能强大的程序调试工具。&lt;br&gt; GDB中的命令固然很多，但我们只需掌握其中十个左右的命令，就大致可以完成日常的基本的程序调试工作&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="面试" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>C++面试问题准备：剑指 offer--第一个只出现一次的字符和数组中的逆序对</title>
    <link href="http://yoursite.com/2018/03/10/C-%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E5%87%86%E5%A4%87%EF%BC%9A%E5%89%91%E6%8C%87-offer-%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6%E5%92%8C%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9/"/>
    <id>http://yoursite.com/2018/03/10/C-面试问题准备：剑指-offer-第一个只出现一次的字符和数组中的逆序对/</id>
    <published>2018-03-10T06:53:12.000Z</published>
    <updated>2018-03-10T09:12:01.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第一个只出现一次的字符"><a href="#第一个只出现一次的字符" class="headerlink" title="第一个只出现一次的字符"></a>第一个只出现一次的字符</h2><blockquote><p>题目描述：在字符中找出第一个只出现一次的字符。例如输入”abaccdeff”,则输出”b”;</p></blockquote><p>看到这个题目我们最直接的想法是从头到尾扫描这个字符串，当访问到某个字符时拿这个字符和后面的每个字符进行比较，如果在后面没有出现该字符，那么这个字符就是所要求的。但是每个字符都要与后面O(n)个字符进行比较，这样时间复制度就为o(n^2);<a id="more"></a></p><p>由于题目与出现字符的次数相关，我们便可以统计每个字符在该字符串中出现的次数？要达到这个目的，我们需要一个数据容器来存放每个字符出现的次数。在这个容器中，我们可以根据字符来查找它出现的次数，也就是这个容器的作用是把一个字符映射为一个数字。而哈希表就是这样一个容器。</p><p>由于SGI STL中还未添加hash table，我们需要考虑自己去实现。字符是一个长度为8的数据类型，因此总共需要256种可能，于是我们创建一个长度为256的数组，每个字母根据其ASCII码值作为数组的下标对应数组的一个数字，而数组中存储的是每个字符出现的次数。这样我们就创建了一个大小为256，以字符ASCII码为键值的哈希表。</p><p><strong><font color="#DC143C">第一次扫描时，在哈希表中更新一个字符出现的次数的时间是O(1)。如果字符串长度为n,那么第一次扫描的时间复杂度是O(n)。第二个扫描时，同样O(1)能读出一个字符出现的次数，所以时间复杂度仍然是O(n)。这样算起来总的时间复杂度是O(n)。</font></strong></p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">firstNotRepeatingChar</span><span class="params">(<span class="keyword">char</span> * pString)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pString == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'\0'</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> tableSize = <span class="number">256</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> hashTable[tableSize];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tableSize; ++i)</span><br><span class="line">        hashTable[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> *hashKey = pString;</span><br><span class="line">    <span class="keyword">while</span>(*(hashKey) != <span class="string">'\0'</span>)<span class="comment">//O(n)</span></span><br><span class="line">        hashTable[*(hashKey ++)] ++;</span><br><span class="line">    hashKey = pString;</span><br><span class="line">    <span class="keyword">while</span>(*(hashKey) != <span class="string">'\0'</span>) &#123;<span class="comment">//O(n)</span></span><br><span class="line">        <span class="keyword">if</span> (hashTable[*hashKey] == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> *hashKey;</span><br><span class="line">        hashKey ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'\0'</span>;<span class="comment">//没有出现一次的返回空</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数组中的逆序对"><a href="#数组中的逆序对" class="headerlink" title="数组中的逆序对"></a>数组中的逆序对</h2><blockquote><p>题目描述：在数组中的两个数字如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数字，求出这个数组中的逆序对的总数。</p></blockquote><p>刚看到这个题目的时候我们的第一反应是，从头到尾扫描这个数组，访问到某个数字的时候遍历后面的数字是否满足逆序对的条件，并让逆序对的总数加一。这样的话每个数字都要和O（n）个数字比较，最后这个算法时间复杂度是O(n^2).</p><p>此时为了降低时间复杂度，我们不能拿一个数字和其后的数字进行比较,我们可以让相邻的两个数字进行比较。</p><p>如下：</p><p><img src="/images/nixu01.jpg" alt=""></p><p>我们先把数组分解成两个长度为 2的子数组，再把这两个子数组分别拆分成两个长度为 1 的子数组。接下来一边合并相邻的子数组，一边统计逆序对的数目。在第一对长度为 1 的子数组{7}、{5}中7大于5，因此（7,5）组成一个逆序对。同样在第二对长度为1的子数组{6}、{4}中也有逆序对（6,4）。由于我们已经统计了这两对子数组内部的逆序对，因此需要把这两对子数组排序（如上图所示），以免在以后的统计过程中再重复统计。</p><p><img src="/images/nixu02.jpg" alt=""></p><p>接下来对第一张图d合并过程细分，如上图我们先用两个指针分别指向两个子数组的末尾，并每次比较两个指针指向的数字。如果第一个子数组中的数字大于第二个子数组中的数字，则构成逆序对，并且逆序对的数目等于第二个子数组中剩余数字的个数（如图（a）和图（c）所示）。如果第一个数组中的数字小于或等于第二个数组中的数字，则不构成逆序对（如图（b）所示）。每一次比较的时候，我们都把较大的数字从后往前复制到一个辅助数组中去，确保辅助数组中的数字是递增排序的。在把较大的数字复制到辅助数组之后，把对应的指针向前移动一位，接下来进行下一轮比较。</p><p>最后总结如下:</p><p><strong><font color="#DC143C">先把数组分隔成子数组，先统计出子数组内部的逆序对数目，然后再统计出两个相邻子数组之间的逆序对数目。在统计逆序对的过程中，还需要对数组进行排序，当然很明显这个排序的过程是归并排序</font></strong></p><p>代码如下：</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> inverseParis(<span class="built_in">int</span> *<span class="keyword">data</span>, <span class="built_in">int</span> length) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">data</span> == NULL || length &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">int</span> *copy = <span class="keyword">data</span>;</span><br><span class="line">    for (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; length; ++i)</span><br><span class="line">        copy[i] = <span class="keyword">data</span>[i];</span><br><span class="line">    <span class="built_in">int</span> <span class="built_in">count</span> = inverseParisCore(<span class="keyword">data</span>, copy, <span class="number">0</span>, lenght -<span class="number">1</span>);</span><br><span class="line">    delete copy[];</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">count</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> inverseParisCore(<span class="built_in">int</span> * <span class="keyword">data</span>, <span class="built_in">int</span> *copy, <span class="built_in">int</span> start, <span class="built_in">int</span> <span class="keyword">end</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (start == <span class="keyword">end</span>) &#123;</span><br><span class="line">        copy[start] = <span class="keyword">data</span>[start];</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">   <span class="built_in">int</span> length = (<span class="keyword">end</span> - start) / <span class="number">2</span>;</span><br><span class="line">   <span class="built_in">int</span> left = inverseParisCore(copy,<span class="keyword">data</span>,start,length);</span><br><span class="line">   <span class="built_in">int</span> right = inverseParisCore(copy,<span class="keyword">data</span>,start + length + <span class="number">1</span>, <span class="keyword">end</span>);</span><br><span class="line">   </span><br><span class="line">   <span class="built_in">int</span> i = start + length;</span><br><span class="line">   <span class="built_in">int</span> j = <span class="keyword">end</span>;</span><br><span class="line">   </span><br><span class="line">   <span class="built_in">int</span> copyIndex = <span class="keyword">end</span>;</span><br><span class="line">   <span class="built_in">int</span> <span class="built_in">count</span> = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">while</span>(i &gt;= start &amp;&amp; j &gt;= start + length + <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">data</span>[i] &gt; <span class="keyword">data</span>[j]) &#123;</span><br><span class="line">            copy[copyIndex --] = <span class="keyword">data</span>[i - <span class="number">1</span>];</span><br><span class="line">            <span class="built_in">count</span> += j - start - length;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            copy[copyIndex --] = <span class="keyword">data</span>[j--];</span><br><span class="line">        &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   for (; i &gt;= start; --i)</span><br><span class="line">        copy[copyIndex --] = <span class="keyword">data</span>[i];</span><br><span class="line">   for (; j &gt;= start + length + <span class="number">1</span>; --j)</span><br><span class="line">        copy[copyIndex --] = <span class="keyword">data</span>[j];</span><br><span class="line">        </span><br><span class="line">   retrun <span class="built_in">count</span>;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong><font color="#DC143C">归并排序算法思想：</font></strong></p><ul><li>分解：将当前区间一分为二，即求分裂点</li><li>求解：递归地对两个子区间R[low..mid]和R[mid+1..high]进行归并排序</li><li>组合：将已排序的两个子区间R[low..mid]和R[mid+1..high]归并为一个有序的区间R[low..high]</li></ul></blockquote><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> mergeSort(<span class="keyword">int</span> *a, <span class="keyword">int</span> start, <span class="keyword">int</span> <span class="built_in">end</span>) &#123;</span><br><span class="line">    <span class="built_in">if</span> (a == NULL || (<span class="built_in">end</span> - start) &lt;=<span class="number">0</span>)</span><br><span class="line">        <span class="built_in">return</span>;</span><br><span class="line">    <span class="built_in">if</span> ((<span class="built_in">end</span> - start) == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">if</span> (a[start] &gt; a[<span class="built_in">end</span>]) &#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = a[start];</span><br><span class="line">            a[start] = a[<span class="built_in">end</span>];</span><br><span class="line">            a[<span class="built_in">end</span>] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (<span class="built_in">end</span> + start) / <span class="number">2</span>;</span><br><span class="line">        merge_sort(a, start,mid);</span><br><span class="line">        merge_sort(a, mid + <span class="number">1</span>, <span class="built_in">end</span>);</span><br><span class="line">        merge(a,start,mid,<span class="built_in">end</span>); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> Merge(<span class="keyword">int</span> *a, <span class="keyword">int</span> p, <span class="keyword">int</span> q, <span class="keyword">int</span> r)  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="keyword">int</span> n1 = q-p+<span class="number">1</span>;  </span><br><span class="line">    <span class="keyword">int</span> n2 = r-q;  </span><br><span class="line">    <span class="keyword">int</span> *L = <span class="keyword">new</span> <span class="keyword">int</span>[n1+<span class="number">1</span>];  </span><br><span class="line">    <span class="keyword">int</span> *R = <span class="keyword">new</span> <span class="keyword">int</span>[n2+<span class="number">1</span>];  </span><br><span class="line">    <span class="keyword">int</span> i, j, k;  </span><br><span class="line">    <span class="comment">//创建两个子数组，并将左右区间内的值分别复制进去</span></span><br><span class="line">    <span class="built_in">for</span> (i=<span class="number">0</span>; i&lt;n1; i++)&#123;  </span><br><span class="line">        L[i] = a[p+i];  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="built_in">for</span> (j=<span class="number">0</span>; j&lt;n2; j++)&#123;  </span><br><span class="line">        R[j] = a[q+j+<span class="number">1</span>];  </span><br><span class="line">    &#125;  </span><br><span class="line">    L[n1] = <span class="number">10000000</span>;  </span><br><span class="line">    R[n2] = <span class="number">10000000</span>;  </span><br><span class="line">    <span class="comment">//合并</span></span><br><span class="line">    <span class="built_in">for</span> (i=<span class="number">0</span>, j=<span class="number">0</span>, k=p; k&lt;=r; k++)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="built_in">if</span> (L[i]&lt;=R[j])  </span><br><span class="line">        &#123;  </span><br><span class="line">            a[k] = L[i];  </span><br><span class="line">            i++;  </span><br><span class="line">        &#125;<span class="built_in">else</span>&#123;  </span><br><span class="line">            a[k] = R[j];  </span><br><span class="line">            j++;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">delete</span> []L;  </span><br><span class="line">    <span class="keyword">delete</span> []R;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;第一个只出现一次的字符&quot;&gt;&lt;a href=&quot;#第一个只出现一次的字符&quot; class=&quot;headerlink&quot; title=&quot;第一个只出现一次的字符&quot;&gt;&lt;/a&gt;第一个只出现一次的字符&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;题目描述：在字符中找出第一个只出现一次的字符。例如输入”abaccdeff”,则输出”b”;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;看到这个题目我们最直接的想法是从头到尾扫描这个字符串，当访问到某个字符时拿这个字符和后面的每个字符进行比较，如果在后面没有出现该字符，那么这个字符就是所要求的。但是每个字符都要与后面O(n)个字符进行比较，这样时间复制度就为o(n^2);
    
    </summary>
    
      <category term="面试" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++面试问题准备：剑指 offer--在O(1)时间删除链表结点和打印1到最大的n位数</title>
    <link href="http://yoursite.com/2018/03/10/C-%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E5%87%86%E5%A4%87%EF%BC%9A%E5%89%91%E6%8C%87-offer-%E5%9C%A8O-1-%E6%97%B6%E9%97%B4%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%BB%93%E7%82%B9%E5%92%8C%E6%89%93%E5%8D%B01%E5%88%B0%E6%9C%80%E5%A4%A7%E7%9A%84n%E4%BD%8D%E6%95%B0/"/>
    <id>http://yoursite.com/2018/03/10/C-面试问题准备：剑指-offer-在O-1-时间删除链表结点和打印1到最大的n位数/</id>
    <published>2018-03-10T05:12:36.000Z</published>
    <updated>2018-03-10T09:08:08.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="在O-1-时间内删除链表结点"><a href="#在O-1-时间内删除链表结点" class="headerlink" title="在O(1)时间内删除链表结点"></a>在O(1)时间内删除链表结点</h2><blockquote><p>题目描述：给定单向链表的头指针和一个结点指针，定义一个函数在O(1)时间删除该结点</p></blockquote><p>在单向链表中删除一个结点最常规的做法无疑是从链表的头结点开始，顺序遍历查找要删除的结点，并在链表中删除该结点。<a id="more"></a></p><p>但是这种删除方式需要遍历整个链表，时间复杂度为O（n）.</p><p>为了获得O(1)的时间复杂度，我们可以使用如下方法：</p><p><img src="/images/deleteList.jpg" alt=""></p><p><strong><font color="#DC143C">把结点j的内容覆盖结点i,接下来把结点i的next指向j的下一个结点之后删除结点j。这样就不需要遍历出结点i的上一个结点。</font></strong></p><blockquote><p>注意问题：如果链表中只有一个结点，而我们要删除的结点就是头结点，删除之后还需要把链表的头结点设置为NULL。如果存在多个链表结点，要删除的结点在链表尾部，我们可以先找到该结点的前序结点，并完成删除操作。</p></blockquote><p>代码如下:</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> deleteNode(listNode * head,listNode  toBeDeleted) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!head || !toBeDeleted)</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    <span class="comment">//覆盖</span></span><br><span class="line">    <span class="keyword">if</span> (toBeDeleted -&gt; <span class="keyword">next</span> != <span class="keyword">NULL</span>) &#123;</span><br><span class="line">        listNode * pNext = toBeDeleted -&gt; <span class="keyword">next</span>;</span><br><span class="line">        toBeDeleted -&gt; value = pNext -&gt; value;</span><br><span class="line">        toBeDeleted -&gt; <span class="keyword">next</span> = pNext -&gt; <span class="keyword">next</span>;</span><br><span class="line">        <span class="keyword">delete</span> pNext;</span><br><span class="line">        pNext = <span class="keyword">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//头结点是要被删除的</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (head == toBeDeleted) &#123;</span><br><span class="line">        <span class="keyword">delete</span> toBeDeleted;</span><br><span class="line">        head = <span class="keyword">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        listNode * pNext = head;</span><br><span class="line">        <span class="keyword">while</span>(pNext -&gt; <span class="keyword">next</span> != toBeDeleted)</span><br><span class="line">            pNext = pNext -&gt; <span class="keyword">next</span>;</span><br><span class="line">        pNext -&gt; <span class="keyword">next</span> = <span class="keyword">NULL</span>;</span><br><span class="line">        <span class="keyword">delete</span> toBeDeleted;</span><br><span class="line">        toBeDeleted = <span class="keyword">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="打印1到最大的n位数"><a href="#打印1到最大的n位数" class="headerlink" title="打印1到最大的n位数"></a>打印1到最大的n位数</h3><blockquote><p>题目描述：输入数字n,按照顺序打印出从1到最大的n位十进制数。比如输入3，则打印出1、2、3一直到最大的3位数即999。</p></blockquote><p>这是一个较大的陷阱，如果说我们不去考虑数据大范围那就很容易，但是无论是long还是long long，都有可能产生溢出，所以最好的办法是利用字符串实现大数加。</p><p>用字符串表示数字的时候，最直观的方法就是字符串里每个字符都是’0’到’9’之间的某个字符，用来表示数字中的一位。因为数字最大是n位的，因此我们需要一个长度为n+1的字符串（字符串中最后一个是结束符号’\0’），当实际数字不够n位的时候，在字符串的前半部分补0。</p><p>因此我们要做的是两件事：一是在字符串表达的数字上模拟加法，二是把字符串表达的数字打印出来。</p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数increment（）实现在数字上增加1</span></span><br><span class="line"><span class="comment">// 函数printNumber（）实现打印字符串数字</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printToMaxOfNDigits</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">char</span> *number = <span class="keyword">new</span> <span class="keyword">char</span>[n + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">memset</span>(number ,<span class="string">'0'</span> ,n);</span><br><span class="line">    number[n] = <span class="string">'\0'</span>;</span><br><span class="line">    <span class="keyword">while</span>(!increment(number))</span><br><span class="line">        printNumber(number);</span><br><span class="line">    <span class="keyword">delete</span> []number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">increment</span><span class="params">(<span class="keyword">char</span> * number)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> isOverflow = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int</span> nTakeOver = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> nLength = <span class="built_in">strlen</span>(number);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = nLength - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="keyword">int</span> nSum = number[i] - <span class="string">'0'</span> + nTakeOver;</span><br><span class="line">        <span class="keyword">if</span> (i == nLength - <span class="number">1</span>)</span><br><span class="line">            nSum ++;</span><br><span class="line">        <span class="keyword">if</span> (nSum &gt;= <span class="number">10</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span>)</span><br><span class="line">                isOverflow = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                nSum -= <span class="number">10</span>;</span><br><span class="line">                nTakeOver = <span class="number">1</span>;</span><br><span class="line">                number[i] = <span class="string">'0'</span> + nSum;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            number[i] = <span class="string">'0'</span> + nSum;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> isOverflow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//打印的时候注意阅读习惯，不打印前导0</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printNumber</span><span class="params">(<span class="keyword">char</span> * number)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> isBegining0 = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">int</span> nLength = <span class="built_in">strlen</span>(number);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nLength; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isBeginning0 &amp;&amp; number[i] != <span class="string">'0'</span>)</span><br><span class="line">            isBeginning0 = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (!isBeginning0)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%c"</span>,number[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\t"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;在O-1-时间内删除链表结点&quot;&gt;&lt;a href=&quot;#在O-1-时间内删除链表结点&quot; class=&quot;headerlink&quot; title=&quot;在O(1)时间内删除链表结点&quot;&gt;&lt;/a&gt;在O(1)时间内删除链表结点&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;题目描述：给定单向链表的头指针和一个结点指针，定义一个函数在O(1)时间删除该结点&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在单向链表中删除一个结点最常规的做法无疑是从链表的头结点开始，顺序遍历查找要删除的结点，并在链表中删除该结点。
    
    </summary>
    
      <category term="面试" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>2018-03-09</title>
    <link href="http://yoursite.com/2018/03/09/2018-03-09/"/>
    <id>http://yoursite.com/2018/03/09/2018-03-09/</id>
    <published>2018-03-09T15:46:27.000Z</published>
    <updated>2018-03-09T15:58:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近和她呆在一起的时间比较长，不过大多是在上自习。因为她要准备专八，我要准备找工作。但是今天她接受到了一个她前男友的快递，他送给她一条毛毯，说是看到西安有点冷。<a id="more"></a><br>是的，虽然她并没有答应我，但是我能感觉到她已经能够接受我了。只是看到这个快递，还是很难受，看到她的纠结犹豫了，我忍受着内心无奈与难受，告诉她你把毛毯放宿舍吧，然后想的话再给他打个电话。之后我就去自习室了，路上一时间我发现我不知道再能为她做什么了，真的不知道能够做什么才能让她将心交给我，想着她晚上盖着他送的毛毯，回忆着曾经那段幸福的时光。<br>算了我写不下去了，可能我还是太急了，毕竟她还需要时间！当下之急是解决工作问题，这样才会有更多时间可以陪伴了解，我也相信我能够让她真正喜欢上我！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近和她呆在一起的时间比较长，不过大多是在上自习。因为她要准备专八，我要准备找工作。但是今天她接受到了一个她前男友的快递，他送给她一条毛毯，说是看到西安有点冷。
    
    </summary>
    
      <category term="日记" scheme="http://yoursite.com/categories/life/"/>
    
    
  </entry>
  
  <entry>
    <title>C++面试问题准备：剑指 offer--从上往下打印和二叉搜索树的后序遍历序列</title>
    <link href="http://yoursite.com/2018/03/08/C-%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E5%87%86%E5%A4%87%EF%BC%9A%E5%89%91%E6%8C%87-offer-%E4%BB%8E%E4%B8%8A%E5%BE%80%E4%B8%8B%E6%89%93%E5%8D%B0%E5%92%8C%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97/"/>
    <id>http://yoursite.com/2018/03/08/C-面试问题准备：剑指-offer-从上往下打印和二叉搜索树的后序遍历序列/</id>
    <published>2018-03-08T12:20:51.000Z</published>
    <updated>2018-03-10T05:09:42.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="从上往下打印二叉树"><a href="#从上往下打印二叉树" class="headerlink" title="从上往下打印二叉树"></a>从上往下打印二叉树</h2><blockquote><p>题目描述：从上往下打印出二叉树的每个结点，同一层的结点按照从左到右的顺序打印。</p></blockquote><p>因为按层打印的顺序决定应该先打印根节点，所以我们从树的根节点开始分析。 <a id="more"></a></p><p><img src="/images/printTree.jpg" alt=""></p><p>为了接下来能够打印值为8的结点的两个子结点，我们应该在遍历到该结点时把值为6和10的两个结点保存到一个容器，现在容器内就有两个结点了。按照从左到右打印的要求，我们先取出值分别为5和7的两个结点放入数据容器。此时数据容器中有三个结点，值分别为10，5，7。接下来我们从数据容器中取出值为10的结点。注意到值为10的结点比值为5、7的结点先放入容器，此时又比这两个结点先取出，这就是我们经常说的 <strong><font color="#DC143C">先入先出</font></strong></p><p>综上我们可以得到思想：</p><p><strong><font color="#DC143C">每一次打印一个结点的时候，如果该结点有子结点，则把该结点的子结点放到一个队列的末尾。接下来到队列的头部取出最早进入队列的结点，重复前面的打印操作，直至队列中所有的子结点都被打印出来为止</font></strong></p><p>代码如下：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">void printTree(Tree *root) &#123;</span><br><span class="line">    if (root == NULL)</span><br><span class="line">        return ;</span><br><span class="line">    std::deque <span class="tag">&lt;Tree *&gt;</span> dequeTree;</span><br><span class="line">    dequeTree.push_back(root);</span><br><span class="line">    while(dequeTree.size()) &#123;</span><br><span class="line">        Tree *<span class="keyword">node</span> <span class="title">= dequeTree</span>.front();</span><br><span class="line">        dequeTree.pop_front();</span><br><span class="line">        cout <span class="tag">&lt;&lt; node -&gt;</span> value <span class="tag">&lt;&lt; endl;</span></span><br><span class="line"><span class="tag">        if (node -&gt;</span> left)</span><br><span class="line">            dequeTree.push_back(<span class="keyword">node</span> <span class="title">-&gt; left</span>);</span><br><span class="line">        if (<span class="keyword">node</span> <span class="title">-&gt; right</span>)</span><br><span class="line">            dequeTree.push_back(<span class="keyword">node</span> <span class="title">-&gt; right</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="判断二叉搜索树的后序遍历序列"><a href="#判断二叉搜索树的后序遍历序列" class="headerlink" title="判断二叉搜索树的后序遍历序列"></a>判断二叉搜索树的后序遍历序列</h2><blockquote><p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则返回true,否则返回false。假设输入的数组的任意两个数字都互不相同。</p></blockquote><p><img src="/images/printTree.jpg" alt=""></p><p>在后续遍历序列中，最后一个数字是树的根节点的值。数组中前面的数字可以分为两部分：第一部分是左子树结点的值，他们都比根节点的值小；第二部分是右子树结点的值，它们都比根节点的值大。根据以上给出的数组，后序遍历结果的最后一个数字8就是根节点的值。在这个数组中，前3个数字5、7和6都比8小，是值为8的结点的左子树结点；后3个数字9、11和10都比8大，是值为8的结点的右子树结点。接下来我们可以用同样的方法，确定数组每一部分对应的子树的结构。</p><p>代码如下：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> verifySquenceOfBST(<span class="type">int</span> sequence[],<span class="type">int</span> <span class="built_in">length</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (sequence == NULL || <span class="built_in">length</span> &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">int</span> root = sequence[<span class="built_in">length</span> - <span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt; <span class="built_in">length</span> - <span class="number">1</span>; ++i)</span><br><span class="line">        <span class="keyword">if</span> (sequence[i] &gt; root)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    <span class="type">int</span> j = i;</span><br><span class="line">    <span class="keyword">for</span> (; j &lt; <span class="built_in">length</span> - i - <span class="number">1</span>; ++ j)</span><br><span class="line">        <span class="keyword">if</span> (sequence[j] &lt; root)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">bool</span> left = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (i &gt; <span class="number">0</span>)</span><br><span class="line">        left = verifySquenceOfBST(sequence,i);</span><br><span class="line">    <span class="type">bool</span> right = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="built_in">length</span> - <span class="number">1</span>)</span><br><span class="line">        right = verifySquenceOfBST(sequence,<span class="built_in">length</span> - i - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> left &amp;&amp; right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;从上往下打印二叉树&quot;&gt;&lt;a href=&quot;#从上往下打印二叉树&quot; class=&quot;headerlink&quot; title=&quot;从上往下打印二叉树&quot;&gt;&lt;/a&gt;从上往下打印二叉树&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;题目描述：从上往下打印出二叉树的每个结点，同一层的结点按照从左到右的顺序打印。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;因为按层打印的顺序决定应该先打印根节点，所以我们从树的根节点开始分析。
    
    </summary>
    
      <category term="面试" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++面试问题准备：剑指-offer--合并两个排序链表和树的子结构</title>
    <link href="http://yoursite.com/2018/03/07/C-%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E5%87%86%E5%A4%87%EF%BC%9A%E5%89%91%E6%8C%87-offer-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E5%92%8C%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84/"/>
    <id>http://yoursite.com/2018/03/07/C-面试问题准备：剑指-offer-合并两个排序链表和树的子结构/</id>
    <published>2018-03-07T11:59:45.000Z</published>
    <updated>2018-03-08T11:22:48.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="合并两个排序链表"><a href="#合并两个排序链表" class="headerlink" title="合并两个排序链表"></a>合并两个排序链表</h2><blockquote><p>输入两个递增排序的链表，合并这两个链表并使新链表中的结点仍然使按照递增排序的。</p></blockquote><p>常见问题：</p><ul><li>写代码之前没有对合并过程想清楚，最终合并出来的链表要么中间断开，要么没有做到递增排序</li><li>代码的鲁棒性存在问题，程序有特殊输入会崩溃（输入空链表）<a id="more"></a><img src="/images/mergeList.png" alt=""></li></ul><p>两个链表的合并过程中：</p><ol><li>链表1的头结点的值小于链表2的头结点的值，因此链表1的头结点使合并后链表的头结点</li><li>在剩余的结点中，链表2的头结点的值小于链表1的头结点的值，因此链表2的头结点是剩余结点的头结点，把这个结点和之前已经合并好的结点连接起来。</li></ol><p>之后的步骤和以上两个步骤的比较是相同的，则可以用递归解决，代码如下：</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">listNode *mergeList(listNode *head1,listNode *head2) &#123;</span><br><span class="line">    <span class="keyword">if</span> (head1 == NULL)</span><br><span class="line">        return head2;</span><br><span class="line">    <span class="keyword">if</span> (head2 == NULL)</span><br><span class="line">        return head1;</span><br><span class="line">    listNode *mergeResult = NULL;</span><br><span class="line">    <span class="function"><span class="title">if</span> (head1 -&gt;</span> <span class="function"><span class="title">value</span> &lt; head2 -&gt;</span> value) &#123;</span><br><span class="line">        mergeResult = head1;</span><br><span class="line">        <span class="function"><span class="title">mergeResult</span> -&gt;</span> <span class="function"><span class="title">next</span> = mergeList(head1 -&gt;</span> next,head2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        mergeResult = head2;</span><br><span class="line">        <span class="function"><span class="title">mergeResult</span> -&gt;</span> <span class="function"><span class="title">next</span> = mergeList(head1,head2 -&gt;</span> next);</span><br><span class="line">    &#125;</span><br><span class="line">    return mergeResult;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="树的子结构"><a href="#树的子结构" class="headerlink" title="树的子结构"></a>树的子结构</h2><blockquote><p>输入两棵二叉树A和B，判断B是不是A的子结构。</p></blockquote><p><img src="/images/subTree.png" alt=""></p><p>如上图，第一棵树命名为A，第二棵树命名为B。</p><p>要查找第一棵树中是否存在和第二棵树一样的字结构,我们可以分成两步：第一步在A中找到和B的根结点的值一样的结点R，第二步再判断A中以R为根节点的子树是否包含和B一样的子树的结构。</p><p>代码如下，注意代码的鲁棒性，即在函数入口处检查参数的正确性。</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一步，找到和B树根节点数值相同的子树根结点</span></span><br><span class="line">bool judegeSubTree(Tree *root1, Tree *root2) &#123;</span><br><span class="line">    bool isSubTree = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (root1 != NULL &amp;&amp; root2 != NULL) &#123;</span><br><span class="line">        <span class="function"><span class="title">if</span> (root1 -&gt;</span> <span class="function"><span class="title">value</span> == root2 -&gt;</span> value) &#123;</span><br><span class="line">            isSubTree = judgeDefinateSubTree(root1,root2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="function"><span class="title">isSubTree</span> = judgeSubTree(root1 -&gt;</span> <span class="function"><span class="title">left</span>,root2) || judgeSubTree(root1 -&gt;</span> right,root2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return isSubTree;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第二步，进行两个树各自子结点的比较</span></span><br><span class="line">bool judgeDefinateSubTree(Tree *root1, Tree *root2) &#123;</span><br><span class="line">    bool result = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (root2 == NULL)</span><br><span class="line">        result = <span class="literal">true</span>;</span><br><span class="line">    <span class="function"><span class="title">if</span> (root1 -&gt;</span> <span class="function"><span class="title">value</span> == root2 -&gt;</span> value)</span><br><span class="line">        result = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="function"><span class="title">result</span> = judgeDefinateSubTree(root1 -&gt;</span> <span class="function"><span class="title">left</span>,root2 -&gt;</span> <span class="function"><span class="title">left</span>) &amp;&amp; judgeDefinateSubTree(root1 -&gt;</span> <span class="function"><span class="title">right</span>, root2 -&gt;</span> right);</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;合并两个排序链表&quot;&gt;&lt;a href=&quot;#合并两个排序链表&quot; class=&quot;headerlink&quot; title=&quot;合并两个排序链表&quot;&gt;&lt;/a&gt;合并两个排序链表&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;输入两个递增排序的链表，合并这两个链表并使新链表中的结点仍然使按照递增排序的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;常见问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;写代码之前没有对合并过程想清楚，最终合并出来的链表要么中间断开，要么没有做到递增排序&lt;/li&gt;
&lt;li&gt;代码的鲁棒性存在问题，程序有特殊输入会崩溃（输入空链表）
    
    </summary>
    
      <category term="面试" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++面试问题准备：剑指 offer--链表中倒数第k个结点和合并反转链表</title>
    <link href="http://yoursite.com/2018/03/07/C-%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E5%87%86%E5%A4%87%EF%BC%9A%E5%89%91%E6%8C%87%20offer-%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E7%BB%93%E7%82%B9%E5%92%8C%E5%90%88%E5%B9%B6%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/"/>
    <id>http://yoursite.com/2018/03/07/C-面试问题准备：剑指 offer-链表中倒数第k个结点和合并反转链表/</id>
    <published>2018-03-07T11:07:47.000Z</published>
    <updated>2018-03-07T13:43:33.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="链表中倒数第K个结点"><a href="#链表中倒数第K个结点" class="headerlink" title="链表中倒数第K个结点"></a>链表中倒数第K个结点</h2><blockquote><p>问题描述：输入一个链表，输出该链表中倒数第K个结点。例如一个链表有6个结点，从头结点开始它们的值依次是1，2，3，4，5，6。这个链表的倒数第三个结点值为4。<br><a id="more"></a></p></blockquote><p>为了得到我们想要的结果，我们会很自然的想到假设这个链表有n个结点，那么倒数第k个结点就是从头结点开始的第n-k+1个结点。如果我们能够得到链表中结点的个数n,那么我们只要从头结点开始向后走n-k+1步就可以了。<br>这个时候需要遍历链表两次，第一次统计出链表中结点的个数，第二次就能找到倒数第k个结点。<br>然而面试官希望我们能够只需要遍历依次链表就能够获取指定的值。</p><p>这个时候我们可以：</p><p><strong><font color="#DC143C">定义两个指针，第一个指针从链表的头指针开始遍历向前走k-1，第二个指针保持不动；从第k步开始，第二个指针也开始从链表的头指针开始遍历。由于两个指针的距离始终保持在k-1，当第一个（走在前面的）指针到达链表的尾结点时，第二个指针正好是倒数第k个结点。</font></strong></p><p><img src="/images/linkList.jpeg" alt=""></p><p>为了保证代码的鲁棒性，可以参考如下下代码；</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">listNode * findKthToTail(listNode * head,<span class="keyword">int</span> k) &#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">NULL</span> || k &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">NULL</span>;</span><br><span class="line">    listNode *pHead = head;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; k - <span class="number">1</span>; ++ i) &#123;</span><br><span class="line">        pHead = pHead -&gt; <span class="keyword">next</span>;</span><br><span class="line">        <span class="keyword">if</span> (pHead == <span class="keyword">NULL</span>) <span class="comment">// 防止k的大小超过链表的长度</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    listNode *pBehind = head;</span><br><span class="line">    <span class="keyword">while</span>(pHead -&gt; <span class="keyword">next</span> != <span class="keyword">NULL</span>) &#123;</span><br><span class="line">        pHead = pHead -&gt; <span class="keyword">next</span>;</span><br><span class="line">        pBehind = pBehind -&gt; <span class="keyword">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pBehind;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h2><blockquote><p>定义一个函数，输入一个链表的头结点，反转链表并输出反转后链表的头结点。</p></blockquote><p>为了正确反转一个链表，我们需要调整链表中指针的方向。如下图：</p><p><img src="/images/reservelist.png" alt=""></p><p>如上图所示的链表中,h,i和j是3个相邻的结点。假设经过若干操作，我们已经把结点h之前的指针调整完毕，这些结点的next都指向前面一个结点。接下来我们把i的next指向h,此时的链表如上图(b),由于结点i的next指向了它的前一个结点，导致链表在结点i,j之间断开。为了避免该问题，我们需要在调整结点i的next之前，把结点j保存下来。</p><p><strong><font color="#DC143C">我们在调整结点i的next指针时，除了需要知道结点本身之外还需要知道i的前一个结点h，因为我们需要把结点i的next指向结点h.同时还要事先保存i的一个结点j,以防止链表断开。</font></strong></p><p>代码如下：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">listNode * reserveList(listNode *head) &#123;</span><br><span class="line">    listNode * <span class="keyword">beReserved </span>= NULL<span class="comment">;</span></span><br><span class="line">    listNode *pNode = head<span class="comment">;</span></span><br><span class="line">    listNode *prev = NULL<span class="comment">;</span></span><br><span class="line">    while(pNode != NULL) &#123;</span><br><span class="line">        listNode *pNext = pNode -&gt; next<span class="comment">;</span></span><br><span class="line">        if (pNext == NULL)</span><br><span class="line">            <span class="keyword">beReserved </span>= pNode<span class="comment">;</span></span><br><span class="line">        pNode -&gt; next = prev<span class="comment">;</span></span><br><span class="line">        prev = pNode<span class="comment">;</span></span><br><span class="line">        pNode = pNext<span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">    return <span class="keyword">beReserved;</span></span><br><span class="line"><span class="keyword">&#125;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;链表中倒数第K个结点&quot;&gt;&lt;a href=&quot;#链表中倒数第K个结点&quot; class=&quot;headerlink&quot; title=&quot;链表中倒数第K个结点&quot;&gt;&lt;/a&gt;链表中倒数第K个结点&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;问题描述：输入一个链表，输出该链表中倒数第K个结点。例如一个链表有6个结点，从头结点开始它们的值依次是1，2，3，4，5，6。这个链表的倒数第三个结点值为4。&lt;br&gt;
    
    </summary>
    
      <category term="面试" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++面试问题准备：strcpy和strncpy以及memcpy函数</title>
    <link href="http://yoursite.com/2018/03/06/C-%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E5%87%86%E5%A4%87%EF%BC%9Astrcpy%E5%92%8Cstrncpy%E4%BB%A5%E5%8F%8Amemcpy%E5%87%BD%E6%95%B0/"/>
    <id>http://yoursite.com/2018/03/06/C-面试问题准备：strcpy和strncpy以及memcpy函数/</id>
    <published>2018-03-06T02:46:32.000Z</published>
    <updated>2018-03-08T05:26:05.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="strcpy函数以及strncpy函数"><a href="#strcpy函数以及strncpy函数" class="headerlink" title="strcpy函数以及strncpy函数"></a>strcpy函数以及strncpy函数</h2><blockquote><p>这两个函数都是字符串拷贝函数</p></blockquote><p>函数原型：</p><p><code>char * strcpy(char * destStr,char * srcStr);</code></p><p><code>cahr * strncpy(char * destStr,char * srcStr,int num);</code></p><a id="more"></a><p>很明显可以看出函数strncpy函数相对于函数strcpy更加安全，strcpy函数在进行复制的时候并没有考虑指定字符串空间的大小，如果目标字符串在空间没有指定字符串空间大的话会产生溢出，即内存泄漏。</p><p> 以上两个函数的实现如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">strcpy</span><span class="params">(<span class="keyword">char</span> * destStr,<span class="keyword">char</span> * srcStr)</span> </span>&#123;</span><br><span class="line">    assert((destStr != <span class="literal">NULL</span>) &amp;&amp; (srcStr != <span class="literal">NULL</span>));</span><br><span class="line">    <span class="keyword">char</span> * strDestCopy = destStr;</span><br><span class="line">    <span class="keyword">while</span>((*destStr++ = *srcStr++) != <span class="string">'\0'</span>);</span><br><span class="line">    <span class="keyword">return</span> strDestCopy;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">char</span> * <span class="title">strncpy</span><span class="params">(<span class="keyword">char</span> * destStr, <span class="keyword">char</span> * srcStr, <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    assert((destStr != <span class="literal">NULL</span>) &amp;&amp; (srcStr != <span class="literal">NULL</span>) &amp;&amp; (num != <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">char</span> * strDestCopy = destStr;</span><br><span class="line">    <span class="keyword">while</span>((*destStr++ = *srcStr++) != <span class="string">'\0'</span>)</span><br><span class="line">        num--;</span><br><span class="line">    <span class="keyword">if</span> (num &gt; <span class="number">0</span>) &#123;<span class="comment">//如果指定长度大于源字符串长度</span></span><br><span class="line">        <span class="keyword">while</span>(num --) &#123;</span><br><span class="line">            *destStr ++ = <span class="string">'\0'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> strDestCopy;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="memcpy函数"><a href="#memcpy函数" class="headerlink" title="memcpy函数"></a>memcpy函数</h2><blockquote><p>该函数可以针对任意类型数据进行拷贝</p></blockquote><p>函数原型：</p><p><code>void *memcpy(void*dest, const void *src, size_t n);</code></p><p>函数功能：</p><p>从src所指内存起始地址开始，拷贝n个字节的数据到目标地址空间dest.</p><p>函数实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">memory</span><span class="params">(<span class="keyword">void</span> *dst,<span class="keyword">const</span> <span class="keyword">void</span> *src,<span class="keyword">size_t</span> s)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">   <span class="keyword">const</span> <span class="keyword">char</span>* psrc=<span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">char</span>*&gt;(src); </span><br><span class="line">   </span><br><span class="line">    <span class="comment">//static_cast表示任何具有明确定义的类型转换，只要不包含底层const,都可以使用static_cast</span></span><br><span class="line">    <span class="comment">//const_cast只能改变运算对象的底层const,且其即可以添加const性质，也可以删除const性质</span></span><br><span class="line">    <span class="comment">//reinterpret_cast通常为运算对象的位模式提供较低层次上的重新解释</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">char</span>* pdst=<span class="keyword">static_cast</span>&lt;<span class="keyword">char</span>*&gt;(dst);  </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(psrc==<span class="literal">NULL</span> || pdst==<span class="literal">NULL</span>)  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;  </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(pdst &gt; psrc &amp;&amp; pdst &lt; (psrc+s))  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">size_t</span> i=s<span class="number">-1</span>;i!=<span class="number">-1</span>;i--)  </span><br><span class="line">            pdst[i]=psrc[i];  </span><br><span class="line">    &#125;  </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">else</span>  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">size_t</span> i=<span class="number">0</span>;i&lt;s;++i)  </span><br><span class="line">            pdst[i]=psrc[i];  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> dst;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;strcpy函数以及strncpy函数&quot;&gt;&lt;a href=&quot;#strcpy函数以及strncpy函数&quot; class=&quot;headerlink&quot; title=&quot;strcpy函数以及strncpy函数&quot;&gt;&lt;/a&gt;strcpy函数以及strncpy函数&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;这两个函数都是字符串拷贝函数&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;函数原型：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;char * strcpy(char * destStr,char * srcStr);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;cahr * strncpy(char * destStr,char * srcStr,int num);&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="面试" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>2018-03-04</title>
    <link href="http://yoursite.com/2018/03/04/2018-03-04/"/>
    <id>http://yoursite.com/2018/03/04/2018-03-04/</id>
    <published>2018-03-04T15:46:13.000Z</published>
    <updated>2018-03-05T07:05:47.000Z</updated>
    
    <content type="html"><![CDATA[<p>我和她不在一块的时间老想她，很想很想。结果今天中午回到学校，她竟然在我们学校学习，所以：<a id="more"></a><br>今天和糖永永同学呆在一块的时间大概有8个小时，这是一种很独特的感觉。<br>我们一起学习，她在看专八，我在总结面试笔记。我看看她，她看看我，莫名开心兴奋，当然对于我来说还真好，越看她越喜欢，然而她老不让我看她，其中有一个原因是她脸上有了一些小痘痘。</p><p>晚上回学校的时候，一路上沉默的时间很多，但并不是那种无话可说，而是发自内心的不想说话。结果她提到了以前和小胖子的相处方式，小胖子应该是属于那种非常能说话的，而且说的很好的那种。突然我内心有点失落，我发现我对她一点也不了解了，我又不知道她心里怎么想的了，她的内心还是很难受，她又很想他了，我不知道怎么对她说，因为我不了解，而且我个人属于那种现实生活中聊天很差的那种人，无法很清晰正确得表达自己想要表的东西。<br>就这样相处吧，还是希望能够对她以前的生活更了解一点！晚安啦！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我和她不在一块的时间老想她，很想很想。结果今天中午回到学校，她竟然在我们学校学习，所以：
    
    </summary>
    
      <category term="日记" scheme="http://yoursite.com/categories/life/"/>
    
    
  </entry>
  
  <entry>
    <title>C++面试问题准备：进程、线程、死锁、多线程还是多进程的选择以及区别</title>
    <link href="http://yoursite.com/2018/03/04/C-%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E5%87%86%E5%A4%87%EF%BC%9A%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%BF%98%E6%98%AF%E5%A4%9A%E8%BF%9B%E7%A8%8B%E7%9A%84%E9%80%89%E6%8B%A9%E4%BB%A5%E5%8F%8A%E5%8C%BA%E5%88%AB/"/>
    <id>http://yoursite.com/2018/03/04/C-面试问题准备：多线程还是多进程的选择以及区别/</id>
    <published>2018-03-04T12:27:20.000Z</published>
    <updated>2018-03-09T15:43:05.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h2><ul><li>一个进程由一个或多个线程组成，线程是一个进程中代码的不同执行路线；</li><li>进程之间相互独立，但同一进程下的各个线程之间共享程序的内存空间(包括代码段、数据集、堆等)及一些进程级的资源(如打开文件和信号)，某进程内的线程在其它进程不可见</li><li>调度和切换：线程上下文切换比进程上下文切换要快得多<a id="more"></a></li></ul><p><strong>进程几种状态</strong>：</p><p>创建态：进程正在创建，操作系统在创建进程时要进行的工作包括分配和建立进程控制块表项、建立资源表格并分配资源、加载程序并建立地址空间。</p><p>就绪态：时间片被用完，此线程被强制暂停，等待下一个属于它的时间片到来</p><p>运行态：此线程正在执行，正在占用时间片</p><p>阻塞：也叫等待状态，等待某一事件（如IO或另一个线程）执行完</p><p>退出：进程已结束，所以也称结束状态，释放操作系统分配的资源。</p><p><strong>线程几种状态</strong>：</p><p>创建：一个新的线程被创建，等待该线程被调用执行  </p><p>就绪：时间片已用完，此线程被强制暂停，等待下一个属于他的时间片到来  </p><p>运行：此线程正在执行，正在占用时间片  </p><p>阻塞：也叫等待状态，等待某一事件(如IO或另一个线程)执行完  </p><p>退出：一个线程完成任务或者其他终止条件发生，该线程终止进入退出状态，退出状态释放该线程所分配的资源</p><blockquote><p><strong><font color="#DC143C">线程共享的资源</font></strong>:<br> a. 堆：堆是在进程空间中开辟出来的，所以它是理所当然地被共享的。因此由malloc和new出来的都是共享的<br> b. 全局变量：它是与具体某一函数无关的，所以也与特定线程无关；因此也是共享的<br> c. 静态变量：即使是局部变量，在该局部变量存在的函数对于整个程序生存期间只有一份拷贝；因此也是共享的<br> d. 文件等公用资源：这个是共享的，使用这些公共资源的线程必须同步。windows下存在的几种线程同步资源的方式：信号、临界区、事件、互斥体<br> <strong><font color="#DC143C">线程独享的资源</font></strong>:<br> a. 线程ID:每个线程都有自己的线程ID，这个ID在本进程中是唯一的。进程用此来标识线程。<br> b. 寄存器组的值:由于线程间是并发运行的，每个线程有自己不同的运行线索，当从一个线程切换到另一个线程上时，必须将原有的线程的寄存器集合的状态保存，以便将来该线程在被重新切换到时能得以恢复。<br> c. 线程的堆栈:<font color="#DC143C">堆栈是保证线程独立运行所必须的.</font>线程函数可以调用函数，而被调用函数中又是可以层层嵌套的，所以线程 必须拥有自己的函数堆栈，使得函数调用可以正常执行，不受其他线程的影响。<br> d. 错误返回码:由于同一个进程中有很多个线程在同时运行，可能某个线程进行系统调用 后设置了errno值，而在该线程还没有处理这个错误，另外一个线程就在此时被调度器投入运行，这样错误值就有可能被修改<br> e. 线程的信号屏蔽码:由于每个线程所感兴趣的信号不同，所以线程的信号屏蔽码应该由线程自己管理。但所有的线程都共享同样的信号处理器<br> f. 线程的优先级:由于线程需要像进程那样能够被调度，那么就必须要有可供调度使用的参数，这个参数就是线程的优先级</p></blockquote><p> <strong><font color="#DC143C">如果有一组线程，每个线程都在等待一个事件的发生，而这个事件只能由该组线程里面的另一个线程发出，则称这组线程发生了死锁</font></strong></p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">线程A        线程B</span><br><span class="line"><span class="keyword">lock</span>(x);       <span class="keyword">lock</span>(y);</span><br><span class="line"><span class="keyword">lock</span>(y);       <span class="keyword">lock</span>(x);</span><br><span class="line">...            ...</span><br><span class="line"><span class="keyword">unlock</span>(y);     <span class="keyword">unlock</span>(x);</span><br><span class="line"><span class="keyword">unlock</span>(x);     <span class="keyword">unlock</span>(y);</span><br></pre></td></tr></table></figure><p>两线程交替执行，则会发生死锁。</p><h4 id="死锁的必要条件"><a href="#死锁的必要条件" class="headerlink" title="死锁的必要条件"></a><strong>死锁的必要条件</strong></h4><ul><li>资源有限：资源不能共享，在一个时候只能由一个线程使用。否则肯定不会发生死锁的。</li><li>持有等待：一个线程在请求新的资源时，其已经获得的资源并不释放，而是继续持有。一个线程在请求资源时，其并没有持有任何资源，自然就不会阻挠别的线程运行。</li><li>不能抢占：如果可以抢占别的线程正在占用的资源，则也不会发生死锁。</li><li>循环等待：如果你等我、我等你、大家都在等着对方，就产生了死锁。</li></ul><h4 id="死锁的应对"><a href="#死锁的应对" class="headerlink" title="死锁的应对"></a><strong>死锁的应对</strong></h4><p><strong><font color="#DC143C">顺其自然：不予理睬</font></strong></p><p>即操作系统不做任何措施，任由死锁发生。在商业操作系统中，死锁发生的频率并不是很高，而且防止死锁的代价很高，比重启100次代价还高。所以有的时候什么也不做其实更好。</p><p><strong><font color="#DC143C">先礼后兵：死锁监测与修复</font></strong></p><p>在高可靠性系统、实时控制系统那就需要进行死锁的防止了。</p><ul><li><p>死锁的检测：死锁的原因是资源竞争，我们只要对资源的拥有和对资源的请求都很清楚的话问题就解决了。</p><ol><li>将线程的资源占用和需求关系用一个有向图表示出来，再检查图中有没有循环，如果有，就发生死锁。但是这种检车算法的事件复杂度为O(n^3)，如果每次资源分配发生变化的时候，做这样一次检查系统效率会出现明显下降。</li></ol><p><img src="/images/deadLock.jpg" alt=""></p><ol><li>利用矩阵：资源分配矩阵和资源等待矩阵。同时维持两个矢量：系统资源总量矢量，表示系统中所有资源的总数是多少；另一个是系统当前可用资源矢量，代表系统还有多少可用资源。<strong><font color="#DC143C">我们将可用资源拿来与资源等待矩阵每一次进行比较，你就知道谁不能满足，如果减出来，每个线程都有负数，那就是发生了死锁。</font></strong></li></ol></li><li>死锁的恢复：<ol><li>抢占：将某个线程所占用的资源强行拿走，分配给别的线程。被抢占的线程很有可能不能正确运行。而且结果很难预料</li><li>杀掉：讲整个线程kill,因为抢占该线程的资源有可能已经造成该线程无法再正确运行。结果也是很难预料</li><li>上翻：即将整个系统反转到过去的某个状态，大家从那个状态重新来过。<blockquote><p>该策略实际上根本行不通，在检测与恢复两个部分都存在巨大困难。致命的问题是：检查死锁的线程自己发生了死锁，此时，死锁检查程序已经无法推进，自然无法检查死锁是否发生。</p></blockquote></li></ol></li></ul><p><strong><font color="#DC143C">先发制人：死锁的动态避免</font></strong></p><p>在每次进行资源分配时，必须经过仔细计算，确保该资源请求批准后系统不会进入死锁或潜在的死锁状态。</p><ul><li>安全状态：从该状态开始，我们能够找到一种资源分配方法和顺序，使得所有的线程都能获得其所需要的资源，从而不会产生死锁。</li><li>不安全状态：尚未发生死锁的状态，但接下来的执行一定会产生死锁。</li></ul><p><strong><font color="#DC143C">执行手段：防止系统进入不安全状态，每次进行资源分配的时候计算一下该分配是否会将系统带入不安全状态，如果是，就否决相关资源请求；否则，就批准。</font></strong></p><blockquote><p>动态避免的<br>优点：无需等待死锁的发生。<br>缺点：计算一个状态是否安全并不容易。如果一个系统资源种类繁杂，线程个数庞大，这种计算将变得十分复杂和费时。更致命的是我们想要预测一个线程的最大资源需求是，进行的估算按照人类一般的超额估算来说是会造成非常严重的后果：资源浪费，死锁误判。</p></blockquote><p><strong><font color="#DC143C">斩草除根：死锁的静态防止</font></strong><br>清除死锁发生的土壤，消除死锁发生的4个必要条件中的任何一个，则死锁将无法发生。</p><ul><li>消除资源独占条件：将资源无限增加或把所有资源变为共享。比如打印机，它是不允许任何线程直接占有，而是设计一个”精灵”程序daemon来管理，所有打印任务都必须经由它发出。</li><li>消除持有等待条件：一个线程必须一次请求其所需要的所有资源，而不是一般情况下的请求一点资源，做一点事情；到需要下一个资源的时候再请求一点，这样获得资源后再将整个程序推进。</li><li>消除非抢占条件：允许抢占资源，可以从一个线程手上将资源抢夺过来。一个线程可以将CPU或内存空间从一个线程手上抢过来，从而避免了因CPU和内存空间的竞争造成死锁。<font color="#DC143C">并不是所有的资源都可以被抢占而不产生不良后果，例如锁</font></li><li>消除循环等待条件：一个线程可以先请求资源A再请求资源B，也可以先请求B再请求资源A。这样如果两个线程按照按照不同的顺序请求A、B两个资源，死锁就有可能发生。但是我们可以规定对A、B两个资源的使用必须按照先A后B的顺序请求，则死锁就不会发生。</li></ul><h2 id="多进程-和多线程的区别"><a href="#多进程-和多线程的区别" class="headerlink" title="多进程 和多线程的区别"></a>多进程 和多线程的区别</h2><blockquote><p>进程是资源分配的最小单位，线程是CPU调度的最小单位。 <!--more--></p></blockquote><p>关于多进程和多线程的区别可以参考如下图：</p><p><img src="/images/moreIPC.png" alt=""></p><h2 id="多进程和多线程的选择"><a href="#多进程和多线程的选择" class="headerlink" title="多进程和多线程的选择"></a>多进程和多线程的选择</h2><p><strong><font color="#DC143C">需频繁创建销毁的优先用线程</font></strong></p><p>这种原则最常见的应用就是Web服务器了，来一个连接建立一个线程，断了就销毁线程，要是用进程，创建和销毁的代价是很难承受的</p><p><strong><font color="#DC143C">需要进行大量计算的优先使用线程</font></strong></p><p>大量计算当然就是要耗费很多CPU，切换频繁了，这种情况下线程是最合适的，一般应用在：图像处理和算法处理。</p><p><strong><font color="#DC143C">强相关的处理用线程，弱相关的处理用进程</font></strong></p><p>一般的Server需要完成如下任务：消息收发、消息处理。“消息收发”和“消息处理”就是弱相关的任务，而“消息处理”里面可能又分为“消息解码”、“业务处理”，这两个任务相对来说相关性就要强多了。因此“消息收发”和“消息处理”可以分进程设计，“消息解码”、“业务处理”可以分线程设计。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;进程和线程的区别&quot;&gt;&lt;a href=&quot;#进程和线程的区别&quot; class=&quot;headerlink&quot; title=&quot;进程和线程的区别&quot;&gt;&lt;/a&gt;进程和线程的区别&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;一个进程由一个或多个线程组成，线程是一个进程中代码的不同执行路线；&lt;/li&gt;
&lt;li&gt;进程之间相互独立，但同一进程下的各个线程之间共享程序的内存空间(包括代码段、数据集、堆等)及一些进程级的资源(如打开文件和信号)，某进程内的线程在其它进程不可见&lt;/li&gt;
&lt;li&gt;调度和切换：线程上下文切换比进程上下文切换要快得多
    
    </summary>
    
      <category term="面试" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++面试问题总结：指针和引用的区别以及extern C的作用</title>
    <link href="http://yoursite.com/2018/03/04/C-%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93%EF%BC%9A%E6%8C%87%E9%92%88%E5%92%8C%E5%BC%95%E7%94%A8%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://yoursite.com/2018/03/04/C-面试问题总结：指针和引用的区别/</id>
    <published>2018-03-04T05:50:38.000Z</published>
    <updated>2018-03-04T10:40:12.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="指针和引用的区别"><a href="#指针和引用的区别" class="headerlink" title="指针和引用的区别"></a>指针和引用的区别</h3><blockquote><p>指针和引用都代表的是地址</p></blockquote><ul><li><strong>引用</strong>需要指向某些对象，但是你可以声明指针变量为空，然后将引用指向该指针变量。</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">char</span> <span class="meta">*pc</span> <span class="string">=</span> <span class="literal">NULL</span><span class="string">;</span></span><br><span class="line"><span class="string">char</span> <span class="meta">&amp;rc</span> <span class="string">=</span> <span class="string">*pc;</span></span><br></pre></td></tr></table></figure><a id="more"></a><ul><li>因为引用肯定会指向一个对象，因此必须初始化，其实和１是一回事。指针无此限制，但是，其实指针的未初始化，过不了coverity这些工具的检测。</li><li>指针可以重新赋值，引用不可以，初始化后就不可改变:即不可以通过以更改指针的方式来更改引用的值，即直接对已经初始化的引用赋值。</li><li>sizeof结果不同，指针返回的是指针本身大小，引用返回的是引用对象的大小:如果是指针的话，一般指针大小是4B，引用返回的大小是引用对象的大小，这样就可能因为对象类型不同而不同。</li><li>引用不需要占用空间,它只是别名，不占用空间。</li></ul><h3 id="extern-C"><a href="#extern-C" class="headerlink" title="extern C"></a>extern C</h3><ul><li>C++代码调用C语言代码</li><li>C++头文件中使用</li><li>多人协同开放的时候可能有的人擅长C语言，有的人擅长C++，这样的情况使用<code>extern c</code>就可以在C++ 中使用C语言</li></ul><p>这里的原因是在编译器对C语言和C++编译的方式有不同。<br>比如针对函数<code>void fun(int ,int )</code>,编译器处理的时候如果按照C语言的方式编译，会将该函数标识为<code>_fun()</code>，此时如果编译器按照C++编译的时候会将该函数编译为<code>_funii()</code>,如果该函数是在C语言的头文件中，我想要C++中调用该函数，肯定需要使用<code>extern c</code>来包含该头文件中的函数，否则在C++编译的情况下，对函数名处理的结果是_funii(),但是真正是找不到这样的函数实际调用的。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;指针和引用的区别&quot;&gt;&lt;a href=&quot;#指针和引用的区别&quot; class=&quot;headerlink&quot; title=&quot;指针和引用的区别&quot;&gt;&lt;/a&gt;指针和引用的区别&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;指针和引用都代表的是地址&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;引用&lt;/strong&gt;需要指向某些对象，但是你可以声明指针变量为空，然后将引用指向该指针变量。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight yaml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;meta&quot;&gt;*pc&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;string&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;meta&quot;&gt;&amp;amp;rc&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;*pc;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="面试" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>2018-03-02</title>
    <link href="http://yoursite.com/2018/03/02/2018-03-02/"/>
    <id>http://yoursite.com/2018/03/02/2018-03-02/</id>
    <published>2018-03-02T13:42:39.000Z</published>
    <updated>2018-03-03T06:19:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天去火车站接到了糖小猪同学，她以为我不会去，结果，哈哈哈，把她给吓到了。</p><p>和她安安静静得坐了一个多小时得火车，嘿嘿，可以看的出来她挺开心的，不过我的初衷是天这么黑，担心她的安全！</p><p>之后回到学校，我们进行了一天简单的应该算是约会吧，一起吃了鸡公煲，一起摘了一筐草莓，有的甜，有的酸。一起从西安外国语大学走到了接近西北政法大学的一个影院，一起看了电影《红海行动》，在路上碰到一个以前学习英语的雪婷老师，结果没理我，我一脸懵逼！糖同学一出口就是是不是你们以前学习口语的，哎呦，我的天哪，她怎么知道的，我的天，内心太震惊了！然后一起在学校里吃了元宵，一起坐在饭堂三楼靠窗的做为聊天，一起走在有大月亮的路上，一切都是美好的开始。</p><p>感觉和她有那么一点点默契了，有的时候她知道我是怎么想的，有的时候我知道她是怎么想的。想到接下来的日子就莫名开心，同样我也会尽自己最大的可能准备北京的工作问题。为了以后能够更容易就这样简简单单，我会在接下来的两个月付出自己所有的能量！</p><p>今天我们走了最少有一万步，嘿嘿。有点累，但是很开心。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天去火车站接到了糖小猪同学，她以为我不会去，结果，哈哈哈，把她给吓到了。&lt;/p&gt;
&lt;p&gt;和她安安静静得坐了一个多小时得火车，嘿嘿，可以看的出来她挺开心的，不过我的初衷是天这么黑，担心她的安全！&lt;/p&gt;
&lt;p&gt;之后回到学校，我们进行了一天简单的应该算是约会吧，一起吃了鸡公煲
      
    
    </summary>
    
      <category term="日记" scheme="http://yoursite.com/categories/life/"/>
    
    
  </entry>
  
</feed>
