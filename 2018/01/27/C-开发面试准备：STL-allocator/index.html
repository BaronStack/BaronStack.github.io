<!DOCTYPE html>
<html>
  <!-- Html Head Tag-->
  <head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content="">
  <meta name="author" content="Mr.张">
  <!-- Open Graph Data -->
  <meta property="og:title" content="C++面试问题准备：STL--allocator"/>
  <meta property="og:description" content="" />
  <meta property="og:site_name" content="那一刻 风情万种"/>
  <meta property="og:type" content="article" />
  <meta property="og:image" content="http://yoursite.com"/>
  
    <link rel="alternate" href="/atom.xml" title="那一刻 风情万种" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  

  <!-- Site Title -->
  <title>那一刻 风情万种</title>

  <!-- Bootstrap CSS -->
  <link rel="stylesheet" href="/css/bootstrap.min.css">
  <!-- Custom CSS -->
  
  <link rel="stylesheet" href="/css/style.dark.css">

  <!-- Google Analytics -->
  

</head>

  <body>
    <!-- Page Header -->


<header class="site-header header-background" style="background-image: url(/img/default-banner-dark.jpg)">
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <div class="page-title with-background-image">
          <p class="title">C++面试问题准备：STL--allocator</p>
          <p class="subtitle"></p>
        </div>
        <div class="site-menu with-background-image">
          <ul>
            
              <li>
                <a href="/">
                  
                  Home
                  
                </a>
              </li>
            
              <li>
                <a href="/archives">
                  
                  Archives
                  
                </a>
              </li>
            
              <li>
                <a href="/categories">
                  
                  categories
                  
                </a>
              </li>
            
              <li>
                <a href="/tags">
                  
                  tags
                  
                </a>
              </li>
            
              <li>
                <a href="https://github.com/BaronStack">
                  
                  Github
                  
                </a>
              </li>
            
              <li>
                <a href="/2689496754@qq.com">
                  
                  Email
                  
                </a>
              </li>
            
          </ul>
        </div>
      </div>
    </div>
  </div>
</header>

<article>
  <div class="container typo">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <div class="post-info text-muted">
          
          <span id="busuanzi_container_site_uv">
          本站访客数<span id="busuanzi_value_site_uv"></span>人次
          </span>
            <!-- Author -->
            <span class="author info">By Mr.张</span>
          
          <!-- Date -->
          <span class="date-time info">On
            <span class="date">2018-01-27</span>
            <span class="time">11:42:05</span>
          </span>
          

          <!--  Categories  -->
            <span class="categories info">Under 

<a href="/categories/面试/">面试</a>
</span>
          
      </div>
        <!-- Tags -->
        
          <div class="post-tags text-muted">
            Tags: 

<a class="tag" href="/tags/C/">#C++</a>


          </div>
        
        <!-- Post Main Content -->
        <div class="post-content">
          <blockquote>
<p>最近在读侯捷老师的《STL源码剖析》，写写总结。他的STL主要是SGI 版本的，也就是我们常用的GCC编译器支持 <a id="more"></a></p>
</blockquote>
<h4 id="什么是allocator"><a href="#什么是allocator" class="headerlink" title="什么是allocator"></a>什么是allocator</h4><p>相信对C++感兴趣的伙伴肯定对STL这个模版库情有独钟，但是当站在STL的角度来看这些容器的实现那么第一个需要知道的就是allocator</p>
<p>allocator是空间适配器，即为STL容器产生的各种对象（所有的数值）分配存储空间的接口。</p>
<p>注意这里的存储空间指的并不一定是内存，还可以有硬盘哦！当然本章主要介绍的是allocator为STL配置内存空间。如果大家对allocator获取硬盘空间的方式感兴趣的话可以浏览该源码<a href="http://www.drdobbs.com/disk-based-container-objects/" target="_blank" rel="noopener">Disk-Based Container Objects</a>(这里需要翻墙，我是真没看懂，基础有点差)</p>
<h4 id="allocator-如何分配空间"><a href="#allocator-如何分配空间" class="headerlink" title="allocator 如何分配空间"></a>allocator 如何分配空间</h4><p>关于allocator 在STL中的规范接口大家可以参考文档<a href="http://zh.cppreference.com/w/cpp/memory/allocator" target="_blank" rel="noopener">allocator</a></p>
<p>其中SGI的默认allocator的源码可以参考<a href="https://afsws.rpi.edu/dept/acm/packages2/egcs/1.1.2/common/include/g++/defalloc.h" target="_blank" rel="noopener">defalloc.h</a></p>
<p>其中关于内存分配以及释放的源码如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">T</span>* <span class="title">allocate</span>(<span class="title">ptrdiff_t</span> <span class="title">size</span>, <span class="title">T</span>*) &#123;</span></span><br><span class="line">    set_new_handler(<span class="number">0</span>);</span><br><span class="line">    T* tmp = (T*)(::<span class="keyword">operator</span> <span class="keyword">new</span>((<span class="keyword">size_t</span>)(size * <span class="keyword">sizeof</span>(T)))); <span class="comment">//由全局操作符::operator new分配指定类型T大小的内存</span></span><br><span class="line">    <span class="keyword">if</span> (tmp == <span class="number">0</span>) &#123;</span><br><span class="line">	<span class="built_in">cerr</span> &lt;&lt; <span class="string">"out of memory"</span> &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">deallocate</span>(<span class="title">T</span>* <span class="title">buffer</span>) &#123;</span></span><br><span class="line">    ::<span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(buffer)</span></span>; <span class="comment">//由全局操作符::operator delete来释放类T的对象的内存</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们根据自己平时代码习惯，对内存的分配以及释放是以下的方式：<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class <span class="type">Foo</span><span class="meta">&#123;...&#125;</span></span><br><span class="line"><span class="type">Foo</span>* a = new <span class="type">Foo</span>;</span><br><span class="line">delete a;</span><br></pre></td></tr></table></figure></p>
<p>底层的new 分配方式是</p>
<ol>
<li>调用::operator new 配置内存</li>
<li>调用Foo::Foo()构造对象内容</li>
</ol>
<p>底层的delete分配方式是</p>
<ol>
<li>调用Foo::~Foo() 析构对象</li>
<li>调用::operator delete 释放内存</li>
</ol>
<blockquote>
<p>说到new ,简单说一下C++中new 和 malloc的区别<br><br><strong>1.new是C++的一种内存分配的关键字，malloc是C语言特有的内存非配函数，也可以为C++使用</strong><br><br><strong>2.new分配内存的大小由编译器来指定，即SGI 的GCC指定，开发者不需要考虑分配的大小计算。而malloc则需要显示计算大小</strong><br><br><strong>3.new会先调用operator new函数，申请足够的内存（通常底层使用malloc实现）。然后调用类型的构造函数，初始化成员变量，最后返回自定义类型指针。delete先调用析构函数，然后调用operator delete函数释放内存（通常底层使用free实现）</strong><br><br><strong>4.new 分配失败会返回bac_alloc异常，可由以上源码看出。而malloc分配失败会返回NULL</strong><br><br><strong>5.new可以被重载，malloc不允许</strong><br><br><strong>6.new分配的内存在自由存储区上，malloc分配的空间是在堆上，而堆是操作系统维护的一块特殊内存。</strong></p>
</blockquote>
<p>在SGI STL中默认的allocator，但是因为封装过于简单，没有考虑效率的强化，因为之后会说道trivial destructor(保证析构时候是执行释放内存的操作，而非无关痛痒的析构)，所以一般SGI会将以上的两个操作分开。</p>
<p>为了实现这个功能，STL标准规范 将以上总共四个操作分别封装在<code>alloc::allocate()</code>执行内存分配，<code>alloc::deallocate()</code> 执行内存释放，<code>::construct()</code>执行对象构造，<code>::destroy()</code>执行对象析构。</p>
<p>以上四个函数分别在以下两个文件：</p>
<figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stl_alloc.h&gt;</span> //负责空间的分配和释放</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stl_construt.h&gt;</span> //负责对象的构造和析构，construc 和destroy是全局函数，所以调用的时候用::construct()</span></span><br></pre></td></tr></table></figure>
<h5 id="关于构造与析构的过程"><a href="#关于构造与析构的过程" class="headerlink" title="关于构造与析构的过程"></a>关于构造与析构的过程</h5><p>关于<a href="http://gcc.gnu.org/onlinedocs/gcc-4.9.0/libstdc++/api/a01502_source.html" target="_blank" rel="noopener">stl_construct.h的源码</a></p>
<p>在<code>&lt;stl_construct.h&gt;</code>中的构造的过程如下 </p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;new.h&gt;</span></span></span><br><span class="line"><span class="keyword">template</span> &lt;class T1,class T2&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> construct(T1 *p,<span class="keyword">const</span> T2&amp; value) &#123;</span><br><span class="line">    <span class="keyword">new</span> (p) T1(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重点是进行对象析构的操作</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对单指针对象进行析构</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="title">void_Destroy</span><span class="params">(_Tp* __pointer)</span></span>&#123;</span><br><span class="line">    __pointer-&gt;~_Tp(); &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//对两个指针进行析构，即参数接受两个迭代器，此时我们需要判断迭代器之间元素的数值型别，即是否执行有意义的析构，即释放会释放内存</span></span><br><span class="line"><span class="comment">//主要析构函数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">ForwardIterator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">destroy</span>(<span class="title">ForwardIterator</span> <span class="title">first</span>,<span class="title">ForwardIterator</span> <span class="title">last</span>) &#123;</span></span><br><span class="line">    _destroy(first,last,value_type(first))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断元素的数值型别 注意，这里的has_trivial_destructor可以对析构函数的执行是否有意义进行判断，采取不同的执行方式来提升析构效率</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">ForwardIterator</span>,<span class="title">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> _<span class="title">destroy</span>(<span class="title">ForwardIterator</span> <span class="title">first</span>,<span class="title">ForwardIterator</span> <span class="title">last</span>,<span class="title">T</span>*) &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> _type_traits&lt;T&gt;::has_trivial_destructor trivial_destructor;</span><br><span class="line">    _destroy_aux(first,last,trivial_destructor);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果元素的数值型别有non-trivial destructor</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">ForwardIterator</span>&gt;</span></span><br><span class="line"><span class="class">_<span class="title">destroy_aux</span>(<span class="title">ForwardIterator</span> <span class="title">first</span>,<span class="title">ForwardIterator</span> <span class="title">last</span>,_<span class="title">false_type</span>) &#123;</span> </span><br><span class="line">    <span class="keyword">for</span> (; first &lt; last; ++first)</span><br><span class="line">        destroy(&amp;*first); <span class="comment">//调用一个指针的析构函数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果元素的数值型别有trivial destructor （即此时执行的该对象的析构函数是无意义的，不释放任何内存）</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">ForwardIterator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> _<span class="title">destroy_aux</span>(<span class="title">ForwardIterator</span>,<span class="title">ForwardIterator</span>,_<span class="title">true_type</span>)&#123;</span>&#125; <span class="comment">//该函数什么也不做，不执行析构操作</span></span><br></pre></td></tr></table></figure>
<p>综上我们就很容易看出SGI STL的开发者们是真生得站在系统效率的角度上进行的开发，一切只为了安全快捷。</p>
<blockquote>
<p>大量的inline函数使得我们系统执行的效率更快，在函数体运行的时候inline函数会在函数体内展开，而不需要在去由编译器去保存函数内容以及实参到内存，从而降低系统效率。</p>
</blockquote>

        </div>
      </div>
    </div>
  </div>
</article>



    <!-- Footer -->
<footer>
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <p class="copyright text-muted">
          <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
          <span id="busuanzi_container_page_uv">本文总阅读量<span id="busuanzi_value_page_pv"></span>次</span>
          Theme By <a target="_blank" href="https://github.com/levblanc">Levblanc.</a>
          Inspired By <a target="_blank" href="https://github.com/klugjo/hexo-theme-clean-blog">Clean Blog.</a>
        <p class="copyright text-muted">
          Powered By <a target="_blank" href="https://hexo.io/">Hexo.</a>
        </p>
      </div>
    </div>
  </div>
</footer>


    <!-- After Footer Scripts -->
<script src="/js/highlight.pack.js"></script>
<script>
  document.addEventListener("DOMContentLoaded", function(event) {
    var codeBlocks = Array.prototype.slice.call(document.getElementsByTagName('pre'))
    codeBlocks.forEach(function(block, index) {
      hljs.highlightBlock(block);
    });
  });
</script>

  </body>
</html>

