{"total":53,"pageSize":10,"pageCount":6,"data":[{"title":"C++面试问题准备：剑指 offer--链表中倒数第k个结点和合并反转链表","slug":"C-面试问题准备：剑指 offer-链表中倒数第k个结点和合并反转链表","date":"2018-03-07T11:07:47.000Z","updated":"2018-03-07T11:57:25.000Z","comments":true,"path":"api/articles/C-面试问题准备：剑指 offer-链表中倒数第k个结点和合并反转链表.json","excerpt":"","keywords":null,"cover":"/images/linkList.jpeg","content":"<h2 id=\"链表中倒数第K个结点\"><a href=\"#链表中倒数第K个结点\" class=\"headerlink\" title=\"链表中倒数第K个结点\"></a>链表中倒数第K个结点</h2><blockquote>\n<p>问题描述：输入一个链表，输出该链表中倒数第K个结点。例如一个链表有6个结点，从头结点开始它们的值依次是1，2，3，4，5，6。这个链表的倒数第三个结点值为4。</p>\n</blockquote>\n<p>为了得到我们想要的结果，我们会很自然的想到假设这个链表有n个结点，那么倒数第k个结点就是从头结点开始的第n-k+1个结点。如果我们能够得到链表中结点的个数n,那么我们只要从头结点开始向后走n-k+1步就可以了。<br>这个时候需要遍历链表两次，第一次统计出链表中结点的个数，第二次就能找到倒数第k个结点。<br>然而面试官希望我们能够只需要遍历依次链表就能够获取指定的值。</p>\n<p>这个时候我们可以：</p>\n<p><strong><font color=\"#DC143C\">定义两个指针，第一个指针从链表的头指针开始遍历向前走k-1，第二个指针保持不动；从第k步开始，第二个指针也开始从链表的头指针开始遍历。由于两个指针的距离始终保持在k-1，当第一个（走在前面的）指针到达链表的尾结点时，第二个指针正好是倒数第k个结点。</font></strong></p>\n<p><img src=\"/images/linkList.jpeg\" alt=\"\"></p>\n<p>为了保证代码的鲁棒性，可以参考如下下代码；</p>\n<figure class=\"highlight gradle\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">listNode * findKthToTail(listNode * head,<span class=\"keyword\">int</span> k) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (head == <span class=\"keyword\">NULL</span> || k &lt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">NULL</span>;</span><br><span class=\"line\">    listNode *pHead = head;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt; k - <span class=\"number\">1</span>; ++ i) &#123;</span><br><span class=\"line\">        pHead = pHead -&gt; <span class=\"keyword\">next</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (pHead == <span class=\"keyword\">NULL</span>) <span class=\"comment\">// 防止k的大小超过链表的长度</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">NULL</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    listNode *pBehind = head;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(pHead -&gt; <span class=\"keyword\">next</span> != <span class=\"keyword\">NULL</span>) &#123;</span><br><span class=\"line\">        pHead = pHead -&gt; <span class=\"keyword\">next</span>;</span><br><span class=\"line\">        pBehind = pBehind -&gt; <span class=\"keyword\">next</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> pBehind;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"反转链表\"><a href=\"#反转链表\" class=\"headerlink\" title=\"反转链表\"></a>反转链表</h2><blockquote>\n<p>定义一个函数，输入一个链表的头结点，反转链表并输出反转后链表的头结点。</p>\n</blockquote>\n<p>为了正确反转一个链表，我们需要调整链表中指针的方向。如下图：</p>\n<p><img src=\"/images/reservelist.png\" alt=\"\"></p>\n<p>如上图所示的链表中,h,i和j是3个相邻的结点。假设经过若干操作，我们已经把结点h之前的指针调整完毕，这些结点的next都指向前面一个结点。接下来我们把i的next指向h,此时的链表如上图(b),由于结点i的next指向了它的前一个结点，导致链表在结点i,j之间断开。为了避免该问题，我们需要在调整结点i的next之前，把结点j保存下来。</p>\n<p><strong><font color=\"#DC143C\">我们在调整结点i的next指针时，除了需要知道结点本身之外还需要知道i的前一个结点h，因为我们需要把结点i的next指向结点h.同时还要事先保存i的一个结点j,以防止链表断开。</font></strong></p>\n<p>代码如下：</p>\n<figure class=\"highlight mipsasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">listNode * reserveList(listNode *head) &#123;</span><br><span class=\"line\">    listNode * <span class=\"keyword\">beReserved </span>= NULL<span class=\"comment\">;</span></span><br><span class=\"line\">    listNode *pNode = head<span class=\"comment\">;</span></span><br><span class=\"line\">    listNode *prev = NULL<span class=\"comment\">;</span></span><br><span class=\"line\">    while(pNode != NULL) &#123;</span><br><span class=\"line\">        listNode *pNext = pNode -&gt; next<span class=\"comment\">;</span></span><br><span class=\"line\">        if (pNext == NULL)</span><br><span class=\"line\">            <span class=\"keyword\">beReserved </span>= pNode<span class=\"comment\">;</span></span><br><span class=\"line\">        pNode -&gt; next = prev<span class=\"comment\">;</span></span><br><span class=\"line\">        prev = pNode<span class=\"comment\">;</span></span><br><span class=\"line\">        pNode = pNext<span class=\"comment\">;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return <span class=\"keyword\">beReserved;</span></span><br><span class=\"line\"><span class=\"keyword\">&#125;</span></span><br></pre></td></tr></table></figure>\n","text":"链表中倒数第K个结点问题描述：输入一个链表，输出该链表中倒数第K个结点。例如一个链表有6个结点，从头结点开始它们的值依次是1，2，3，4，5，6。这个链表的倒数第三个结点值为4。为了得到我们想要的结果，我们会很自然的想到假设这个链表有n个结点，那么倒数第k个结点就是从头结点开始的","link":"","raw":null,"photos":[],"categories":[{"name":"面试","slug":"面试","count":17,"path":"api/categories/面试.json"}],"tags":[{"name":"C++","slug":"C","count":15,"path":"api/tags/C.json"}]},{"title":"C++面试问题准备：strcpy和strncpy以及memcpy函数","slug":"C-面试问题准备：strcpy和strncpy以及memcpy函数","date":"2018-03-06T02:46:32.000Z","updated":"2018-03-07T11:57:25.000Z","comments":true,"path":"api/articles/C-面试问题准备：strcpy和strncpy以及memcpy函数.json","excerpt":"","keywords":null,"cover":null,"content":"<h2 id=\"strcpy函数以及strncpy函数\"><a href=\"#strcpy函数以及strncpy函数\" class=\"headerlink\" title=\"strcpy函数以及strncpy函数\"></a>strcpy函数以及strncpy函数</h2><blockquote>\n<p>这两个函数都是字符串拷贝函数</p>\n</blockquote>\n<p>函数原型：</p>\n<p><code>char * strcpy(char * destStr,char * srcStr);</code></p>\n<p><code>cahr * strncpy(char * destStr,char * srcStr,int num);</code></p>\n<p>很明显可以看出函数strncpy函数相对于函数strcpy更加安全，strcpy函数在进行复制的时候并没有考虑指定字符串空间的大小，如果目标字符串在空间没有指定字符串空间大的话会产生溢出，即内存泄漏。</p>\n<p> 以上两个函数的实现如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">char</span> * <span class=\"title\">strcpy</span><span class=\"params\">(<span class=\"keyword\">char</span> * destStr,<span class=\"keyword\">char</span> * srcStr)</span> </span>&#123;</span><br><span class=\"line\">    assert((destStr != <span class=\"literal\">NULL</span>) &amp;&amp; (srcStr != <span class=\"literal\">NULL</span>));</span><br><span class=\"line\">    <span class=\"keyword\">char</span> * strDestCopy = destStr;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>((*destStr++ = *srcStr++) != <span class=\"string\">'\\0'</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> strDestCopy;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">char</span> * <span class=\"title\">strncpy</span><span class=\"params\">(<span class=\"keyword\">char</span> * destStr, <span class=\"keyword\">char</span> * srcStr, <span class=\"keyword\">int</span> num)</span> </span>&#123;</span><br><span class=\"line\">    assert((destStr != <span class=\"literal\">NULL</span>) &amp;&amp; (srcStr != <span class=\"literal\">NULL</span>) &amp;&amp; (num != <span class=\"number\">0</span>));</span><br><span class=\"line\">    <span class=\"keyword\">char</span> * strDestCopy = destStr;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>((*destStr++ = *srcStr++) != <span class=\"string\">'\\0'</span>)</span><br><span class=\"line\">        num--;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (num &gt; <span class=\"number\">0</span>) &#123;<span class=\"comment\">//如果指定长度大于源字符串长度</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(num --) &#123;</span><br><span class=\"line\">            *destStr ++ = <span class=\"string\">'\\0'</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> strDestCopy;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"memcpy函数\"><a href=\"#memcpy函数\" class=\"headerlink\" title=\"memcpy函数\"></a>memcpy函数</h2><blockquote>\n<p>该函数可以针对任意类型数据进行拷贝</p>\n</blockquote>\n<p>函数原型：</p>\n<p><code>void *memcpy(void*dest, const void *src, size_t n);</code></p>\n<p>函数功能：</p>\n<p>从src所指内存起始地址开始，拷贝n个字节的数据到目标地址空间dest.</p>\n<p>函数实现：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> *<span class=\"title\">memory</span><span class=\"params\">(<span class=\"keyword\">void</span> *dst,<span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *src,<span class=\"keyword\">size_t</span> s)</span>  </span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;  </span><br><span class=\"line\">   <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* psrc=<span class=\"keyword\">static_cast</span>&lt;<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>*&gt;(src); </span><br><span class=\"line\">   </span><br><span class=\"line\">    <span class=\"comment\">//static_cast表示任何具有明确定义的类型转换，只要不包含底层const,都可以使用static_cast</span></span><br><span class=\"line\">    <span class=\"comment\">//const_cast只能改变运算对象的底层const,且其即可以添加const性质，也可以删除const性质</span></span><br><span class=\"line\">    <span class=\"comment\">//reinterpret_cast通常为运算对象的位模式提供较低层次上的重新解释</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">char</span>* pdst=<span class=\"keyword\">static_cast</span>&lt;<span class=\"keyword\">char</span>*&gt;(dst);  </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span>(psrc==<span class=\"literal\">NULL</span> || pdst==<span class=\"literal\">NULL</span>)  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;  </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span>(pdst &gt; psrc &amp;&amp; pdst &lt; (psrc+s))  </span><br><span class=\"line\">    &#123;  </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">size_t</span> i=s<span class=\"number\">-1</span>;i!=<span class=\"number\">-1</span>;i--)  </span><br><span class=\"line\">            pdst[i]=psrc[i];  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    <span class=\"keyword\">else</span>  </span><br><span class=\"line\">    &#123;  </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">size_t</span> i=<span class=\"number\">0</span>;i&lt;s;++i)  </span><br><span class=\"line\">            pdst[i]=psrc[i];  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> dst;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","text":"strcpy函数以及strncpy函数这两个函数都是字符串拷贝函数函数原型：char * strcpy(char * destStr,char * srcStr);cahr * strncpy(char * destStr,char * srcStr,int num);很明显可以","link":"","raw":null,"photos":[],"categories":[{"name":"面试","slug":"面试","count":17,"path":"api/categories/面试.json"}],"tags":[{"name":"C++","slug":"C","count":15,"path":"api/tags/C.json"}]},{"title":"2018-03-04","slug":"2018-03-04","date":"2018-03-04T15:46:13.000Z","updated":"2018-03-05T07:05:47.000Z","comments":true,"path":"api/articles/2018-03-04.json","excerpt":"<p>我和她不在一块的时间老想她，很想很想。结果今天中午回到学校，她竟然在我们学校学习，所以：","keywords":null,"cover":null,"content":null,"text":"我和她不在一块的时间老想她，很想很想。结果今天中午回到学校，她竟然在我们学校学习，所以：<br>今天和糖永永同学呆在一块的时间大概有8个小时，这是一种很独特的感觉。<br>我们一起学习，她在看专八，我在总结面试笔记。我看看她，她看看我，莫名开心兴奋，当然对于我来说还真好，越看她越","link":"","raw":null,"photos":[],"categories":[{"name":"日记","slug":"life","count":25,"path":"api/categories/life.json"}],"tags":[]},{"title":"C++面试问题准备：多线程还是多进程的选择以及区别","slug":"C-面试问题准备：多线程还是多进程的选择以及区别","date":"2018-03-04T12:27:20.000Z","updated":"2018-03-05T09:42:35.000Z","comments":true,"path":"api/articles/C-面试问题准备：多线程还是多进程的选择以及区别.json","excerpt":"<h2 id=\"进程和线程的区别\"><a href=\"#进程和线程的区别\" class=\"headerlink\" title=\"进程和线程的区别\"></a>进程和线程的区别</h2><ul>\n<li>一个进程由一个或多个线程组成，线程是一个进程中代码的不同执行路线；</li>\n<li>进程之间相互独立，但同一进程下的各个线程之间共享程序的内存空间(包括代码段、数据集、堆等)及一些进程级的资源(如打开文件和信号)，某进程内的线程在其它进程不可见</li>\n<li>调度和切换：线程上下文切换比进程上下文切换要快得多","keywords":null,"cover":"/images/moreIPC.png","content":null,"text":"进程和线程的区别一个进程由一个或多个线程组成，线程是一个进程中代码的不同执行路线；进程之间相互独立，但同一进程下的各个线程之间共享程序的内存空间(包括代码段、数据集、堆等)及一些进程级的资源(如打开文件和信号)，某进程内的线程在其它进程不可见调度和切换：线程上下文切换比进程上下文","link":"","raw":null,"photos":[],"categories":[{"name":"面试","slug":"面试","count":17,"path":"api/categories/面试.json"}],"tags":[{"name":"C++","slug":"C","count":15,"path":"api/tags/C.json"}]},{"title":"C++面试问题总结：指针和引用的区别以及extern C的作用","slug":"C-面试问题总结：指针和引用的区别","date":"2018-03-04T05:50:38.000Z","updated":"2018-03-04T10:40:12.000Z","comments":true,"path":"api/articles/C-面试问题总结：指针和引用的区别.json","excerpt":"<h3 id=\"指针和引用的区别\"><a href=\"#指针和引用的区别\" class=\"headerlink\" title=\"指针和引用的区别\"></a>指针和引用的区别</h3><blockquote>\n<p>指针和引用都代表的是地址</p>\n</blockquote>\n<ul>\n<li><strong>引用</strong>需要指向某些对象，但是你可以声明指针变量为空，然后将引用指向该指针变量。</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">char</span> <span class=\"meta\">*pc</span> <span class=\"string\">=</span> <span class=\"literal\">NULL</span><span class=\"string\">;</span></span><br><span class=\"line\"><span class=\"string\">char</span> <span class=\"meta\">&amp;rc</span> <span class=\"string\">=</span> <span class=\"string\">*pc;</span></span><br></pre></td></tr></table></figure>","keywords":null,"cover":null,"content":null,"text":"指针和引用的区别指针和引用都代表的是地址引用需要指向某些对象，但是你可以声明指针变量为空，然后将引用指向该指针变量。1<br>2<br>char *pc = NULL;<br>char &amp;rc = *pc;<br>因为引用肯定会指向一个对象，因此必须初始化，其实和１是一回","link":"","raw":null,"photos":[],"categories":[{"name":"面试","slug":"面试","count":17,"path":"api/categories/面试.json"}],"tags":[{"name":"C++","slug":"C","count":15,"path":"api/tags/C.json"}]},{"title":"2018-03-02","slug":"2018-03-02","date":"2018-03-02T13:42:39.000Z","updated":"2018-03-03T06:19:00.000Z","comments":true,"path":"api/articles/2018-03-02.json","excerpt":"","keywords":null,"cover":null,"content":"<p>今天去火车站接到了糖小猪同学，她以为我不会去，结果，哈哈哈，把她给吓到了。</p>\n<p>和她安安静静得坐了一个多小时得火车，嘿嘿，可以看的出来她挺开心的，不过我的初衷是天这么黑，担心她的安全！</p>\n<p>之后回到学校，我们进行了一天简单的应该算是约会吧，一起吃了鸡公煲，一起摘了一筐草莓，有的甜，有的酸。一起从西安外国语大学走到了接近西北政法大学的一个影院，一起看了电影《红海行动》，在路上碰到一个以前学习英语的雪婷老师，结果没理我，我一脸懵逼！糖同学一出口就是是不是你们以前学习口语的，哎呦，我的天哪，她怎么知道的，我的天，内心太震惊了！然后一起在学校里吃了元宵，一起坐在饭堂三楼靠窗的做为聊天，一起走在有大月亮的路上，一切都是美好的开始。</p>\n<p>感觉和她有那么一点点默契了，有的时候她知道我是怎么想的，有的时候我知道她是怎么想的。想到接下来的日子就莫名开心，同样我也会尽自己最大的可能准备北京的工作问题。为了以后能够更容易就这样简简单单，我会在接下来的两个月付出自己所有的能量！</p>\n<p>今天我们走了最少有一万步，嘿嘿。有点累，但是很开心。</p>\n","text":"今天去火车站接到了糖小猪同学，她以为我不会去，结果，哈哈哈，把她给吓到了。和她安安静静得坐了一个多小时得火车，嘿嘿，可以看的出来她挺开心的，不过我的初衷是天这么黑，担心她的安全！之后回到学校，我们进行了一天简单的应该算是约会吧，一起吃了鸡公煲，一起摘了一筐草莓，有的甜，有的酸。一","link":"","raw":null,"photos":[],"categories":[{"name":"日记","slug":"life","count":25,"path":"api/categories/life.json"}],"tags":[]},{"title":"C++面试问题准备：剑指 offer-包含min函数的栈和栈的压入和弹出","slug":"C-面试问题准备：剑指-offer-包含min函数的栈和栈的压入和弹出","date":"2018-02-27T16:12:54.000Z","updated":"2018-03-03T07:27:32.000Z","comments":true,"path":"api/articles/C-面试问题准备：剑指-offer-包含min函数的栈和栈的压入和弹出.json","excerpt":"<h2 id=\"包含min函数的栈\"><a href=\"#包含min函数的栈\" class=\"headerlink\" title=\"包含min函数的栈\"></a>包含min函数的栈</h2><blockquote>\n<p>题目描述：定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的min函数，且在该栈中调用min,push以及pop的时间复杂度都是O(1)","keywords":null,"cover":"/images/minStack.png","content":null,"text":"包含min函数的栈题目描述：定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的min函数，且在该栈中调用min,push以及pop的时间复杂度都是O(1)看到这个问题我们会想到每一次将元素压入栈的时候对栈内所有的元素进行排序，将最小的元素放到栈顶，这样可以在O(1)时间","link":"","raw":null,"photos":[],"categories":[{"name":"面试","slug":"面试","count":17,"path":"api/categories/面试.json"}],"tags":[{"name":"C++","slug":"C","count":15,"path":"api/tags/C.json"}]},{"title":"2018-02-27","slug":"2018-02-27","date":"2018-02-27T15:31:50.000Z","updated":"2018-02-27T15:58:13.000Z","comments":true,"path":"api/articles/2018-02-27.json","excerpt":"<p>最近脑袋处于紧绷状态，随着春招的临近，北京的相关公司招聘信息发来很多。投了几家较为中意公司的简历，同时自己也铆足精神全心准备笔试和面试。","keywords":null,"cover":"/images/yongyong/小黄花.jpg","content":null,"text":"最近脑袋处于紧绷状态，随着春招的临近，北京的相关公司招聘信息发来很多。投了几家较为中意公司的简历，同时自己也铆足精神全心准备笔试和面试。同时最近在读书的时候努力提升自己的结构化思维能力，让自己在准备过程中梳理的知识更加由条理，方便记忆！看着手机里海信多媒体研发中心的新员工群，默默","link":"","raw":null,"photos":[],"categories":[{"name":"日记","slug":"life","count":25,"path":"api/categories/life.json"}],"tags":[]},{"title":"C++面试问题准备：linux cpu、系统性能调试相关命令","slug":"C-面试问题准备：linux-cpu、系统性能调试相关命令","date":"2018-02-26T13:07:17.000Z","updated":"2018-02-26T16:07:24.000Z","comments":true,"path":"api/articles/C-面试问题准备：linux-cpu、系统性能调试相关命令.json","excerpt":"<h2 id=\"Linux下查看内存和CPU占用情况\"><a href=\"#Linux下查看内存和CPU占用情况\" class=\"headerlink\" title=\"Linux下查看内存和CPU占用情况\"></a>Linux下查看内存和CPU占用情况</h2><h3 id=\"ps-将某个时间点的进程运行情况选取下来\"><a href=\"#ps-将某个时间点的进程运行情况选取下来\" class=\"headerlink\" title=\"ps:将某个时间点的进程运行情况选取下来\"></a><strong><code>ps</code>:将某个时间点的进程运行情况选取下来</strong></h3><figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">ps</span> aux  &lt;== 查看系统所有进程数据</span><br><span class=\"line\"><span class=\"keyword\">ps</span> -lA &lt;== 也是能够查看所有系统的数据</span><br><span class=\"line\"><span class=\"keyword\">ps</span> axjf &lt;== 连同部分进程树状态</span><br></pre></td></tr></table></figure>","keywords":null,"cover":"/images/linuxImages/ps_l.png","content":null,"text":"Linux下查看内存和CPU占用情况ps:将某个时间点的进程运行情况选取下来1<br>2<br>3<br>ps aux  &lt;== 查看系统所有进程数据<br>ps -lA &lt;== 也是能够查看所有系统的数据<br>ps axjf &lt;== 连同部分进程树状态<br","link":"","raw":null,"photos":[],"categories":[{"name":"面试","slug":"面试","count":17,"path":"api/categories/面试.json"}],"tags":[{"name":"linux","slug":"linux","count":5,"path":"api/tags/linux.json"}]},{"title":"C++面试问题准备：关于命令--netstat tcpdump ipcs ipcrm的使用","slug":"C-面试问题准备：关于命令-netstat-tcpdump-ipcs-ipcrm的使用","date":"2018-02-26T05:34:33.000Z","updated":"2018-02-26T08:44:45.000Z","comments":true,"path":"api/articles/C-面试问题准备：关于命令-netstat-tcpdump-ipcs-ipcrm的使用.json","excerpt":"<h2 id=\"网络通信命令–netstat-tcpdump\"><a href=\"#网络通信命令–netstat-tcpdump\" class=\"headerlink\" title=\"网络通信命令–netstat tcpdump\"></a>网络通信命令–netstat tcpdump</h2><h3 id=\"netstat：查看网络连接状态\"><a href=\"#netstat：查看网络连接状态\" class=\"headerlink\" title=\"netstat：查看网络连接状态\"></a><strong>netstat：查看网络连接状态</strong></h3><blockquote>\n<p>如果某一个网络服务已经启动，但是就是无法进行连接，这个时候就需要查询一下网络接口所监听的端口（port），来看看是否真的已经启动，因为有的时候屏幕上显示的OK并不一定真的就是”OK”。","keywords":null,"cover":"/images/linuxImages/net_rn.png","content":null,"text":"网络通信命令–netstat tcpdumpnetstat：查看网络连接状态如果某一个网络服务已经启动，但是就是无法进行连接，这个时候就需要查询一下网络接口所监听的端口（port），来看看是否真的已经启动，因为有的时候屏幕上显示的OK并不一定真的就是”OK”。关于netstat的","link":"","raw":null,"photos":[],"categories":[{"name":"面试","slug":"面试","count":17,"path":"api/categories/面试.json"}],"tags":[{"name":"Linux","slug":"Linux","count":1,"path":"api/tags/Linux.json"}]}]}