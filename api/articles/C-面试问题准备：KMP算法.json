{"title":"KMP算法","slug":"C-面试问题准备：KMP算法","date":"2018-03-12T16:35:13.000Z","updated":"2018-03-14T13:21:03.000Z","comments":true,"path":"api/articles/C-面试问题准备：KMP算法.json","photos":[],"link":"","excerpt":"在说KMP算法之前先说一下普通的模式匹配算法BF蛮力算法–字符串匹配算法思想：<br>从目标串T的的第一个字符起与模式串P的第一个字符比较<br>若相等，则继续对字符进行后续的比较<br>否则目标串从第二个字符起与模式串的第一个字符重新比较<br>直至模式串中的每个字符依次和目标串中的一个连续的字符序列相等为止，此时称为匹配成功，否则匹配失败","covers":null,"content":"<blockquote>\n<p>在说KMP算法之前先说一下普通的模式匹配算法</p>\n</blockquote>\n<h2 id=\"BF蛮力算法–字符串匹配\"><a href=\"#BF蛮力算法–字符串匹配\" class=\"headerlink\" title=\"BF蛮力算法–字符串匹配\"></a>BF蛮力算法–字符串匹配</h2><font size=\"5\">算法思想：</font><br><font color=\"#DC143C\">从目标串T的的第一个字符起与模式串P的第一个字符比较<br>若相等，则继续对字符进行后续的比较<br>否则目标串从第二个字符起与模式串的第一个字符重新比较<br>直至模式串中的每个字符依次和目标串中的一个连续的字符序列相等为止，此时称为匹配成功，否则匹配失败</font> <a id=\"more\"></a><br><br><font size=\"5\">算法性能：</font><br><font color=\"#DC143C\">假设模式串的长度是m，目标串的长度是n.<br>最坏情况即每次模式串都是在最后一个出现不等，最坏的时间复杂度为O(mn),因为其回溯比较，从而影响效率。<br><br>代码如下：<br><br><figure class=\"highlight hsp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> bf_match(char *target,char * pattern) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> <span class=\"keyword\">pos</span> = <span class=\"number\">-1</span><span class=\"comment\">;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>, j = <span class=\"number\">0</span>, k = <span class=\"number\">0</span><span class=\"comment\">;</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"keyword\">pos</span> == <span class=\"number\">-1</span> &amp;&amp; i &lt; <span class=\"keyword\">strlen</span>(target)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(j &lt; <span class=\"keyword\">strlen</span>(pattern) &amp;&amp; target[i] == pattern[j]) &#123;</span><br><span class=\"line\">            i ++<span class=\"comment\">;</span></span><br><span class=\"line\">            j ++<span class=\"comment\">;</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (j == <span class=\"keyword\">strlen</span>(pattern)) <span class=\"comment\">//扫描完，匹配成功，则让pos为开始匹配的下标</span></span><br><span class=\"line\">            <span class=\"keyword\">pos</span> = k<span class=\"comment\">;</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123; <span class=\"comment\">//未扫描完，则模式串从头开始，目标串从下一个字符开始</span></span><br><span class=\"line\">            j = <span class=\"number\">0</span><span class=\"comment\">;</span></span><br><span class=\"line\">            k++<span class=\"comment\">;</span></span><br><span class=\"line\">            i = k<span class=\"comment\">;</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">pos</span><span class=\"comment\">;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br><br>## KMP–Knuth-Morris-Pratt算法：消除BF中的回溯<br><br><font size=\"5\">算法思想：</font><br><font color=\"#DC143C\"><br>(1) 计算跳转位置信息，这里我们称之为部分匹配表。<br>(2) 后移到指定位置，重新开始匹配。</font>\n\n<p>这里 <strong><font color=\"#DC143C\">部分匹配表</font></strong>的含义是在目标字符串中最大前缀和最大后缀所拥有相同字符的最大长度。</p>\n<p>next数组的计算代码如下:</p>\n<figure class=\"highlight axapta\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> cal_next(<span class=\"keyword\">char</span> *<span class=\"keyword\">str</span>, <span class=\"keyword\">int</span> *next, <span class=\"keyword\">int</span> len)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    next[<span class=\"number\">0</span>] = <span class=\"number\">-1</span>;<span class=\"comment\">//next[0]初始化为-1，-1表示不存在相同的最大前缀和最大后缀</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> k = <span class=\"number\">-1</span>;<span class=\"comment\">//k初始化为-1</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> q = <span class=\"number\">1</span>; q &lt;= len<span class=\"number\">-1</span>; q++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (k &gt; <span class=\"number\">-1</span> &amp;&amp; <span class=\"keyword\">str</span>[k + <span class=\"number\">1</span>] != <span class=\"keyword\">str</span>[q])<span class=\"comment\">//如果下一个不同，那么k就变成next[k]，注意next[k]是小于k的，无论k取任何值。</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            k = next[k];<span class=\"comment\">//往前回溯</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">str</span>[k + <span class=\"number\">1</span>] == <span class=\"keyword\">str</span>[q])<span class=\"comment\">//如果相同，k++</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            k = k + <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        next[q] = k;<span class=\"comment\">//这个是把算的k的值（就是相同的最大前缀和最大后缀长）赋给next[q]</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>KMP代码如下:</p>\n<figure class=\"highlight axapta\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> KMP(<span class=\"keyword\">char</span> *<span class=\"keyword\">str</span>, <span class=\"keyword\">int</span> slen, <span class=\"keyword\">char</span> *ptr, <span class=\"keyword\">int</span> plen)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> *next = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[plen];</span><br><span class=\"line\">    cal_next(ptr, next, plen);<span class=\"comment\">//计算next数组</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> k = <span class=\"number\">-1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; slen; i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (k &gt;<span class=\"number\">-1</span>&amp;&amp; ptr[k + <span class=\"number\">1</span>] != <span class=\"keyword\">str</span>[i])<span class=\"comment\">//ptr和str不匹配，且k&gt;-1（表示ptr和str有部分匹配）</span></span><br><span class=\"line\">            k = next[k];<span class=\"comment\">//往前回溯</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ptr[k + <span class=\"number\">1</span>] == <span class=\"keyword\">str</span>[i])</span><br><span class=\"line\">            k = k + <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (k == plen<span class=\"number\">-1</span>)<span class=\"comment\">//说明k移动到ptr的最末端</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"comment\">//cout &lt;&lt; \"在位置\" &lt;&lt; i-plen+1&lt;&lt; endl;</span></span><br><span class=\"line\">            <span class=\"comment\">//k = -1;//重新初始化，寻找下一个</span></span><br><span class=\"line\">            <span class=\"comment\">//i = i - plen + 1;//i定位到该位置，外层for循环i++可以继续找下一个（这里默认存在两个匹配字符串可以部分重叠），感谢评论中同学指出错误。</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> i-plen+<span class=\"number\">1</span>;<span class=\"comment\">//返回相应的位置</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</font>","categories":[{"name":"面试","slug":"面试","count":33,"path":"api/categories/面试.json"}],"tags":[{"name":"C++","slug":"C","count":25,"path":"api/tags/C.json"}]}