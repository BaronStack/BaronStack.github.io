{"title":"C++面试问题准备：剑指 offer--从上往下打印和二叉搜索树的后序遍历序列","slug":"C-面试问题准备：剑指-offer-从上往下打印和二叉搜索树的后序遍历序列","date":"2018-03-08T12:20:51.000Z","updated":"2018-03-10T05:09:42.000Z","comments":true,"path":"api/articles/C-面试问题准备：剑指-offer-从上往下打印和二叉搜索树的后序遍历序列.json","photos":[],"link":"","excerpt":"从上往下打印二叉树题目描述：从上往下打印出二叉树的每个结点，同一层的结点按照从左到右的顺序打印。因为按层打印的顺序决定应该先打印根节点，所以我们从树的根节点开始分析。","covers":["/images/printTree.jpg","/images/printTree.jpg"],"content":"<h2 id=\"从上往下打印二叉树\"><a href=\"#从上往下打印二叉树\" class=\"headerlink\" title=\"从上往下打印二叉树\"></a>从上往下打印二叉树</h2><blockquote>\n<p>题目描述：从上往下打印出二叉树的每个结点，同一层的结点按照从左到右的顺序打印。</p>\n</blockquote>\n<p>因为按层打印的顺序决定应该先打印根节点，所以我们从树的根节点开始分析。 <a id=\"more\"></a></p>\n<p><img src=\"/images/printTree.jpg\" alt=\"\"></p>\n<p>为了接下来能够打印值为8的结点的两个子结点，我们应该在遍历到该结点时把值为6和10的两个结点保存到一个容器，现在容器内就有两个结点了。按照从左到右打印的要求，我们先取出值分别为5和7的两个结点放入数据容器。此时数据容器中有三个结点，值分别为10，5，7。接下来我们从数据容器中取出值为10的结点。注意到值为10的结点比值为5、7的结点先放入容器，此时又比这两个结点先取出，这就是我们经常说的 <strong><font color=\"#DC143C\">先入先出</font></strong></p>\n<p>综上我们可以得到思想：</p>\n<p><strong><font color=\"#DC143C\">每一次打印一个结点的时候，如果该结点有子结点，则把该结点的子结点放到一个队列的末尾。接下来到队列的头部取出最早进入队列的结点，重复前面的打印操作，直至队列中所有的子结点都被打印出来为止</font></strong></p>\n<p>代码如下：</p>\n<figure class=\"highlight crmsh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void printTree(Tree *root) &#123;</span><br><span class=\"line\">    if (root == NULL)</span><br><span class=\"line\">        return ;</span><br><span class=\"line\">    std::deque <span class=\"tag\">&lt;Tree *&gt;</span> dequeTree;</span><br><span class=\"line\">    dequeTree.push_back(root);</span><br><span class=\"line\">    while(dequeTree.size()) &#123;</span><br><span class=\"line\">        Tree *<span class=\"keyword\">node</span> <span class=\"title\">= dequeTree</span>.front();</span><br><span class=\"line\">        dequeTree.pop_front();</span><br><span class=\"line\">        cout <span class=\"tag\">&lt;&lt; node -&gt;</span> value <span class=\"tag\">&lt;&lt; endl;</span></span><br><span class=\"line\"><span class=\"tag\">        if (node -&gt;</span> left)</span><br><span class=\"line\">            dequeTree.push_back(<span class=\"keyword\">node</span> <span class=\"title\">-&gt; left</span>);</span><br><span class=\"line\">        if (<span class=\"keyword\">node</span> <span class=\"title\">-&gt; right</span>)</span><br><span class=\"line\">            dequeTree.push_back(<span class=\"keyword\">node</span> <span class=\"title\">-&gt; right</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"判断二叉搜索树的后序遍历序列\"><a href=\"#判断二叉搜索树的后序遍历序列\" class=\"headerlink\" title=\"判断二叉搜索树的后序遍历序列\"></a>判断二叉搜索树的后序遍历序列</h2><blockquote>\n<p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则返回true,否则返回false。假设输入的数组的任意两个数字都互不相同。</p>\n</blockquote>\n<p><img src=\"/images/printTree.jpg\" alt=\"\"></p>\n<p>在后续遍历序列中，最后一个数字是树的根节点的值。数组中前面的数字可以分为两部分：第一部分是左子树结点的值，他们都比根节点的值小；第二部分是右子树结点的值，它们都比根节点的值大。根据以上给出的数组，后序遍历结果的最后一个数字8就是根节点的值。在这个数组中，前3个数字5、7和6都比8小，是值为8的结点的左子树结点；后3个数字9、11和10都比8大，是值为8的结点的右子树结点。接下来我们可以用同样的方法，确定数组每一部分对应的子树的结构。</p>\n<p>代码如下：</p>\n<figure class=\"highlight glsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">bool</span> verifySquenceOfBST(<span class=\"type\">int</span> sequence[],<span class=\"type\">int</span> <span class=\"built_in\">length</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (sequence == NULL || <span class=\"built_in\">length</span> &lt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> root = sequence[<span class=\"built_in\">length</span> - <span class=\"number\">1</span>];</span><br><span class=\"line\">    <span class=\"type\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (; i &lt; <span class=\"built_in\">length</span> - <span class=\"number\">1</span>; ++i)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (sequence[i] &gt; root)</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> j = i;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (; j &lt; <span class=\"built_in\">length</span> - i - <span class=\"number\">1</span>; ++ j)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (sequence[j] &lt; root)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"type\">bool</span> left = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (i &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        left = verifySquenceOfBST(sequence,i);</span><br><span class=\"line\">    <span class=\"type\">bool</span> right = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (i &lt; <span class=\"built_in\">length</span> - <span class=\"number\">1</span>)</span><br><span class=\"line\">        right = verifySquenceOfBST(sequence,<span class=\"built_in\">length</span> - i - <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> left &amp;&amp; right;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","categories":[{"name":"面试","slug":"面试","count":25,"path":"api/categories/面试.json"}],"tags":[{"name":"C++","slug":"C","count":20,"path":"api/tags/C.json"}]}