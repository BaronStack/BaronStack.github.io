{"title":"剑指-offer--合并两个排序链表和树的子结构","slug":"C-面试问题准备：剑指-offer-合并两个排序链表和树的子结构","date":"2018-03-07T11:59:45.000Z","updated":"2018-03-14T13:22:32.000Z","comments":true,"path":"api/articles/C-面试问题准备：剑指-offer-合并两个排序链表和树的子结构.json","photos":[],"link":"","excerpt":"合并两个排序链表输入两个递增排序的链表，合并这两个链表并使新链表中的结点仍然使按照递增排序的。常见问题：写代码之前没有对合并过程想清楚，最终合并出来的链表要么中间断开，要么没有做到递增排序代码的鲁棒性存在问题，程序有特殊输入会崩溃（输入空链表）","covers":["/images/mergeList.png","/images/subTree.png"],"content":"<h2 id=\"合并两个排序链表\"><a href=\"#合并两个排序链表\" class=\"headerlink\" title=\"合并两个排序链表\"></a>合并两个排序链表</h2><blockquote>\n<p>输入两个递增排序的链表，合并这两个链表并使新链表中的结点仍然使按照递增排序的。</p>\n</blockquote>\n<p>常见问题：</p>\n<ul>\n<li>写代码之前没有对合并过程想清楚，最终合并出来的链表要么中间断开，要么没有做到递增排序</li>\n<li>代码的鲁棒性存在问题，程序有特殊输入会崩溃（输入空链表）<a id=\"more\"></a>\n<img src=\"/images/mergeList.png\" alt=\"\"></li>\n</ul>\n<p>两个链表的合并过程中：</p>\n<ol>\n<li>链表1的头结点的值小于链表2的头结点的值，因此链表1的头结点使合并后链表的头结点</li>\n<li>在剩余的结点中，链表2的头结点的值小于链表1的头结点的值，因此链表2的头结点是剩余结点的头结点，把这个结点和之前已经合并好的结点连接起来。</li>\n</ol>\n<p>之后的步骤和以上两个步骤的比较是相同的，则可以用递归解决，代码如下：</p>\n<figure class=\"highlight xl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">listNode *mergeList(listNode *head1,listNode *head2) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (head1 == NULL)</span><br><span class=\"line\">        return head2;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (head2 == NULL)</span><br><span class=\"line\">        return head1;</span><br><span class=\"line\">    listNode *mergeResult = NULL;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">if</span> (head1 -&gt;</span> <span class=\"function\"><span class=\"title\">value</span> &lt; head2 -&gt;</span> value) &#123;</span><br><span class=\"line\">        mergeResult = head1;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"title\">mergeResult</span> -&gt;</span> <span class=\"function\"><span class=\"title\">next</span> = mergeList(head1 -&gt;</span> next,head2);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        mergeResult = head2;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"title\">mergeResult</span> -&gt;</span> <span class=\"function\"><span class=\"title\">next</span> = mergeList(head1,head2 -&gt;</span> next);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return mergeResult;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"树的子结构\"><a href=\"#树的子结构\" class=\"headerlink\" title=\"树的子结构\"></a>树的子结构</h2><blockquote>\n<p>输入两棵二叉树A和B，判断B是不是A的子结构。</p>\n</blockquote>\n<p><img src=\"/images/subTree.png\" alt=\"\"></p>\n<p>如上图，第一棵树命名为A，第二棵树命名为B。</p>\n<p>要查找第一棵树中是否存在和第二棵树一样的字结构,我们可以分成两步：第一步在A中找到和B的根结点的值一样的结点R，第二步再判断A中以R为根节点的子树是否包含和B一样的子树的结构。</p>\n<p>代码如下，注意代码的鲁棒性，即在函数入口处检查参数的正确性。</p>\n<figure class=\"highlight xl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//第一步，找到和B树根节点数值相同的子树根结点</span></span><br><span class=\"line\">bool judegeSubTree(Tree *root1, Tree *root2) &#123;</span><br><span class=\"line\">    bool isSubTree = <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root1 != NULL &amp;&amp; root2 != NULL) &#123;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"title\">if</span> (root1 -&gt;</span> <span class=\"function\"><span class=\"title\">value</span> == root2 -&gt;</span> value) &#123;</span><br><span class=\"line\">            isSubTree = judgeDefinateSubTree(root1,root2);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"function\"><span class=\"title\">isSubTree</span> = judgeSubTree(root1 -&gt;</span> <span class=\"function\"><span class=\"title\">left</span>,root2) || judgeSubTree(root1 -&gt;</span> right,root2);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return isSubTree;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//第二步，进行两个树各自子结点的比较</span></span><br><span class=\"line\">bool judgeDefinateSubTree(Tree *root1, Tree *root2) &#123;</span><br><span class=\"line\">    bool result = <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root2 == NULL)</span><br><span class=\"line\">        result = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">if</span> (root1 -&gt;</span> <span class=\"function\"><span class=\"title\">value</span> == root2 -&gt;</span> value)</span><br><span class=\"line\">        result = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> </span><br><span class=\"line\">        <span class=\"function\"><span class=\"title\">result</span> = judgeDefinateSubTree(root1 -&gt;</span> <span class=\"function\"><span class=\"title\">left</span>,root2 -&gt;</span> <span class=\"function\"><span class=\"title\">left</span>) &amp;&amp; judgeDefinateSubTree(root1 -&gt;</span> <span class=\"function\"><span class=\"title\">right</span>, root2 -&gt;</span> right);</span><br><span class=\"line\">    return result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","categories":[{"name":"面试","slug":"面试","count":35,"path":"api/categories/面试.json"}],"tags":[{"name":"C++","slug":"C","count":25,"path":"api/tags/C.json"}]}