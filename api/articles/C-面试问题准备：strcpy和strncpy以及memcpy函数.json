{"title":"strcpy和strncpy以及memcpy函数","slug":"C-面试问题准备：strcpy和strncpy以及memcpy函数","date":"2018-03-06T02:46:32.000Z","updated":"2018-03-14T13:21:03.000Z","comments":true,"path":"api/articles/C-面试问题准备：strcpy和strncpy以及memcpy函数.json","photos":[],"link":"","excerpt":"strcpy函数以及strncpy函数这两个函数都是字符串拷贝函数函数原型：char * strcpy(char * destStr,char * srcStr);cahr * strncpy(char * destStr,char * srcStr,int num);","covers":null,"content":"<h2 id=\"strcpy函数以及strncpy函数\"><a href=\"#strcpy函数以及strncpy函数\" class=\"headerlink\" title=\"strcpy函数以及strncpy函数\"></a>strcpy函数以及strncpy函数</h2><blockquote>\n<p>这两个函数都是字符串拷贝函数</p>\n</blockquote>\n<p>函数原型：</p>\n<p><code>char * strcpy(char * destStr,char * srcStr);</code></p>\n<p><code>cahr * strncpy(char * destStr,char * srcStr,int num);</code></p>\n<a id=\"more\"></a>\n<p>很明显可以看出函数strncpy函数相对于函数strcpy更加安全，strcpy函数在进行复制的时候并没有考虑指定字符串空间的大小，如果目标字符串在空间没有指定字符串空间大的话会产生溢出，即内存泄漏。</p>\n<p> 以上两个函数的实现如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">char</span> * <span class=\"title\">strcpy</span><span class=\"params\">(<span class=\"keyword\">char</span> * destStr,<span class=\"keyword\">char</span> * srcStr)</span> </span>&#123;</span><br><span class=\"line\">    assert((destStr != <span class=\"literal\">NULL</span>) &amp;&amp; (srcStr != <span class=\"literal\">NULL</span>));</span><br><span class=\"line\">    <span class=\"keyword\">char</span> * strDestCopy = destStr;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>((*destStr++ = *srcStr++) != <span class=\"string\">'\\0'</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> strDestCopy;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">char</span> * <span class=\"title\">strncpy</span><span class=\"params\">(<span class=\"keyword\">char</span> * destStr, <span class=\"keyword\">char</span> * srcStr, <span class=\"keyword\">int</span> num)</span> </span>&#123;</span><br><span class=\"line\">    assert((destStr != <span class=\"literal\">NULL</span>) &amp;&amp; (srcStr != <span class=\"literal\">NULL</span>) &amp;&amp; (num != <span class=\"number\">0</span>));</span><br><span class=\"line\">    <span class=\"keyword\">char</span> * strDestCopy = destStr;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>((*destStr++ = *srcStr++) != <span class=\"string\">'\\0'</span>)</span><br><span class=\"line\">        num--;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (num &gt; <span class=\"number\">0</span>) &#123;<span class=\"comment\">//如果指定长度大于源字符串长度</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(num --) &#123;</span><br><span class=\"line\">            *destStr ++ = <span class=\"string\">'\\0'</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> strDestCopy;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"memcpy函数\"><a href=\"#memcpy函数\" class=\"headerlink\" title=\"memcpy函数\"></a>memcpy函数</h2><blockquote>\n<p>该函数可以针对任意类型数据进行拷贝</p>\n</blockquote>\n<p>函数原型：</p>\n<p><code>void *memcpy(void*dest, const void *src, size_t n);</code></p>\n<p>函数功能：</p>\n<p>从src所指内存起始地址开始，拷贝n个字节的数据到目标地址空间dest.</p>\n<p>函数实现：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> *<span class=\"title\">memory</span><span class=\"params\">(<span class=\"keyword\">void</span> *dst,<span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *src,<span class=\"keyword\">size_t</span> s)</span>  </span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;  </span><br><span class=\"line\">   <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* psrc=<span class=\"keyword\">static_cast</span>&lt;<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>*&gt;(src); </span><br><span class=\"line\">   </span><br><span class=\"line\">    <span class=\"comment\">//static_cast表示任何具有明确定义的类型转换，只要不包含底层const,都可以使用static_cast</span></span><br><span class=\"line\">    <span class=\"comment\">//const_cast只能改变运算对象的底层const,且其即可以添加const性质，也可以删除const性质</span></span><br><span class=\"line\">    <span class=\"comment\">//reinterpret_cast通常为运算对象的位模式提供较低层次上的重新解释</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">char</span>* pdst=<span class=\"keyword\">static_cast</span>&lt;<span class=\"keyword\">char</span>*&gt;(dst);  </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span>(psrc==<span class=\"literal\">NULL</span> || pdst==<span class=\"literal\">NULL</span>)  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;  </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span>(pdst &gt; psrc &amp;&amp; pdst &lt; (psrc+s))  </span><br><span class=\"line\">    &#123;  </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">size_t</span> i=s<span class=\"number\">-1</span>;i!=<span class=\"number\">-1</span>;i--)  </span><br><span class=\"line\">            pdst[i]=psrc[i];  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">else</span>  </span><br><span class=\"line\">    &#123;  </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">size_t</span> i=<span class=\"number\">0</span>;i&lt;s;++i)  </span><br><span class=\"line\">            pdst[i]=psrc[i];  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> dst;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","categories":[{"name":"面试","slug":"面试","count":37,"path":"api/categories/面试.json"}],"tags":[{"name":"C++","slug":"C","count":25,"path":"api/tags/C.json"}]}