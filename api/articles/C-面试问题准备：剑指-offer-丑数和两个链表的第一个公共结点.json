{"title":"C++面试问题准备：剑指 offer--丑数和两个链表的第一个公共结点","slug":"C-面试问题准备：剑指-offer-丑数和两个链表的第一个公共结点","date":"2018-03-12T10:01:41.000Z","updated":"2018-03-12T16:15:11.000Z","comments":true,"path":"api/articles/C-面试问题准备：剑指-offer-丑数和两个链表的第一个公共结点.json","photos":[],"link":"","excerpt":"两个链表的第一个公共结点问题描述：输入两个链表，找出它们的第一个公共结点。这道题第一次很容易想到，在第一个链表上遍历每个结点的时候再在第二个链表顺序遍历所有的结点，如果第二个链表上有一个结点和第一个链表上的结点一样，则返回该结点。但是这样的遍历方式会导致时间复杂度为O(mn);","covers":null,"content":"<h2 id=\"两个链表的第一个公共结点\"><a href=\"#两个链表的第一个公共结点\" class=\"headerlink\" title=\"两个链表的第一个公共结点\"></a>两个链表的第一个公共结点</h2><blockquote>\n<p>问题描述：输入两个链表，找出它们的第一个公共结点。</p>\n</blockquote>\n<p>这道题第一次很容易想到，在第一个链表上遍历每个结点的时候再在第二个链表顺序遍历所有的结点，如果第二个链表上有一个结点和第一个链表上的结点一样，则返回该结点。但是这样的遍历方式会导致时间复杂度为O(mn);<a id=\"more\"></a></p>\n<p>这样显然是不能让面试官满意的，那么分析两个链表具有公共结点的特点，即从该公共结点之后它们所有的结点都是重合的。我们可以考虑从后往前遍历链表，只需要找到最后一个不相同的结点，则该结点就是第一个公共结点。</p>\n<p>代码如下:</p>\n<figure class=\"highlight gradle\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">listNode * findFirstCommonNode(listNode * head1, listNode * head2) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (head1 == <span class=\"keyword\">NULL</span> || head2 == <span class=\"keyword\">NULL</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">NULL</span>;</span><br><span class=\"line\">    stack &lt;listNode &gt; s1,s2;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(head1 -&gt; <span class=\"keyword\">next</span> != <span class=\"keyword\">NULL</span>) &#123;</span><br><span class=\"line\">        s1.<span class=\"keyword\">push</span>(head1);</span><br><span class=\"line\">        head1 = head1 -&gt; <span class=\"keyword\">next</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">     <span class=\"keyword\">while</span>(head2 -&gt; <span class=\"keyword\">next</span> != <span class=\"keyword\">NULL</span>) &#123;</span><br><span class=\"line\">         s1.<span class=\"keyword\">push</span>(head2);</span><br><span class=\"line\">         head1 = head2 -&gt; <span class=\"keyword\">next</span>;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     <span class=\"keyword\">while</span>(!s1.empty() &amp;&amp; !s2.empty()) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">int</span> result;</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (s1.top() == s2.top()) &#123;</span><br><span class=\"line\">            s1.<span class=\"keyword\">pop</span>();</span><br><span class=\"line\">            result = s2.top();</span><br><span class=\"line\">            s2.<span class=\"keyword\">pop</span>()</span><br><span class=\"line\">          &#125; </span><br><span class=\"line\">          <span class=\"keyword\">else</span> </span><br><span class=\"line\">            <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     <span class=\"keyword\">return</span> <span class=\"keyword\">NULL</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上一个方法需要两个辅助栈，如果链表的长度分别为m和n，那么空间复杂度是O(m+n)。这种思路的时间复杂度也是O(m+n)。和最开始的蛮力法相比，时间效率得到了提高，相当于是空间换时间。</p>\n<p>接下来有一个更简单的办法：首先遍历两个链表得到它们的长度，就能知道哪个链表比较长，以及长的链表比短的链表多几个结点。在第二次遍历的时候，在较长的链表上先走若干步，接着同时在两个链表上遍历，找到的第一个相同的结点就是它们的第一个公共结点。</p>\n<p>代码如下：<br><figure class=\"highlight gradle\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">listNode * findFirstCommonNode(listNode * head1, listNode * head2) &#123;</span><br><span class=\"line\">    unsigned <span class=\"keyword\">int</span> length1 = getListLength(head1);</span><br><span class=\"line\">    unsigned <span class=\"keyword\">int</span> length2 = getListLength(head2);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">int</span> nLengthDif = length1 -length2;</span><br><span class=\"line\">    listNode * listLong = head1;</span><br><span class=\"line\">    listNode * listShort = head2;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (length2 &gt; length1) &#123;</span><br><span class=\"line\">        listLong = head2;</span><br><span class=\"line\">        listShort = head1;</span><br><span class=\"line\">        nLengthDif = length2 -length1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//先从长链表走几步</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt; nLengthDif; ++i) </span><br><span class=\"line\">        listLong = listLong -&gt; <span class=\"keyword\">next</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(listLong != <span class=\"keyword\">NULL</span> &amp;&amp; listShort != <span class=\"keyword\">NULL</span> &amp;&amp; listLong != listShort) &#123;</span><br><span class=\"line\">        listLong = listLong -&gt; <span class=\"keyword\">next</span>;</span><br><span class=\"line\">        listShort = listShort -&gt; <span class=\"keyword\">next</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    listNode *first = listLong;</span><br><span class=\"line\">     <span class=\"keyword\">return</span> first;    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> getListLength(listNode * head) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (head == <span class=\"keyword\">NULL</span>) </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> <span class=\"keyword\">count</span> = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(head -&gt; <span class=\"keyword\">next</span> != <span class=\"keyword\">NULL</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">count</span> ++;</span><br><span class=\"line\">        head = head -&gt; <span class=\"keyword\">next</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">count</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"丑数\"><a href=\"#丑数\" class=\"headerlink\" title=\"丑数\"></a>丑数</h2><blockquote>\n<p>题目描述：我们把只包含因子2、3、5的数称作丑数。求按从小到大的顺序第1500个丑数。例如6、8都是丑数，但14不是，因为它包含因子7。习惯上我们把1当作第一个丑数。</p>\n</blockquote>\n<p>显然我们可以得到一个数如果能够连续被2整除、被3整除或者被5整除，最后结果余1，那么它就是丑数。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isUgly</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(n % <span class=\"number\">2</span> == <span class=\"number\">0</span>)</span><br><span class=\"line\">        n /= <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(n % <span class=\"number\">3</span> == <span class=\"number\">0</span>)</span><br><span class=\"line\">        n /= <span class=\"number\">3</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(n % <span class=\"number\">5</span> == <span class=\"number\">0</span>)</span><br><span class=\"line\">        n /= <span class=\"number\">5</span>;</span><br><span class=\"line\">     <span class=\"keyword\">if</span> (n == <span class=\"number\">1</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">     <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getUglyNumber</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n &lt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> uglyFound = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(uglyFound &lt; n) &#123;</span><br><span class=\"line\">        i ++;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (isUgly(i))</span><br><span class=\"line\">            uglyFound ++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> i;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上段代码很直观得告诉我们指定题目的第n个丑数的计算过程。但是由于它会对每个非丑数也进行丑数的判断，从而导致算法效率不高。</p>\n<p>此时我们可以采用方法2:<strong><font color=\"#DC143C\">创建数组保存已经找到的丑数，用空间换时间的解法。</font></strong></p>\n<p>即找到如何计算丑数的方法，而非判断丑数。我们可以创建一个数组，里面的数字是排好序的丑数，每一个丑数都是前面的丑数乘以2、3或5得到的。</p>\n<p>这种思路的关键在于怎样确保数组里面的丑数是排好序的。假设数组中已经由若干丑数排好序后存放在数组中，并且已有最大的丑数计作M，我们接下来分析如何生成下一个丑数。该丑数一定是前面某一个丑数乘以2、3或5的结果，所以我们首先考虑把已有的每个丑数乘以2。在乘以2的时候，能得到若干个小于或等于M的结果。</p>\n<p>代码如下：</p>\n<figure class=\"highlight fortran\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">int</span> getUglyNumber_Solution2(<span class=\"built_in\">int</span> <span class=\"built_in\">index</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">index</span> &lt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"built_in\">int</span> *uglyNumbers = new <span class=\"built_in\">int</span>[<span class=\"built_in\">index</span>];</span><br><span class=\"line\">    uglyNumbers[<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"built_in\">int</span> nextUglyIndex = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"built_in\">int</span> *multiply2 = uglyNumbers;</span><br><span class=\"line\">    <span class=\"built_in\">int</span> *multiply3 = uglyNumbers;</span><br><span class=\"line\">    <span class=\"built_in\">int</span> *multiply5 = uglyNumbers;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(nextUglyIndex &lt; <span class=\"built_in\">index</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">int</span> <span class=\"built_in\">min</span> = <span class=\"built_in\">Min</span>(*multiply2 * <span class=\"number\">2</span> ,*multiply3 * <span class=\"number\">3</span> ,*multiply5 * <span class=\"number\">5</span>);</span><br><span class=\"line\">        uglyNumbers[nextUglyIndex] = <span class=\"built_in\">min</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(*multiply2 * <span class=\"number\">2</span> &lt;= uglyNumbers[nextUglyIndex])</span><br><span class=\"line\">             multiply2 ++;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(*multiply3 * <span class=\"number\">3</span> &lt;= uglyNumbers[nextUglyIndex])</span><br><span class=\"line\">             multiply3 ++;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(*multiply5 * <span class=\"number\">5</span> &lt;= uglyNumbers[nextUglyIndex])</span><br><span class=\"line\">             multiply5 ++;</span><br><span class=\"line\">        nextUglyIndex++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">int</span> ugly = uglyNumbers[nextUglyIndex - <span class=\"number\">1</span>];</span><br><span class=\"line\">    delete[] uglyNumbers;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ugly;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">int</span> <span class=\"built_in\">min</span>(<span class=\"built_in\">int</span> number1,<span class=\"built_in\">int</span> number2,<span class=\"built_in\">int</span> number3) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">int</span> <span class=\"built_in\">min</span> = (number1 &lt; number2) ? number1:number2;</span><br><span class=\"line\">    <span class=\"built_in\">min</span> = (<span class=\"built_in\">min</span> &lt; number3) ? <span class=\"built_in\">min</span>:number3;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">min</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","categories":[{"name":"面试","slug":"面试","count":29,"path":"api/categories/面试.json"}],"tags":[{"name":"C++","slug":"C","count":23,"path":"api/tags/C.json"}]}