{"title":"C++面试问题准备：剑指 offer-包含min函数的栈和栈的压入和弹出","slug":"C-面试问题准备：剑指-offer-包含min函数的栈和栈的压入和弹出","date":"2018-02-27T16:12:54.000Z","updated":"2018-03-03T07:27:32.000Z","comments":true,"path":"api/articles/C-面试问题准备：剑指-offer-包含min函数的栈和栈的压入和弹出.json","photos":[],"link":"","excerpt":"包含min函数的栈题目描述：定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的min函数，且在该栈中调用min,push以及pop的时间复杂度都是O(1)","covers":["/images/minStack.png","/images/pushStack.png","/images/stack.png"],"content":"<h2 id=\"包含min函数的栈\"><a href=\"#包含min函数的栈\" class=\"headerlink\" title=\"包含min函数的栈\"></a>包含min函数的栈</h2><blockquote>\n<p>题目描述：定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的min函数，且在该栈中调用min,push以及pop的时间复杂度都是O(1)<a id=\"more\"></a></p>\n</blockquote>\n<p>看到这个问题我们会想到每一次将元素压入栈的时候对栈内所有的元素进行排序，将最小的元素放到栈顶，这样可以在O(1)时间内获得最小元素，但是这样的结果造成的是不能保证最后压入的元素最先出栈，这样就不是栈了。</p>\n<p>那么我们又可以想到在栈中添加一个成员变量用来存放最小元素，每次压入栈的时候将当前元素与要压入的元素进行比较，并且更新该成员变量。此时如果最小元素被弹出了，如何得到下一个最小元素呢？</p>\n<p>这个时候就发现仅仅添加一个栈的成员变量是不够的，因此我们想要在压入这个最小元素之前将次小元素保存下来。这个时候我们可以采用 <strong><font color=\"#DC143C\">辅助栈</font></strong>，保存最小元素和次小元素。</p>\n<p>可以浏览下图，看看整个压入和弹出的过程是什么样子的。</p>\n<p><img src=\"/images/minStack.png\" alt=\"\"></p>\n<p>以上过程是这样子的：<strong>首先往空的数据栈中压入3，显然现在3是最小的，所以同时向辅助栈压入最小值。接下来向数据栈中压入数字4，由于4大于之前的最小值，因此我们仍然往辅助栈里压入数字3。第三步，继续向数据栈里压入数字2，由于2小于之前的最小值3，因此我们将最小值更新为2，并把2压入辅助栈，同样压入数字1的时候也要更新最小值，并把新的最小值压入辅助栈。当第五步在数据栈中弹出1的时候，我们把辅助栈的栈顶弹出，辅助栈的栈顶元素就是2。接下来继续弹出数据栈和辅助栈的栈顶之后，数据栈还剩下3、4两个数字，3是最小值。此时位于辅助栈的栈顶数字也正好是3。</strong></p>\n<p>函数代码如下：</p>\n<figure class=\"highlight ceylon\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt; <span class=\"keyword\">void</span> stackWithMin&lt;T&gt;::push(const T&amp; <span class=\"keyword\">value</span>) &#123;</span><br><span class=\"line\">    m<span class=\"number\">_</span>data.push(<span class=\"keyword\">value</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (m<span class=\"number\">_m</span><span class=\"keyword\">in</span>.size() == <span class=\"number\">0</span> || <span class=\"keyword\">value</span> &lt; m<span class=\"number\">_m</span><span class=\"keyword\">in</span>.top())</span><br><span class=\"line\">        m<span class=\"number\">_m</span><span class=\"keyword\">in</span>.push(<span class=\"keyword\">value</span>);</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        m<span class=\"number\">_m</span><span class=\"keyword\">in</span>.push(m<span class=\"number\">_m</span><span class=\"keyword\">in</span>.top());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">template &lt;typename T&gt; <span class=\"keyword\">void</span> stackWithMin&lt;T&gt;::pop() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">assert</span>(m<span class=\"number\">_</span>data.size() &gt; <span class=\"number\">0</span> &amp;&amp; m<span class=\"number\">_m</span><span class=\"keyword\">in</span>.size() &gt; <span class=\"number\">0</span>); <span class=\"comment\">// assert的作用是现计算表达式 expression ，如果其值为假（即为0），那么它先向stderr打印一条出错信息，然后通过调用 abort 来终止程序运行</span></span><br><span class=\"line\">    m<span class=\"number\">_</span>data.pop();</span><br><span class=\"line\">    m<span class=\"number\">_m</span><span class=\"keyword\">in</span>.pop();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">template &lt;typename T&gt; <span class=\"keyword\">void</span> stackWithMin&lt;T&gt;::min() const &#123;</span><br><span class=\"line\">    <span class=\"keyword\">assert</span>(m<span class=\"number\">_</span>data.size() &gt; <span class=\"number\">0</span> &amp;&amp; m<span class=\"number\">_m</span><span class=\"keyword\">in</span>.size() &gt; <span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> m<span class=\"number\">_m</span><span class=\"keyword\">in</span>.top();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"栈的压入弹出序列\"><a href=\"#栈的压入弹出序列\" class=\"headerlink\" title=\"栈的压入弹出序列\"></a>栈的压入弹出序列</h2><blockquote>\n<p>输入两个整数序列，第一个整数表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1、2、3、4、5是某栈的压栈序列，序列4、5、3、2、1是该栈序列对应的一个弹出序列，但4、3、5、1、2就不可能是该压栈序列的弹出序列。</p>\n</blockquote>\n<p>借用一个辅助栈，把输入的第一个序列中的数字依次压入该辅助栈，并按照第二个序列的顺序依次从该栈中弹出数字。</p>\n<p>以弹出序列4、5、3、2、1为例分析压栈和弹出的过程。第一个希望被弹出的数字是4，因此4需要先压入到辅助栈里面。压入栈的顺序由压栈序列确定了，也就是把4压入到栈之前，数字1、2、3都需要西安压入到栈里面。此时栈里包含4个数字，分别是1、2、3、4，其中4是栈顶。把4弹出后栈中就剩下里1、2、3。接下来希望被弹出的数字是5，由于它不是栈顶数字，接着我们在第一个序列中把4以后数字压入 <strong><font color=\"#DC143C\">辅助栈</font></strong>，直到压入数字5。这个时候5位于栈顶，就可以被弹出来了。接下来希望弹出的三个数字是3、2、1。由于每次操作前他们都位于栈顶，因此直接弹出即可。以下是该操作的全部过程：</p>\n<p><img src=\"/images/pushStack.png\" alt=\"\"></p>\n<p>接下来再分析弹出序列4、3、5、1、2。第一个弹出的数字4的情况和前面一样。把4弹出之后，3位于栈顶，可以直接弹出。接下来希望弹出的数字是5，由于5不是栈顶数字，到压栈序列里把没有压栈的数字压入辅助栈，直至遇到数字5。把数字5压入栈之后，5就位于栈顶了，可以弹出。此时栈内有两个数字1和2，其中2位于栈顶。由于接下来需要弹出的数字是1，但1不在栈顶，我们需要从压栈序列中尚未压入栈的数字中去搜索这个数字。但此时压栈序列中所有数字都已经压入栈了。所以该序列不是序列1、2、3、4、5对应的弹出序列。<br>该过程如下：</p>\n<p><img src=\"/images/stack.png\" alt=\"\"></p>\n<p>总结以下不是栈弹出序列的规律：</p>\n<p><strong><font color=\"#DC143C\">如果下一个弹出的数字刚好是栈顶数字，直接弹出就可以。如果下一个数字不是栈顶数字，我们把压栈序列中还没有压入栈的数字压入辅助栈，直到把下一个需要弹出的数字压入栈顶为止。如果所有的数字都压入栈了仍然没有找到下一个弹出的数字，那么该序列不可能是一个弹出序列。</font></strong></p>\n<p>函数代码如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isPopOrder</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> * pPush,<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> * pPop, <span class=\"keyword\">int</span> nLength)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">bool</span> bPossible = <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (pPush != <span class=\"literal\">NULL</span> &amp;&amp; pPop != <span class=\"literal\">NULL</span> &amp;&amp; nLength &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> * pNextpush = pPush;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> * pNextpop = pPop;</span><br><span class=\"line\">        <span class=\"built_in\">std</span>::<span class=\"built_in\">stack</span> &lt;<span class=\"keyword\">int</span>&gt; stackData;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (pNextPop - pPop &lt; nLength) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (stackData.empty() || stackData.top() != *pNextPop) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (pNextPush - pPush == nLength)</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                stackData.push(* pNextPush);</span><br><span class=\"line\">                pNextPush ++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (stackData.top() != *pNextPop)</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            stackData.pop();</span><br><span class=\"line\">            pNextPop ++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (stackData.empty() &amp;&amp; pNextPop - pPop == nLength)</span><br><span class=\"line\">            bPossible = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> bPossible;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","categories":[{"name":"面试","slug":"面试","count":15,"path":"api/categories/面试.json"}],"tags":[{"name":"C++","slug":"C","count":13,"path":"api/tags/C.json"}]}