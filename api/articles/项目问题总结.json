{"title":"项目问题总结","slug":"项目问题总结","date":"2018-03-13T15:29:42.000Z","updated":"2018-03-14T09:52:15.000Z","comments":true,"path":"api/articles/项目问题总结.json","photos":[],"link":"","excerpt":"问题一：主机间通信断开链接后重新连接失败，显示接受（C端）端口被占用分析：主机之间建立的链接属于TCP链接，断开的时候会发生TCP四次挥手，过程中C端会进入TIME_WAIT状态，有时S端主动断开链接的时候也会导致S端进入TIME_WAIT状态。即我们断开TCP链接的时候并没有完全断开，此时S端还处于TIME_WAIT，导致通信端口被占用，无法创建新的链接。","covers":["/images/time_wait.png"],"content":"<h2 id=\"问题一：主机间通信断开链接后重新连接失败，显示接受（C端）端口被占用\"><a href=\"#问题一：主机间通信断开链接后重新连接失败，显示接受（C端）端口被占用\" class=\"headerlink\" title=\"问题一：主机间通信断开链接后重新连接失败，显示接受（C端）端口被占用\"></a>问题一：主机间通信断开链接后重新连接失败，显示接受（C端）端口被占用</h2><h3 id=\"分析：\"><a href=\"#分析：\" class=\"headerlink\" title=\"分析：\"></a><font color=\"#DC143C\">分析：</font></h3><p>主机之间建立的链接属于TCP链接，断开的时候会发生TCP四次挥手，过程中C端会进入TIME_WAIT状态，有时S端主动断开链接的时候也会导致S端进入TIME_WAIT状态。即我们断开TCP链接的时候并没有完全断开，此时S端还处于TIME_WAIT，导致通信端口被占用，无法创建新的链接。<a id=\"more\"></a></p>\n<p><img src=\"/images/time_wait.png\" alt=\"\"></p>\n<h3 id=\"为什么会有TIME-WAIT状态的原因：\"><a href=\"#为什么会有TIME-WAIT状态的原因：\" class=\"headerlink\" title=\"为什么会有TIME_WAIT状态的原因：\"></a><font color=\"#DC143C\">为什么会有TIME_WAIT状态的原因：</font></h3><ul>\n<li>可靠的终止TCP链接</li>\n</ul>\n<blockquote>\n<p>若处于time_wait的客户端发送给服务器确认报文段丢失的话，服务器将在此重新发送FIN报文段，那么客户端必须处于一个可接收的状态就是time_wait而不是close状态</p>\n<ul>\n<li>保证让迟来的TCP报文段有足够的时间被识别并丢弃</li>\n</ul>\n<p>linux 中一个TCP端口不能打开两次或两次以上，当客户端处于time_wait状态时我们将无法使用此端口建立新连接，如果不存在time_wait状态，新连接可能会收到旧连接的数据。time_wait持续的时间是2MSL，保证旧的数据可以丢弃，因为网络中的数据最大存在MSL</p>\n</blockquote>\n<h3 id=\"解决TIME-WAIT的状态占用：\"><a href=\"#解决TIME-WAIT的状态占用：\" class=\"headerlink\" title=\"解决TIME_WAIT的状态占用：\"></a><font color=\"#DC143C\">解决TIME_WAIT的状态占用：</font></h3><ul>\n<li>通过socket的选项SO_REUSEADDR来强制进程立即使用处于time_wait状态的连接占用的端口，即使sock处于time_wait状态，与之绑定的socket地址也可以立即被重用 </li>\n<li>修改内核参数/proc/sys/net/ipv4/tcp_tw/recycle来快速回收被关闭的socket,从而是tcp连接根本不进入time_wait状态，进而允许应用程序立即重用本地的socket地址。详细修改方式可以参考文章<a href=\"https://www.cnblogs.com/balaamwe/archive/2011/12/07/2279282.html\" target=\"_blank\" rel=\"noopener\">如何优雅得关闭socket</a></li>\n</ul>\n<h2 id=\"问题二：多个C端同时向数据库写／取数据，如何防止数据被覆盖\"><a href=\"#问题二：多个C端同时向数据库写／取数据，如何防止数据被覆盖\" class=\"headerlink\" title=\"问题二：多个C端同时向数据库写／取数据，如何防止数据被覆盖\"></a>问题二：多个C端同时向数据库写／取数据，如何防止数据被覆盖</h2><h4 id=\"MySQL的并发控制与加锁分析\"><a href=\"#MySQL的并发控制与加锁分析\" class=\"headerlink\" title=\"MySQL的并发控制与加锁分析\"></a>MySQL的并发控制与加锁分析</h4>","categories":[{"name":"面试","slug":"面试","count":36,"path":"api/categories/面试.json"}],"tags":[]}