{"title":"C++开发面试问题准备：剑指 offer--二叉树的镜像和顺时针打印矩阵","slug":"C-面试问题准备：剑指-offer-二叉树的镜像和顺时针打印矩阵","date":"2018-02-08T09:31:05.000Z","updated":"2018-02-08T11:24:22.000Z","comments":true,"path":"api/articles/C-面试问题准备：剑指-offer-二叉树的镜像和顺时针打印矩阵.json","photos":[],"link":"","excerpt":"二叉树的镜像题目描述：完成一个函数，输入一个二叉树，该函数输出它的镜像如图： [Figure] ","covers":["/images/treeMirror.jpg","/images/tree2.jpg","/images/matrix.jpg","/images/matrix2.jpg","/images/matrix1.jpg"],"content":"<h2 id=\"二叉树的镜像\"><a href=\"#二叉树的镜像\" class=\"headerlink\" title=\"二叉树的镜像\"></a>二叉树的镜像</h2><blockquote>\n<p>题目描述：完成一个函数，输入一个二叉树，该函数输出它的镜像</p>\n</blockquote>\n<p>如图：</p>\n<p><img src=\"/images/treeMirror.jpg\" alt=\"二叉树镜像\">    <a id=\"more\"></a></p>\n<p>我们需要总结自己的解题步骤，尝试一下，将该二叉树的根结点的左右子节点进行交换，得到了如下图的结果</p>\n<p>这个时候发现还不是镜像，因为两个根结点子节点之后还有节点，那么也需要交换该子节点的位置。</p>\n<p>综上可得顺序如下：</p>\n<p><img src=\"/images/tree2.jpg\" alt=\"二叉树镜像\"></p>\n<p>那么我们便可以总结求一棵树的镜像的过程：<strong><font color=\"#DC143C\">先序遍历这棵树的每个结点，如果遍历到的结点有子结点，就交换子结点。</font></strong></p>\n<p>代码如下：<br><figure class=\"highlight coq\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct treeNode &#123;</span><br><span class=\"line\">    int value;</span><br><span class=\"line\">    struct treeNode* <span class=\"built_in\">left</span>;</span><br><span class=\"line\">    struct treeNode* <span class=\"built_in\">right</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//递归解法</span><br><span class=\"line\">void mirrorRecursively(treeNode * pNode) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (pNode == NULL |<span class=\"type\">| (pNode</span> -&gt; <span class=\"built_in\">left</span> == NULL &amp;&amp; pNode -&gt; <span class=\"built_in\">right</span> == NULL))</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    treeNode *temp = pNode -&gt; <span class=\"built_in\">left</span>;</span><br><span class=\"line\">    pNode -&gt; <span class=\"built_in\">left</span> = pNode -&gt; <span class=\"built_in\">right</span>;</span><br><span class=\"line\">    pNode -&gt; <span class=\"built_in\">right</span> = temp;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (pNode -&gt; <span class=\"built_in\">left</span>)</span><br><span class=\"line\">        mirrorRecursively(pNode -&gt; <span class=\"built_in\">left</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (pNode -&gt; <span class=\"built_in\">right</span>)</span><br><span class=\"line\">        mirrorRecursively(pNode -&gt; <span class=\"built_in\">right</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//非递归解法,利用栈实现遍历</span><br><span class=\"line\">void mirrorNonRecursively(treeNode * pNode) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (pNode == NULL |<span class=\"type\">| (pNode</span> -&gt; <span class=\"built_in\">left</span> == NULL &amp;&amp; pNode -&gt; <span class=\"built_in\">right</span> == NULL))</span><br><span class=\"line\">         <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    stack &lt;treeNode *&gt; s;</span><br><span class=\"line\">     while(pNode |<span class=\"type\">| !s</span>.empty()) &#123;</span><br><span class=\"line\">        while(pNode) &#123;</span><br><span class=\"line\">            s.push(pNode);</span><br><span class=\"line\">            pNode = pNode -&gt; <span class=\"built_in\">left</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        pNode = s.<span class=\"built_in\">top</span>();</span><br><span class=\"line\">        s.pop();</span><br><span class=\"line\">        //先从叶子结点进行交换</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (pNode -&gt; <span class=\"built_in\">right</span> |<span class=\"type\">| pNode</span> -&gt; <span class=\"built_in\">left</span>) &#123;</span><br><span class=\"line\">             treeNode *temp = pNode -&gt; <span class=\"built_in\">left</span>;</span><br><span class=\"line\">             pNode -&gt; <span class=\"built_in\">left</span> = pNode -&gt; <span class=\"built_in\">right</span>;</span><br><span class=\"line\">             pNode -&gt; <span class=\"built_in\">right</span> = temp;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"顺时针打印矩阵\"><a href=\"#顺时针打印矩阵\" class=\"headerlink\" title=\"顺时针打印矩阵\"></a>顺时针打印矩阵</h2><blockquote>\n<p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。</p>\n</blockquote>\n<p>如下矩阵：</p>\n<p><img src=\"/images/matrix.jpg\" alt=\"\"></p>\n<p>则一次打印出来的顺序为：1，2，3，4，8，12，16，15，14，13，9，5，6，7，11，10</p>\n<p>我们可以找到打印的规律，将矩阵想象成若干个圈，可以用循环来打印，每次打印矩阵的一个圈就可以。如下图：</p>\n<p><img src=\"/images/matrix2.jpg\" alt=\"\"></p>\n<p>这个时候我们分析循环结束的条件，打印第一圈左上角的坐标为（0,0)，第二圈左上角的坐标为（1,1），依次类推第n圈坐标为（n,n）。我们可以取左上角坐标为（start，start）为一圈的分析目标。</p>\n<p>我们能够发现对于一个5 X 5的矩阵而言，最后一圈只有一个数字，坐标为（2，2）。我们发现5 &gt; 2 <em> 2.对于一个6 X 6的矩阵而言，最后一圈有四个数字，左上角坐标仍为（2，2），显然满足6 &gt; 2 </em> 2.同样对于一个7 X 7的矩阵而言，最后一圈有一个数字，坐标为(3,3)，满足7 &gt; 3 * 2.</p>\n<p>于是我们可以得出结论，让循环继续的条件是rows &gt; startX <em> 2且columns &gt; startY </em> 2.</p>\n<p>则可以用以下代码循环打印一圈矩阵：</p>\n<figure class=\"highlight excel\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void printMatrix(<span class=\"built_in\">int</span> ** numbers, <span class=\"built_in\">int</span> <span class=\"built_in\">rows</span>, <span class=\"built_in\">int</span> <span class=\"built_in\">columns</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">if</span> (numbers == NULL || <span class=\"built_in\">columns</span> &lt;= <span class=\"number\">0</span> || <span class=\"built_in\">rows</span> &lt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">        return ;</span><br><span class=\"line\">    <span class=\"built_in\">int</span> start = <span class=\"number\">0</span>;</span><br><span class=\"line\">    while(start * <span class=\"number\">2</span> &lt; <span class=\"built_in\">rows</span> &amp;&amp; start * <span class=\"number\">2</span> &lt; <span class=\"built_in\">columns</span>) &#123;</span><br><span class=\"line\">        printMatrixInCircle(numbers, <span class=\"built_in\">rows</span>,<span class=\"built_in\">columns</span>,start);</span><br><span class=\"line\">        ++ start;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>接下来考虑如何打印一圈的矩阵，我们可以将打印分为四部分，即四种打印情况：从左到右，从上到下，从右到左，从下到上。如图：</p>\n<p><img src=\"/images/matrix1.jpg\" alt=\"\"></p>\n<p>第一步打印肯定有，即从左到右。要想拥有第二步打印，即从上到下，那么必须满足终止行号大于起始行号。要想拥有第三步，从右到左打印，那么必须满足两个条件：终止行号大于起始行号、终止列号大于起始列号。要想拥有第四步，从下到上打印，当前矩阵至少有三行两列，需要满足：终止列号大于起始列号、终止行号大于（起始行号-1）。</p>\n<p>代码如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">printMatrixInCircle</span><span class=\"params\">(<span class=\"keyword\">int</span> ** numbers,<span class=\"keyword\">int</span> rows,<span class=\"keyword\">int</span> columns,<span class=\"keyword\">int</span> start)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> endX = rows - <span class=\"number\">1</span> - start;<span class=\"comment\">//终止行号</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> endY = columns - <span class=\"number\">1</span> - start;<span class=\"comment\">//终止列号</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//从左到右</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = start;i &lt;= endY; ++ i)</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\"</span>,numbers[start][i]);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//从上到下</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (start &lt; endX)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = start;i &lt;= endX; ++ i)</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\"</span>,numbers[i][endY]);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//从右到左</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (start &lt; endX &amp;&amp; start &lt; endY)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = endY;i &gt;= start; -- i)</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\"</span>,numbers[endX][i]);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//从下到上</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (start &lt; endX - <span class=\"number\">1</span> &amp;&amp; start &lt; endY)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = endX; i &gt;= start; -- i)</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\"</span>,numbers[i][start]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>具体测试实现这里就不多说了，相信大家读懂思路之后代码就是顺手拈来！</p>\n","categories":[{"name":"面试","slug":"面试","count":8,"path":"api/categories/面试.json"}],"tags":[{"name":"C++","slug":"C","count":10,"path":"api/tags/C.json"}]}