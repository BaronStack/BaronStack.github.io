{"title":"C++面试问题准备：STL-iterator","slug":"C-面试问题准备：STL-iterator","date":"2018-02-11T12:53:12.000Z","updated":"2018-02-22T12:54:00.000Z","comments":true,"path":"api/articles/C-面试问题准备：STL-iterator.json","photos":[],"link":"","excerpt":"这两天在家里没有好好读书，要反思一下。今天看《STL源码剖析》到了迭代器iterator这里什么是迭代器在《Design Patterns》中对迭代器模式的描述如下：提供一种方法，使之能够依序寻访某个聚合物（容器）所含的各个元素，而又无需暴露该聚合物内部表现方式","covers":null,"content":"<blockquote>\n<p>这两天在家里没有好好读书，要反思一下。今天看《STL源码剖析》到了迭代器iterator这里</p>\n</blockquote>\n<h2 id=\"什么是迭代器\"><a href=\"#什么是迭代器\" class=\"headerlink\" title=\"什么是迭代器\"></a>什么是迭代器</h2><p>在《Design Patterns》中对迭代器模式的描述如下：<font color=\"#DC143C\">提供一种方法，使之能够依序寻访某个聚合物（容器）所含的各个元素，而又无需暴露该聚合物内部表现方式</font> <a id=\"more\"></a></p>\n<blockquote>\n<p>这里小小的回忆下我们复习过的面向对象五大原则，显然该设计模式满足单一职责原则(<strong>对于迭代器来说只有元素地址能够引起它的变化</strong>)以及接口隔离(<strong>迭代器的设计就是为了访问数据元素，即访问接口</strong>)原则。详细请看<a href=\"https://baronstack.github.io/#/posts/C-面试问题准备：面向对象的基本原则\" target=\"_blank\" rel=\"noopener\">面向对象基本原则</a></p>\n</blockquote>\n<p>观察如下代码：</p>\n<figure class=\"highlight applescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;<span class=\"built_in\">class</span> InputIterator,<span class=\"built_in\">class</span> T&gt;</span><br><span class=\"line\">InputIterator find (InputIterator <span class=\"keyword\">first</span>,InputIterator <span class=\"keyword\">last</span>,const T&amp; value) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"keyword\">first</span> != <span class=\"keyword\">last</span> &amp;&amp; *<span class=\"keyword\">first</span> != value)</span><br><span class=\"line\">        ++ <span class=\"keyword\">first</span>;</span><br><span class=\"line\"><span class=\"built_in\">    return</span> <span class=\"keyword\">first</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这是一段find()函数的源码，显然我们能够发现，给予不同的迭代器，find函数便能够对不同的容器进行查找操作。</p>\n<p>在本书STL中，对本书迭代器的描述是:<font color=\"#DC143C\">迭代器是一种行为类似指针的对象。</font>而指针的各种行为中最为常见也最重要的便是内容提领和成员访问。因此迭代器最重要的工作就是<font color=\"#DC143C\">对operator*和operator-&gt;进行重载</font>。这里对内容提领和成员访问的描述可以先参考原生态指针auto_ptr的简化代码：</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;class T&gt;</span><br><span class=\"line\">class auto_ptr &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span>:</span><br><span class=\"line\">        <span class=\"keyword\">explicit</span> auto_ptr(T *p = <span class=\"number\">0</span>) : pointee(p) () <span class=\"comment\">//explicit构造函数是用来防止隐式转换的,使得代码更加清晰明确</span></span><br><span class=\"line\">        <span class=\"keyword\">template</span> &lt;class U&gt;</span><br><span class=\"line\">        auto_ptr(auto_ptr&lt;U&gt;&amp; rhs) : pointee(rhs.<span class=\"built_in\">release</span>()) &#123;&#125;</span><br><span class=\"line\">        ~auto_ptr() ( <span class=\"keyword\">delete</span> pointee; )</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">template</span>&lt;class U&gt;</span><br><span class=\"line\">        auto_ptr&lt;T&gt; &amp; <span class=\"keyword\">operator</span>=(auto_ptr&lt;U&gt; &amp; rhs) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">if</span> (<span class=\"keyword\">this</span> != &amp;rhs) </span><br><span class=\"line\">                reset(rhs.<span class=\"built_in\">release</span>());</span><br><span class=\"line\">            <span class=\"built_in\">return</span> *<span class=\"keyword\">this</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        T&amp; <span class=\"keyword\">operator</span>*() <span class=\"keyword\">const</span> &#123; <span class=\"built_in\">return</span> *pointee; &#125;</span><br><span class=\"line\">        T* <span class=\"keyword\">operator</span>-&gt; () <span class=\"keyword\">const</span> &#123; <span class=\"built_in\">return</span> pointee; &#125;</span><br><span class=\"line\">        T* <span class=\"built_in\">get</span> <span class=\"keyword\">const</span> &#123; <span class=\"built_in\">return</span> pointee; &#125;</span><br><span class=\"line\">        <span class=\"comment\">//..</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span>:</span><br><span class=\"line\">        T *pointee;</span><br><span class=\"line\">&#125;; </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> func() &#123;</span><br><span class=\"line\">    auto_ptr&lt;<span class=\"keyword\">string</span>&gt; ps(<span class=\"keyword\">new</span> <span class=\"keyword\">string</span>(<span class=\"string\">\"jjhou\"</span>));<span class=\"comment\">//auto_ptr括号内放置的是\"原生指针所指对象的型别\"，而非原生指针的型别</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    cout &lt;&lt; *ps &lt;&lt; endl; <span class=\"comment\">//output:jjhou</span></span><br><span class=\"line\">    cout &lt;&lt; ps -&gt; <span class=\"built_in\">size</span>() &lt;&lt; endl; <span class=\"comment\">//output:5</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"迭代器的相应型别\"><a href=\"#迭代器的相应型别\" class=\"headerlink\" title=\"迭代器的相应型别\"></a>迭代器的相应型别</h2><p>在算法中运用迭代器很可能会用到其相应型别，即：迭代器所指之物便是其中之一。<br>如果我们在算法中想要声明一个变量，以”迭代器所指对象的型别”为型别，改怎么办？毕竟C++只支持sizeof(),并不支持typeof()!即便是动用RTTI性质中的typeid(),获得的也只是型别名称，不能拿来做变量声明之用。<br>解决办法是利用<code>function template</code>的参数推导机制：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">I</span>,<span class=\"title\">class</span> <span class=\"title\">Y</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">void</span> <span class=\"title\">func_impl</span>(<span class=\"title\">I</span> <span class=\"title\">iter</span>, <span class=\"title\">T</span> <span class=\"title\">t</span>) &#123;</span></span><br><span class=\"line\">    T tmp;<span class=\"comment\">//这里解决了问题，T就是所指之物的型别，本例为int</span></span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">I</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">inline</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">void</span> <span class=\"title\">func</span>(<span class=\"title\">I</span> <span class=\"title\">iter</span>) &#123;</span></span><br><span class=\"line\">    func_impl(iter,*iter);<span class=\"comment\">//func的全部工作移往func_imp1</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i;</span><br><span class=\"line\">    func(&amp;i);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>我们以func()为对外接口，却把实际操作全部置于func_impl()之中。由于func_impl()是一个function template，一旦被调用，编译器会自动进行template参数推导。于是导出型别T，顺利解决问题</strong></p>\n<p>常用的迭代器相应型别有五种，且并非任何情况下任何一种都可利用上述的template参数推导机制来取得。</p>\n","categories":[{"name":"面试","slug":"面试","count":12,"path":"api/categories/面试.json"}],"tags":[{"name":"C++","slug":"C","count":10,"path":"api/tags/C.json"}]}