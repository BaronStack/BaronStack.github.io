{"title":"C++开发面试问题准备：源程序编译过程以及静态链接和动态链接的区别","slug":"C-开发面试问题准备：静态链接和动态链接","date":"2018-02-07T04:44:33.000Z","updated":"2018-02-07T09:36:27.000Z","comments":true,"path":"api/articles/C-开发面试问题准备：静态链接和动态链接.json","photos":[],"link":"","excerpt":"在Linux下我们用GCC对源码进行编译，编译的过程中有一个步骤是链接。这里我们先了解一下编译的过程，我在xmind中画的一个图如下，对软件不够熟悉，所以画得比较丑。 [Figure] 大体分为一下几个步骤：预处理（Preprocess）编译(Complication)汇编(Assembly)链接(Linking)执行(Execute)","covers":["/images/Compile&amp;&amp;Linking.png"],"content":"<p>在Linux下我们用GCC对源码进行编译，编译的过程中有一个步骤是链接。这里我们先了解一下编译的过程，我在xmind中画的一个图如下，对软件不够熟悉，所以画得比较丑。</p>\n<p><img src=\"/images/Compile&amp;&amp;Linking.png\" alt=\"编译过程\"></p>\n<p>大体分为一下几个步骤：</p>\n<ul>\n<li>预处理（Preprocess）</li>\n<li>编译(Complication)</li>\n<li>汇编(Assembly)</li>\n<li>链接(Linking)</li>\n<li>执行(Execute)<a id=\"more\"></a>\n<h2 id=\"预处理\"><a href=\"#预处理\" class=\"headerlink\" title=\"预处理\"></a><strong>预处理</strong></h2></li>\n</ul>\n<p>首先源码文件（.c/.cpp）和相关头文件(.h)被预处理器与编译成(.i)文件，大家可以在终端下输入：</p>\n<p><code>gcc -E hello.cpp -o hello.i</code></p>\n<p><code>hello.i</code>就是预编译之后的源码文件。</p>\n<p>预处理主要是进行一下几个过程：</p>\n<ul>\n<li>将所有的<code>#define</code>删除，并在程序中展开调用该宏的代码</li>\n<li>处理所有的条件编译指令（该指令的作用：<strong>防止头文件的重复包含和编译，即编译的时候只编译<code>#if</code>与<code>#endif</code>之间的代码</strong>），如#if ,#ifdef</li>\n<li>处理<code>#include</code>包含指令，将被包含的文件插入到该预编译指令的位置，该过程是递归进行的，被包含的文件可能还包含其他文件。</li>\n<li>删除所有的注释\\\\和\\<em>…\\</em>\\</li>\n<li>添加行号和文件标识，如#2 “hello.c” 2,以便于编译时编译器产生调试用的行号信息及用于编译时产生编译错误或警告时能够显示行号信息</li>\n<li>保留所有的#pragma编译器指令，因为编译器须要使用它们</li>\n</ul>\n<h2 id=\"编译\"><a href=\"#编译\" class=\"headerlink\" title=\"编译\"></a><strong>编译</strong></h2><p>编译的过程就是编译器进行一系列的词法分析下、语法分析、语义分析及优化后生成的汇编代码。可以在终端输入以下代码进行编译：</p>\n<p><code>gcc –S hello.i –o hello.s</code></p>\n<p>或者从源文件直接生成汇编代码</p>\n<p><code>gcc –S hello.c –o hello.s</code></p>\n<p>编译主要进行的以下几个过程内容为：</p>\n<ul>\n<li>词法分析：<font color=\"#DC143C\"> 输入源程序，对构成源程序的字符串进行扫描和分解，识别出一个个的单词（亦称单词符号或简称符号），如基本字（begin、end、if、for、while），标识符、常数、运算符和界符（标点符号、左右括号）</font></li>\n<li>语法分析：<font color=\"#DC143C\"> 在词法分析的基础上，根据语言的语法规则，把单词符号串分解成各类语法单位（语法范畴），如“短语”、“句子”、“程序段”和“程序”等。通过语法分析，确定整个输入串是否构成语法上正确的“程序”。</font></li>\n<li>语义分析（加中间代码生成）：<font color=\"#DC143C\"> 对每种语法范畴进行语义i安插，例如，变量是否定义、类型是否正确等等。如果语义正确，则进行另一方面工作，即进行中间代码的解释。这一阶段所依循的是语言的语义规则。通常使用属性文法描述语义规则</font></li>\n<li>汇编代码生成（一般在这之前还有一个优化的过程：依赖程序的等价变换规则，主要进行：公关子表达式的提取、循环优化、删除无用代码等）：<font color=\"#DC143C\">把中间代码（或经优化处理之后）变换成特定机器上的低级语言代码,一般就是变成汇编代码</font></li>\n</ul>\n<h2 id=\"汇编\"><a href=\"#汇编\" class=\"headerlink\" title=\"汇编\"></a><strong>汇编</strong></h2><p>汇编就是将汇编代码转变成机器可以执行的命令，生成目标文件（.o），汇编器as根据汇编指令和机器指令的对照表一一翻译即可完成。可以在终端输入以下代码进行汇编文件的生成：</p>\n<p><code>gcc –c hello.s –o hello.o</code></p>\n<p>或者由源文件生成汇编代码：</p>\n<p><code>gcc –c hello.c –o hello.o</code></p>\n<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a><strong>链接</strong></h2><p>链接就是链接器ld将各个目标文件组装在一起，解决符号依赖，库依赖关系，并生成可执行文件。可以在终端输入以下命令进行链接：</p>\n<p><code>ld –static crt1.o crti.o crtbeginT.o hello.o –start-group –lgcc –lgcc_eh –lc-end-group crtend.o crtn.o</code></p>\n<blockquote>\n<p>关于动态链接和静态链接的区别如下：</p>\n</blockquote>\n<p><strong><font color=\"#00FFFF\">静态链接：</font></strong></p>\n<font color=\"#00FFFF\">在生成可执行文件的时候(链接阶段)，把所有需要的函数的二进制代码都包含到可执行文件中去。因此，链接器需要知道参与链接的目标文件需要哪些函数，同时也要知道每个目标文件都能提供什么函数，这样链接器才能知道是不是每个目标文件所需要的函数都能正确地链接。如果某个目标文件需要的函数在参与链接的目标文件中找不到的话，链接器就报错了。目标文件中有两个重要的接口来提供这些信息：一个是符号表，另外一个是重定位表</font>\n\n<font color=\"#DC143C\">核心思想：将不同的可重定位模块打包成一个文件，在链接的时候会自动从这个文件中抽取出用到的模块</font>\n\n<ul>\n<li>优点：在程序发布的时候就不需要的依赖库，也就是不再需要带着库一块发布，程序可以独立执行</li>\n<li>缺点：<ol>\n<li>程序体积会相对大一些</li>\n<li>如果静态库有更新的话，所有可执行文件都得重新链接才能用上新的静态库,不够灵活</li>\n</ol>\n</li>\n</ul>\n<p><strong><font color=\"#00FFFF\">动态链接：</font></strong></p>\n<font color=\"#00FFFF\">在编译的时候不直接拷贝可执行代码，而是通过记录一系列符号和参数，在程序运行或加载时将这些信息传递给操作系统，操作系统负责将需要的动态库加载到内存中，然后程序在运行到指定的代码时，去共享执行内存中已经加载的动态库可执行代码，最终达到运行时连接的目的</font>\n\n<font color=\"#DC143C\">核心思想是：代码共享和延迟绑定</font>\n\n<ul>\n<li>优点：多个程序可以共享同一段代码，而不需要在磁盘上存储多个拷贝</li>\n<li>缺点：由于是运行时加载，可能会影响程序的前期执行性能</li>\n</ul>\n<p><strong><font color=\"#00FFFF\">库：</font></strong><br>一些功能代码经过编译连接后的可执行形式</p>\n<ul>\n<li>静态lib将导出声明和实现都放在lib中。编译后所有代码都嵌入到宿主程序。</li>\n<li>动态lib相当于一个h文件，是对实现部分（.dll文件）的导出部分的声明。编译后只是将导出声明部分编译到宿主程序中，运行时候需要相应的dll文件支持。</li>\n</ul>\n","categories":[{"name":"面试","slug":"面试","count":7,"path":"api/categories/面试.json"}],"tags":[{"name":"C++","slug":"C","count":9,"path":"api/tags/C.json"}]}