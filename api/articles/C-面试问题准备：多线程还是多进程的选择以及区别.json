{"title":"C++面试问题准备：进程、线程、死锁、多线程还是多进程的选择以及区别","slug":"C-面试问题准备：多线程还是多进程的选择以及区别","date":"2018-03-04T12:27:20.000Z","updated":"2018-03-09T15:43:05.000Z","comments":true,"path":"api/articles/C-面试问题准备：多线程还是多进程的选择以及区别.json","photos":[],"link":"","excerpt":"进程和线程的区别一个进程由一个或多个线程组成，线程是一个进程中代码的不同执行路线；进程之间相互独立，但同一进程下的各个线程之间共享程序的内存空间(包括代码段、数据集、堆等)及一些进程级的资源(如打开文件和信号)，某进程内的线程在其它进程不可见调度和切换：线程上下文切换比进程上下文切换要快得多","covers":["/images/deadLock.jpg","/images/moreIPC.png"],"content":"<h2 id=\"进程和线程的区别\"><a href=\"#进程和线程的区别\" class=\"headerlink\" title=\"进程和线程的区别\"></a>进程和线程的区别</h2><ul>\n<li>一个进程由一个或多个线程组成，线程是一个进程中代码的不同执行路线；</li>\n<li>进程之间相互独立，但同一进程下的各个线程之间共享程序的内存空间(包括代码段、数据集、堆等)及一些进程级的资源(如打开文件和信号)，某进程内的线程在其它进程不可见</li>\n<li>调度和切换：线程上下文切换比进程上下文切换要快得多<a id=\"more\"></a>\n</li>\n</ul>\n<p><strong>进程几种状态</strong>：</p>\n<p>创建态：进程正在创建，操作系统在创建进程时要进行的工作包括分配和建立进程控制块表项、建立资源表格并分配资源、加载程序并建立地址空间。</p>\n<p>就绪态：时间片被用完，此线程被强制暂停，等待下一个属于它的时间片到来</p>\n<p>运行态：此线程正在执行，正在占用时间片</p>\n<p>阻塞：也叫等待状态，等待某一事件（如IO或另一个线程）执行完</p>\n<p>退出：进程已结束，所以也称结束状态，释放操作系统分配的资源。</p>\n<p><strong>线程几种状态</strong>：</p>\n<p>创建：一个新的线程被创建，等待该线程被调用执行  </p>\n<p>就绪：时间片已用完，此线程被强制暂停，等待下一个属于他的时间片到来  </p>\n<p>运行：此线程正在执行，正在占用时间片  </p>\n<p>阻塞：也叫等待状态，等待某一事件(如IO或另一个线程)执行完  </p>\n<p>退出：一个线程完成任务或者其他终止条件发生，该线程终止进入退出状态，退出状态释放该线程所分配的资源</p>\n<blockquote>\n<p><strong><font color=\"#DC143C\">线程共享的资源</font></strong>:<br> a. 堆：堆是在进程空间中开辟出来的，所以它是理所当然地被共享的。因此由malloc和new出来的都是共享的<br> b. 全局变量：它是与具体某一函数无关的，所以也与特定线程无关；因此也是共享的<br> c. 静态变量：即使是局部变量，在该局部变量存在的函数对于整个程序生存期间只有一份拷贝；因此也是共享的<br> d. 文件等公用资源：这个是共享的，使用这些公共资源的线程必须同步。windows下存在的几种线程同步资源的方式：信号、临界区、事件、互斥体<br> <strong><font color=\"#DC143C\">线程独享的资源</font></strong>:<br> a. 线程ID:每个线程都有自己的线程ID，这个ID在本进程中是唯一的。进程用此来标识线程。<br> b. 寄存器组的值:由于线程间是并发运行的，每个线程有自己不同的运行线索，当从一个线程切换到另一个线程上时，必须将原有的线程的寄存器集合的状态保存，以便将来该线程在被重新切换到时能得以恢复。<br> c. 线程的堆栈:<font color=\"#DC143C\">堆栈是保证线程独立运行所必须的.</font>线程函数可以调用函数，而被调用函数中又是可以层层嵌套的，所以线程 必须拥有自己的函数堆栈，使得函数调用可以正常执行，不受其他线程的影响。<br> d. 错误返回码:由于同一个进程中有很多个线程在同时运行，可能某个线程进行系统调用 后设置了errno值，而在该线程还没有处理这个错误，另外一个线程就在此时被调度器投入运行，这样错误值就有可能被修改<br> e. 线程的信号屏蔽码:由于每个线程所感兴趣的信号不同，所以线程的信号屏蔽码应该由线程自己管理。但所有的线程都共享同样的信号处理器<br> f. 线程的优先级:由于线程需要像进程那样能够被调度，那么就必须要有可供调度使用的参数，这个参数就是线程的优先级</p>\n</blockquote>\n<p> <strong><font color=\"#DC143C\">如果有一组线程，每个线程都在等待一个事件的发生，而这个事件只能由该组线程里面的另一个线程发出，则称这组线程发生了死锁</font></strong></p>\n <figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">线程A        线程B</span><br><span class=\"line\"><span class=\"keyword\">lock</span>(x);       <span class=\"keyword\">lock</span>(y);</span><br><span class=\"line\"><span class=\"keyword\">lock</span>(y);       <span class=\"keyword\">lock</span>(x);</span><br><span class=\"line\">...            ...</span><br><span class=\"line\"><span class=\"keyword\">unlock</span>(y);     <span class=\"keyword\">unlock</span>(x);</span><br><span class=\"line\"><span class=\"keyword\">unlock</span>(x);     <span class=\"keyword\">unlock</span>(y);</span><br></pre></td></tr></table></figure>\n<p>两线程交替执行，则会发生死锁。</p>\n<h4 id=\"死锁的必要条件\"><a href=\"#死锁的必要条件\" class=\"headerlink\" title=\"死锁的必要条件\"></a><strong>死锁的必要条件</strong></h4><ul>\n<li>资源有限：资源不能共享，在一个时候只能由一个线程使用。否则肯定不会发生死锁的。</li>\n<li>持有等待：一个线程在请求新的资源时，其已经获得的资源并不释放，而是继续持有。一个线程在请求资源时，其并没有持有任何资源，自然就不会阻挠别的线程运行。</li>\n<li>不能抢占：如果可以抢占别的线程正在占用的资源，则也不会发生死锁。</li>\n<li>循环等待：如果你等我、我等你、大家都在等着对方，就产生了死锁。</li>\n</ul>\n<h4 id=\"死锁的应对\"><a href=\"#死锁的应对\" class=\"headerlink\" title=\"死锁的应对\"></a><strong>死锁的应对</strong></h4><p><strong><font color=\"#DC143C\">顺其自然：不予理睬</font></strong></p>\n<p>即操作系统不做任何措施，任由死锁发生。在商业操作系统中，死锁发生的频率并不是很高，而且防止死锁的代价很高，比重启100次代价还高。所以有的时候什么也不做其实更好。</p>\n<p><strong><font color=\"#DC143C\">先礼后兵：死锁监测与修复</font></strong></p>\n<p>在高可靠性系统、实时控制系统那就需要进行死锁的防止了。</p>\n<ul>\n<li><p>死锁的检测：死锁的原因是资源竞争，我们只要对资源的拥有和对资源的请求都很清楚的话问题就解决了。</p>\n<ol>\n<li>将线程的资源占用和需求关系用一个有向图表示出来，再检查图中有没有循环，如果有，就发生死锁。但是这种检车算法的事件复杂度为O(n^3)，如果每次资源分配发生变化的时候，做这样一次检查系统效率会出现明显下降。</li>\n</ol>\n<p><img src=\"/images/deadLock.jpg\" alt=\"\"></p>\n<ol>\n<li>利用矩阵：资源分配矩阵和资源等待矩阵。同时维持两个矢量：系统资源总量矢量，表示系统中所有资源的总数是多少；另一个是系统当前可用资源矢量，代表系统还有多少可用资源。<strong><font color=\"#DC143C\">我们将可用资源拿来与资源等待矩阵每一次进行比较，你就知道谁不能满足，如果减出来，每个线程都有负数，那就是发生了死锁。</font></strong></li>\n</ol>\n</li>\n<li>死锁的恢复：<ol>\n<li>抢占：将某个线程所占用的资源强行拿走，分配给别的线程。被抢占的线程很有可能不能正确运行。而且结果很难预料</li>\n<li>杀掉：讲整个线程kill,因为抢占该线程的资源有可能已经造成该线程无法再正确运行。结果也是很难预料</li>\n<li>上翻：即将整个系统反转到过去的某个状态，大家从那个状态重新来过。<blockquote>\n<p>该策略实际上根本行不通，在检测与恢复两个部分都存在巨大困难。致命的问题是：检查死锁的线程自己发生了死锁，此时，死锁检查程序已经无法推进，自然无法检查死锁是否发生。</p>\n</blockquote>\n</li>\n</ol>\n</li>\n</ul>\n<p><strong><font color=\"#DC143C\">先发制人：死锁的动态避免</font></strong></p>\n<p>在每次进行资源分配时，必须经过仔细计算，确保该资源请求批准后系统不会进入死锁或潜在的死锁状态。</p>\n<ul>\n<li>安全状态：从该状态开始，我们能够找到一种资源分配方法和顺序，使得所有的线程都能获得其所需要的资源，从而不会产生死锁。</li>\n<li>不安全状态：尚未发生死锁的状态，但接下来的执行一定会产生死锁。</li>\n</ul>\n<p><strong><font color=\"#DC143C\">执行手段：防止系统进入不安全状态，每次进行资源分配的时候计算一下该分配是否会将系统带入不安全状态，如果是，就否决相关资源请求；否则，就批准。</font></strong></p>\n<blockquote>\n<p>动态避免的<br>优点：无需等待死锁的发生。<br>缺点：计算一个状态是否安全并不容易。如果一个系统资源种类繁杂，线程个数庞大，这种计算将变得十分复杂和费时。更致命的是我们想要预测一个线程的最大资源需求是，进行的估算按照人类一般的超额估算来说是会造成非常严重的后果：资源浪费，死锁误判。</p>\n</blockquote>\n<p><strong><font color=\"#DC143C\">斩草除根：死锁的静态防止</font></strong><br>清除死锁发生的土壤，消除死锁发生的4个必要条件中的任何一个，则死锁将无法发生。</p>\n<ul>\n<li>消除资源独占条件：将资源无限增加或把所有资源变为共享。比如打印机，它是不允许任何线程直接占有，而是设计一个”精灵”程序daemon来管理，所有打印任务都必须经由它发出。</li>\n<li>消除持有等待条件：一个线程必须一次请求其所需要的所有资源，而不是一般情况下的请求一点资源，做一点事情；到需要下一个资源的时候再请求一点，这样获得资源后再将整个程序推进。</li>\n<li>消除非抢占条件：允许抢占资源，可以从一个线程手上将资源抢夺过来。一个线程可以将CPU或内存空间从一个线程手上抢过来，从而避免了因CPU和内存空间的竞争造成死锁。<font color=\"#DC143C\">并不是所有的资源都可以被抢占而不产生不良后果，例如锁</font></li>\n<li>消除循环等待条件：一个线程可以先请求资源A再请求资源B，也可以先请求B再请求资源A。这样如果两个线程按照按照不同的顺序请求A、B两个资源，死锁就有可能发生。但是我们可以规定对A、B两个资源的使用必须按照先A后B的顺序请求，则死锁就不会发生。</li>\n</ul>\n<h2 id=\"多进程-和多线程的区别\"><a href=\"#多进程-和多线程的区别\" class=\"headerlink\" title=\"多进程 和多线程的区别\"></a>多进程 和多线程的区别</h2><blockquote>\n<p>进程是资源分配的最小单位，线程是CPU调度的最小单位。 <!--more--></p>\n</blockquote>\n<p>关于多进程和多线程的区别可以参考如下图：</p>\n<p><img src=\"/images/moreIPC.png\" alt=\"\"></p>\n<h2 id=\"多进程和多线程的选择\"><a href=\"#多进程和多线程的选择\" class=\"headerlink\" title=\"多进程和多线程的选择\"></a>多进程和多线程的选择</h2><p><strong><font color=\"#DC143C\">需频繁创建销毁的优先用线程</font></strong></p>\n<p>这种原则最常见的应用就是Web服务器了，来一个连接建立一个线程，断了就销毁线程，要是用进程，创建和销毁的代价是很难承受的</p>\n<p><strong><font color=\"#DC143C\">需要进行大量计算的优先使用线程</font></strong></p>\n<p>大量计算当然就是要耗费很多CPU，切换频繁了，这种情况下线程是最合适的，一般应用在：图像处理和算法处理。</p>\n<p><strong><font color=\"#DC143C\">强相关的处理用线程，弱相关的处理用进程</font></strong></p>\n<p>一般的Server需要完成如下任务：消息收发、消息处理。“消息收发”和“消息处理”就是弱相关的任务，而“消息处理”里面可能又分为“消息解码”、“业务处理”，这两个任务相对来说相关性就要强多了。因此“消息收发”和“消息处理”可以分进程设计，“消息解码”、“业务处理”可以分线程设计。</p>\n","categories":[{"name":"面试","slug":"面试","count":28,"path":"api/categories/面试.json"}],"tags":[{"name":"C++","slug":"C","count":22,"path":"api/tags/C.json"}]}