{"title":"剑指 offer--链表中倒数第k个结点和合并反转链表","slug":"C-面试问题准备：剑指 offer-链表中倒数第k个结点和合并反转链表","date":"2018-03-07T11:07:47.000Z","updated":"2018-03-14T13:21:03.000Z","comments":true,"path":"api/articles/C-面试问题准备：剑指 offer-链表中倒数第k个结点和合并反转链表.json","photos":[],"link":"","excerpt":"链表中倒数第K个结点问题描述：输入一个链表，输出该链表中倒数第K个结点。例如一个链表有6个结点，从头结点开始它们的值依次是1，2，3，4，5，6。这个链表的倒数第三个结点值为4。<br>","covers":["/images/linkList.jpeg","/images/reservelist.png"],"content":"<h2 id=\"链表中倒数第K个结点\"><a href=\"#链表中倒数第K个结点\" class=\"headerlink\" title=\"链表中倒数第K个结点\"></a>链表中倒数第K个结点</h2><blockquote>\n<p>问题描述：输入一个链表，输出该链表中倒数第K个结点。例如一个链表有6个结点，从头结点开始它们的值依次是1，2，3，4，5，6。这个链表的倒数第三个结点值为4。<br><a id=\"more\"></a></p>\n</blockquote>\n<p>为了得到我们想要的结果，我们会很自然的想到假设这个链表有n个结点，那么倒数第k个结点就是从头结点开始的第n-k+1个结点。如果我们能够得到链表中结点的个数n,那么我们只要从头结点开始向后走n-k+1步就可以了。<br>这个时候需要遍历链表两次，第一次统计出链表中结点的个数，第二次就能找到倒数第k个结点。<br>然而面试官希望我们能够只需要遍历依次链表就能够获取指定的值。</p>\n<p>这个时候我们可以：</p>\n<p><strong><font color=\"#DC143C\">定义两个指针，第一个指针从链表的头指针开始遍历向前走k-1，第二个指针保持不动；从第k步开始，第二个指针也开始从链表的头指针开始遍历。由于两个指针的距离始终保持在k-1，当第一个（走在前面的）指针到达链表的尾结点时，第二个指针正好是倒数第k个结点。</font></strong></p>\n<p><img src=\"/images/linkList.jpeg\" alt=\"\"></p>\n<p>为了保证代码的鲁棒性，可以参考如下下代码；</p>\n<figure class=\"highlight gradle\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">listNode * findKthToTail(listNode * head,<span class=\"keyword\">int</span> k) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (head == <span class=\"keyword\">NULL</span> || k &lt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">NULL</span>;</span><br><span class=\"line\">    listNode *pHead = head;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt; k - <span class=\"number\">1</span>; ++ i) &#123;</span><br><span class=\"line\">        pHead = pHead -&gt; <span class=\"keyword\">next</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (pHead == <span class=\"keyword\">NULL</span>) <span class=\"comment\">// 防止k的大小超过链表的长度</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">NULL</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    listNode *pBehind = head;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(pHead -&gt; <span class=\"keyword\">next</span> != <span class=\"keyword\">NULL</span>) &#123;</span><br><span class=\"line\">        pHead = pHead -&gt; <span class=\"keyword\">next</span>;</span><br><span class=\"line\">        pBehind = pBehind -&gt; <span class=\"keyword\">next</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> pBehind;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"反转链表\"><a href=\"#反转链表\" class=\"headerlink\" title=\"反转链表\"></a>反转链表</h2><blockquote>\n<p>定义一个函数，输入一个链表的头结点，反转链表并输出反转后链表的头结点。</p>\n</blockquote>\n<p>为了正确反转一个链表，我们需要调整链表中指针的方向。如下图：</p>\n<p><img src=\"/images/reservelist.png\" alt=\"\"></p>\n<p>如上图所示的链表中,h,i和j是3个相邻的结点。假设经过若干操作，我们已经把结点h之前的指针调整完毕，这些结点的next都指向前面一个结点。接下来我们把i的next指向h,此时的链表如上图(b),由于结点i的next指向了它的前一个结点，导致链表在结点i,j之间断开。为了避免该问题，我们需要在调整结点i的next之前，把结点j保存下来。</p>\n<p><strong><font color=\"#DC143C\">我们在调整结点i的next指针时，除了需要知道结点本身之外还需要知道i的前一个结点h，因为我们需要把结点i的next指向结点h.同时还要事先保存i的一个结点j,以防止链表断开。</font></strong></p>\n<p>代码如下：</p>\n<figure class=\"highlight mipsasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">listNode * reserveList(listNode *head) &#123;</span><br><span class=\"line\">    listNode * <span class=\"keyword\">beReserved </span>= NULL<span class=\"comment\">;</span></span><br><span class=\"line\">    listNode *pNode = head<span class=\"comment\">;</span></span><br><span class=\"line\">    listNode *prev = NULL<span class=\"comment\">;</span></span><br><span class=\"line\">    while(pNode != NULL) &#123;</span><br><span class=\"line\">        listNode *pNext = pNode -&gt; next<span class=\"comment\">;</span></span><br><span class=\"line\">        if (pNext == NULL)</span><br><span class=\"line\">            <span class=\"keyword\">beReserved </span>= pNode<span class=\"comment\">;</span></span><br><span class=\"line\">        pNode -&gt; next = prev<span class=\"comment\">;</span></span><br><span class=\"line\">        prev = pNode<span class=\"comment\">;</span></span><br><span class=\"line\">        pNode = pNext<span class=\"comment\">;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return <span class=\"keyword\">beReserved;</span></span><br><span class=\"line\"><span class=\"keyword\">&#125;</span></span><br></pre></td></tr></table></figure>\n","categories":[{"name":"面试","slug":"面试","count":37,"path":"api/categories/面试.json"}],"tags":[{"name":"C++","slug":"C","count":25,"path":"api/tags/C.json"}]}