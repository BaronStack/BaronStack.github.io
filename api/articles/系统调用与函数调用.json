{"title":"系统调用与函数调用","slug":"系统调用与函数调用","date":"2018-03-15T02:33:24.000Z","updated":"2018-03-15T03:40:24.000Z","comments":true,"path":"api/articles/系统调用与函数调用.json","photos":[],"link":"","excerpt":"Linux下对文件的操作有两种方式：系统调用（system call）和库函数调用（Library Functions）系统调用（system call）指运行在用户空间的应用程序向操作系统内核请求某些服务的过程。系统调用提供了用户程序与操作系统之间的接口。一般来说系统调用都是在内核态执行，由于系统调用不考虑平台差异性，它是由内核直接提供，因而移植性较差（几乎没有移植性）。","covers":["/images/syscall.png"],"content":"<blockquote>\n<p>Linux下对文件的操作有两种方式：系统调用（system call）和库函数调用（Library Functions）</p>\n</blockquote>\n<h3 id=\"系统调用（system-call）\"><a href=\"#系统调用（system-call）\" class=\"headerlink\" title=\"系统调用（system call）\"></a>系统调用（system call）</h3><blockquote>\n<p>指运行在<font color=\"#DC143C\">用户空间</font>的<font color=\"#DC143C\">应用程序</font>向<font color=\"#DC143C\">操作系统内核</font>请求某些服务的过程。系统调用提供了用户程序与操作系统之间的接口。一般来说系统调用都是在内核态执行，由于系统调用不考虑平台差异性，它是由内核直接提供，因而移植性较差（几乎没有移植性）。<a id=\"more\"></a></p>\n</blockquote>\n<p>这里简单介绍一下Linux系统下常见的系统调用：</p>\n<ul>\n<li><p>getpid,getppid—获取进程识别号</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/types.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">pid_t</span> getpid(<span class=\"keyword\">void</span>);<span class=\"comment\">// 获取进程标识号，它可以作为当前进程的唯一标识</span></span><br><span class=\"line\"><span class=\"keyword\">pid_t</span> getppid(<span class=\"keyword\">void</span>);<span class=\"comment\">//获取当前进程的父进程标识号</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>fork创建子进程</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/types.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">pid_t</span> fork(<span class=\"keyword\">void</span>); <span class=\"comment\">//通过完全复制当前进程创建一个子进程</span></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">如果创建子进程成功，在父进程中返回子进程的进程标示符，在子进程中返回0。</span></span><br><span class=\"line\"><span class=\"comment\">如果失败，在父进程中返回-1，子进程不会被创建，errno被设置。</span></span><br><span class=\"line\"><span class=\"comment\">因为在fork()的调用处，整个父进程空间会原模原样地复制到子进程中，包括指令，</span></span><br><span class=\"line\"><span class=\"comment\">变量值，程序调用栈，环境变量，缓冲区，等等。所以，子进程和父进程是不能通过</span></span><br><span class=\"line\"><span class=\"comment\">程序内的变量（即使是全局变量）通信的，对于这两个进程来说，它们有各自的进程空间，</span></span><br><span class=\"line\"><span class=\"comment\">互不影响。但父进程和子进程可以通过管道，共享内存，等方式实现通信。</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>sleep时进程睡眠指定的秒数</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> <span class=\"title\">sleep</span><span class=\"params\">(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> seconds)</span></span>;<span class=\"comment\">//到达指定时间后返回0，若有信号中断，则返回剩余的秒数</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>wait,waitpid等待子进程终止</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/types.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/wait.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">pid_t</span> wait(<span class=\"keyword\">int</span> *status);</span><br><span class=\"line\"><span class=\"keyword\">pid_t</span> waitpid(<span class=\"keyword\">pid_t</span> pid, <span class=\"keyword\">int</span> *status, <span class=\"keyword\">int</span> options);</span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">等待子进程的状态发生变化：子进程终止，子进程被信号停止，子进程被信号恢复。</span></span><br><span class=\"line\"><span class=\"comment\">wait等待一个子进程终止，waitpid等待pid指定的子进程状态改变。默认waitpid仅等待子进程终止，</span></span><br><span class=\"line\"><span class=\"comment\">可以通过options来改变行为,waitpid执行成功返回状态改变子进程的进程号；</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p><strong>具体详细的系统调用可以参考<font color=\"#DC143C\"><a href=\"http://blog.csdn.net/gwq5210/article/details/41345339\" target=\"_blank\" rel=\"noopener\">Linux下系统调用</a></font></strong></p>\n<h3 id=\"库函数（Library-Functions）\"><a href=\"#库函数（Library-Functions）\" class=\"headerlink\" title=\"库函数（Library Functions）\"></a>库函数（Library Functions）</h3><blockquote>\n<p>由用户或组织自己开发的，具有一定功能的函数集合，一般具有较好平台移植性，通过库文件（静态库或动态库）向程序员提供功能性调用。程序员无需关心平台差异，由库来屏蔽平台差异性。</p>\n</blockquote>\n<p>库函数一般分为两类：C语言标准规定的库函数和编译器特定的库函数。可以理解库函数为系统调用的一层封装（大部分），比如：如printf的实现最终还是调用了putc()和user.h中的write()这样的系统调用，而另一些则不会使用系统调用，比如strlen，strcat，memcpy等  </p>\n<blockquote>\n<p>既然使用库函数调用也有系统调用的开销，那为什么不直接使用系统调用呢?<br>因为读写文件通常是大量的数据（这种大量是相对于底层驱动的系统调用所需要的数据单位而言），使用库函数可以大大减少系统调用的次数。<strong><font color=\"#DC143C\">缓冲区技术的出现，在用户空间和内核空间，对文件的操作都是用了缓冲区技术，当内核缓冲区写满之后才将内核缓冲区中的数据写入文件对应的硬件媒介中，而不是每写一次，就要执行一次系统调用，再切换到用户空间写如磁盘。对CPU处理效率消耗比较大</font></strong></p>\n</blockquote>\n<h3 id=\"系统调用和库函数的区别\"><a href=\"#系统调用和库函数的区别\" class=\"headerlink\" title=\"系统调用和库函数的区别\"></a>系统调用和库函数的区别</h3><p><img src=\"/images/syscall.png\" alt=\"\"></p>\n<h3 id=\"联系\"><a href=\"#联系\" class=\"headerlink\" title=\"联系\"></a>联系</h3><blockquote>\n<p>内核功能与操作系统特性紧密相关的服务，由系统调用提供<br>具有共通特性的功能一般需要较好的平台移植性，故而由库函数提供</p>\n</blockquote>\n<p>库函数与系统调用在功能上相互补充，如进程间通信资源的管理，进程控制等功能与平台特性和内核息息相关，必须由系统调用来实现<br>文件 I/O操作等各平台都具有的共通功能一般采用库函数，也便于跨平台移植<br>库函数与系统调用也有交集，如 库函数中的I/O操作的内部实现依然需要调用系统的I/O方能实现</p>\n","categories":[{"name":"面试","slug":"面试","count":33,"path":"api/categories/面试.json"}],"tags":[{"name":"OS","slug":"OS","count":4,"path":"api/tags/OS.json"}]}