{"name":"OS","slug":"OS","count":2,"postlist":[{"title":"C++面试问题准备：阻塞和非阻塞、同步和异步","slug":"C-面试问题准备：阻塞和非阻塞、同步和异步","date":"2018-03-10T14:11:46.000Z","updated":"2018-03-11T04:52:08.000Z","comments":true,"path":"api/articles/C-面试问题准备：阻塞和非阻塞、同步和异步.json","excerpt":"","keywords":null,"cover":null,"content":"<h2 id=\"同步和异步主要针对C端\"><a href=\"#同步和异步主要针对C端\" class=\"headerlink\" title=\"同步和异步主要针对C端\"></a>同步和异步主要针对C端</h2><h3 id=\"同步\"><a href=\"#同步\" class=\"headerlink\" title=\"同步\"></a><strong><font color=\"#DC143C\">同步</font></strong></h3><p>所谓同步，就是在c端发出一个功能调用时，在没有得到结果之前，该调用就不返回。也就是必须一件一件事做,等前一件做完了才能做下一件事。 &lt;!–more–    &gt;</p>\n<blockquote>\n<p>例如普通B/S模式（同步）：提交请求-&gt;等待服务器处理-&gt;处理完毕返回 这个期间客户端浏览器不能干任何事</p>\n</blockquote>\n<h3 id=\"异步\"><a href=\"#异步\" class=\"headerlink\" title=\"异步\"></a><strong><font color=\"#DC143C\">异步</font></strong></h3><p>当c端一个异步过程调用发出后，调用者不能立刻得到结果。实际处理这个调用的部件在完成后，通过状态、通知和回调来通知调用者。</p>\n<blockquote>\n<p>例如 ajax请求（异步）: 请求通过事件触发-&gt;服务器处理（这时浏览器仍然可以作其他事情）-&gt;处理完毕</p>\n</blockquote>\n<h2 id=\"阻塞和非阻塞针对S端\"><a href=\"#阻塞和非阻塞针对S端\" class=\"headerlink\" title=\"阻塞和非阻塞针对S端\"></a>阻塞和非阻塞针对S端</h2><h3 id=\"阻塞\"><a href=\"#阻塞\" class=\"headerlink\" title=\"阻塞\"></a><strong><font color=\"#DC143C\">阻塞</font></strong></h3><p>阻塞调用是指调用结果返回之前，当前线程会被挂起（线程进入非可执行状态，在这个状态下，cpu不会给线程分配时间片，即线程暂停运行）。函数只有在得到结果之后才会返回</p>\n<blockquote>\n<p>比如到你某个时候到A楼一层（假如是内核缓冲区）取快递，但是你不知道快递什么时候过来，你又不能干别的事，只能死等着。但你可以睡觉（进程处于休眠状态），因为你知道快递把货送来时一定会给你打个电话（假定一定能叫醒你）。</p>\n</blockquote>\n<h3 id=\"非阻塞\"><a href=\"#非阻塞\" class=\"headerlink\" title=\"非阻塞\"></a><strong><font color=\"#DC143C\">非阻塞</font></strong></h3><p>在不能立刻得到结果之前，该函数不会阻塞当前线程，而会立刻返回</p>\n<blockquote>\n<p>还是等快递的例子：如果用忙轮询的方法，每隔5分钟到A楼一层(内核缓冲区）去看快递来了没有。如果没来，立即返回。而快递来了，就放在A楼一层，等你去取</p>\n</blockquote>\n<p>综上：</p>\n<p>同步  就是我客户端（c端调用者）调用一个功能，该功能没有结束前，我（c端调用者）死等结果<br>异步  就是我（c端调用者）调用一个功能，不需要知道该功能结果，该功能有结果后通知我（c端调用者）即回调通知。<br>阻塞  就是调用我（s端被调用者，函数），我（s端被调用者，函数）没有接收完数据或者没有得到结果之前，我不会返回。<br>非阻塞 就是调用我（s端被调用者，函数），我（s端被调用者，函数）立即返回，通过select通知调用者</p>\n","text":"同步和异步主要针对C端同步所谓同步，就是在c端发出一个功能调用时，在没有得到结果之前，该调用就不返回。也就是必须一件一件事做,等前一件做完了才能做下一件事。 &lt;!–more–    &gt;例如普通B/S模式（同步）：提交请求-&gt;等待服务器处理-&gt;处理完毕返回 ","link":"","raw":null,"photos":[],"categories":[{"name":"面试","slug":"面试","count":26,"path":"api/categories/面试.json"}],"tags":[{"name":"OS","slug":"OS","count":2,"path":"api/tags/OS.json"}]},{"title":"C++面试问题准备：辨认大小端以及系统位数","slug":"C-面试问题准备：辨认大小端以及系统位数","date":"2018-02-17T08:33:17.000Z","updated":"2018-02-26T05:28:07.000Z","comments":true,"path":"api/articles/C-面试问题准备：辨认大小端以及系统位数.json","excerpt":"<h2 id=\"什么是大小端-big-endian和small-endian\"><a href=\"#什么是大小端-big-endian和small-endian\" class=\"headerlink\" title=\"什么是大小端(big-endian和small-endian)\"></a>什么是大小端(big-endian和small-endian)</h2><p>即最高有效位(most significant)在低地址位就是大端，最低有效位(least significant)在低地址就是小端。<br>大概意思就是：我们取数据a = 0x12ff，那么最高有效位指的就是数字的0x12数据，最低有效位指的是0xff。<br>","keywords":null,"cover":null,"content":null,"text":"什么是大小端(big-endian和small-endian)即最高有效位(most significant)在低地址位就是大端，最低有效位(least significant)在低地址就是小端。<br>大概意思就是：我们取数据a = 0x12ff，那么最高有效位指的就是数字的0","link":"","raw":null,"photos":[],"categories":[{"name":"面试","slug":"面试","count":26,"path":"api/categories/面试.json"}],"tags":[{"name":"C++","slug":"C","count":21,"path":"api/tags/C.json"},{"name":"OS","slug":"OS","count":2,"path":"api/tags/OS.json"}]}]}