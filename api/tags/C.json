{"name":"C++","slug":"C","count":25,"postlist":[{"title":"C++开发面试问题","slug":"C-开发面试问题","date":"2018-01-26T14:47:27.000Z","updated":"2018-02-22T12:54:00.000Z","comments":true,"path":"api/articles/C-开发面试问题.json","excerpt":"<h4 id=\"语言基础\"><a href=\"#语言基础\" class=\"headerlink\" title=\"语言基础\"></a>语言基础</h4><ul>\n<li>OOP（封装、继承、多态） + V func 的实现，V table 的原理</li>\n<li>const static的各种情况，分清const pointer 和pointer to const以及两者合体的形式","keywords":null,"cover":null,"content":null,"text":"语言基础OOP（封装、继承、多态） + V func 的实现，V table 的原理const static的各种情况，分清const pointer 和pointer to const以及两者合体的形式内存泄漏 三条规则。注意exception safe和smart point","link":"","raw":null,"photos":[],"categories":[{"name":"面试","slug":"面试","count":33,"path":"api/categories/面试.json"}],"tags":[{"name":"C++","slug":"C","count":25,"path":"api/tags/C.json"}]},{"title":"STL--allocator","slug":"C-开发面试准备：STL-allocator","date":"2018-01-27T15:02:40.000Z","updated":"2018-03-14T13:26:59.000Z","comments":true,"path":"api/articles/C-开发面试准备：STL-allocator.json","excerpt":"<blockquote>\n<p>最近在读侯捷老师的《STL源码剖析》，写写总结。他的STL主要是SGI 版本的，也就是我们常用的GCC编译器支持","keywords":null,"cover":null,"content":null,"text":"最近在读侯捷老师的《STL源码剖析》，写写总结。他的STL主要是SGI 版本的，也就是我们常用的GCC编译器支持 什么是allocator相信对C++感兴趣的伙伴肯定对STL这个模版库情有独钟，但是当站在STL的角度来看这些容器的实现那么第一个需要知道的就是allocatoral","link":"","raw":null,"photos":[],"categories":[{"name":"面试","slug":"面试","count":33,"path":"api/categories/面试.json"}],"tags":[{"name":"C++","slug":"C","count":25,"path":"api/tags/C.json"}]},{"title":"sizeof(class)的大小","slug":"C-面试问题准备-C-类的大小-sizeof-class","date":"2018-03-11T06:18:40.000Z","updated":"2018-03-14T13:33:27.000Z","comments":true,"path":"api/articles/C-面试问题准备-C-类的大小-sizeof-class.json","excerpt":"<h3 id=\"空类的大小\"><a href=\"#空类的大小\" class=\"headerlink\" title=\"空类的大小\"></a>空类的大小</h3><p><img src=\"/images/emptyClass.png\" alt=\"\"></p>\n<p>为什么空的什么都没有是1呢？","keywords":null,"cover":"/images/emptyClass.png","content":null,"text":"空类的大小 [Figure] 看到添加了静态变量的显示结果是和上一个显示的结果一样的。因为static变量对于整个类只有一份拷贝，且静态成员被编译器放在内存空间的全局存储区，但是在类实例化的时候只为类中的成员变量分配存储空间，所以它不会影响类的大小。","link":"","raw":null,"photos":[],"categories":[{"name":"面试","slug":"面试","count":33,"path":"api/categories/面试.json"}],"tags":[{"name":"C++","slug":"C","count":25,"path":"api/tags/C.json"}]},{"title":"源程序编译过程以及静态链接和动态链接的区别","slug":"C-开发面试问题准备：静态链接和动态链接","date":"2018-02-07T04:44:33.000Z","updated":"2018-03-14T13:21:03.000Z","comments":true,"path":"api/articles/C-开发面试问题准备：静态链接和动态链接.json","excerpt":"<p>在Linux下我们用GCC对源码进行编译，编译的过程中有一个步骤是链接。这里我们先了解一下编译的过程，我在xmind中画的一个图如下，对软件不够熟悉，所以画得比较丑。</p>\n<p><img src=\"/images/Compile&amp;&amp;Linking.png\" alt=\"编译过程\"></p>\n<p>大体分为一下几个步骤：</p>\n<ul>\n<li>预处理（Preprocess）</li>\n<li>编译(Complication)</li>\n<li>汇编(Assembly)</li>\n<li>链接(Linking)</li>\n<li>执行(Execute)","keywords":null,"cover":"/images/Compile&amp;&amp;Linking.png","content":null,"text":"在Linux下我们用GCC对源码进行编译，编译的过程中有一个步骤是链接。这里我们先了解一下编译的过程，我在xmind中画的一个图如下，对软件不够熟悉，所以画得比较丑。 [Figure] 一些功能代码经过编译连接后的可执行形式静态lib将导出声明和实现都放在lib中。编译后所有代码","link":"","raw":null,"photos":[],"categories":[{"name":"面试","slug":"面试","count":33,"path":"api/categories/面试.json"}],"tags":[{"name":"C++","slug":"C","count":25,"path":"api/tags/C.json"}]},{"title":"实现String类","slug":"C-面试问题准备-实现String类","date":"2018-03-13T10:04:21.000Z","updated":"2018-03-14T13:33:59.000Z","comments":true,"path":"api/articles/C-面试问题准备-实现String类.json","excerpt":"<h2 id=\"String-类\"><a href=\"#String-类\" class=\"headerlink\" title=\"String 类\"></a>String 类</h2><p>原型如下：</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class <span class=\"keyword\">String</span></span><br><span class=\"line\">&#123; </span><br><span class=\"line\"> <span class=\"keyword\">public</span>: </span><br><span class=\"line\"> <span class=\"keyword\">String</span>(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *str = NULL); <span class=\"comment\">// 普通构造函数 </span></span><br><span class=\"line\"> <span class=\"keyword\">String</span>(<span class=\"keyword\">const</span> <span class=\"keyword\">String</span> &amp;other); <span class=\"comment\">// 拷贝构造函数 </span></span><br><span class=\"line\"> ~ <span class=\"keyword\">String</span>(<span class=\"keyword\">void</span>); <span class=\"comment\">// 析构函数 </span></span><br><span class=\"line\"> <span class=\"keyword\">String</span> &amp; <span class=\"keyword\">operator</span> =(<span class=\"keyword\">const</span> <span class=\"keyword\">String</span> &amp;other); <span class=\"comment\">// 赋值函数 </span></span><br><span class=\"line\"> <span class=\"keyword\">private</span>: </span><br><span class=\"line\"> <span class=\"keyword\">char</span> *m_data; <span class=\"comment\">// 用于保存字符串 </span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>","keywords":null,"cover":null,"content":null,"text":"String 类原型如下：1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>class String<br>&#123; <br> public: <br> String(const char *str = NULL); // ","link":"","raw":null,"photos":[],"categories":[{"name":"面试","slug":"面试","count":33,"path":"api/categories/面试.json"}],"tags":[{"name":"C++","slug":"C","count":25,"path":"api/tags/C.json"}]},{"title":"Base64编码方式及实现代码","slug":"C-面试问题准备：Base64编码方式及实现代码","date":"2018-03-13T13:39:21.000Z","updated":"2018-03-14T13:59:20.000Z","comments":true,"path":"api/articles/C-面试问题准备：Base64编码方式及实现代码.json","excerpt":"<blockquote>\n<p>之前根本就没有听过base64编码，可能还是对网络这里了解不够，参加了北京柠檬微趣的现场笔试，看到了这个题目，当时想的太简单了，其实本来思路想好之后就不会很难，可惜先入为主了，导致没有参加面试机会，可惜可惜！！！<br>特总结base64编码实现如下：<br>","keywords":null,"cover":"/images/base64.png","content":null,"text":"之前根本就没有听过base64编码，可能还是对网络这里了解不够，参加了北京柠檬微趣的现场笔试，看到了这个题目，当时想的太简单了，其实本来思路想好之后就不会很难，可惜先入为主了，导致没有参加面试机会，可惜可惜！！！<br>特总结base64编码实现如下：<br>Base64编码是一","link":"","raw":null,"photos":[],"categories":[{"name":"面试","slug":"面试","count":33,"path":"api/categories/面试.json"}],"tags":[{"name":"C++","slug":"C","count":25,"path":"api/tags/C.json"}]},{"title":"KMP算法","slug":"C-面试问题准备：KMP算法","date":"2018-03-12T16:35:13.000Z","updated":"2018-03-14T13:21:03.000Z","comments":true,"path":"api/articles/C-面试问题准备：KMP算法.json","excerpt":"<blockquote>\n<p>在说KMP算法之前先说一下普通的模式匹配算法</p>\n</blockquote>\n<h2 id=\"BF蛮力算法–字符串匹配\"><a href=\"#BF蛮力算法–字符串匹配\" class=\"headerlink\" title=\"BF蛮力算法–字符串匹配\"></a>BF蛮力算法–字符串匹配</h2><font size=\"5\">算法思想：</font><br><font color=\"#DC143C\">从目标串T的的第一个字符起与模式串P的第一个字符比较<br>若相等，则继续对字符进行后续的比较<br>否则目标串从第二个字符起与模式串的第一个字符重新比较<br>直至模式串中的每个字符依次和目标串中的一个连续的字符序列相等为止，此时称为匹配成功，否则匹配失败</font>","keywords":null,"cover":null,"content":null,"text":"在说KMP算法之前先说一下普通的模式匹配算法BF蛮力算法–字符串匹配算法思想：<br>从目标串T的的第一个字符起与模式串P的第一个字符比较<br>若相等，则继续对字符进行后续的比较<br>否则目标串从第二个字符起与模式串的第一个字符重新比较<br>直至模式串中的每个字符依次和目标","link":"","raw":null,"photos":[],"categories":[{"name":"面试","slug":"面试","count":33,"path":"api/categories/面试.json"}],"tags":[{"name":"C++","slug":"C","count":25,"path":"api/tags/C.json"}]},{"title":"STL-iterator","slug":"C-面试问题准备：STL-iterator","date":"2018-02-11T12:53:12.000Z","updated":"2018-03-14T13:21:03.000Z","comments":true,"path":"api/articles/C-面试问题准备：STL-iterator.json","excerpt":"<blockquote>\n<p>这两天在家里没有好好读书，要反思一下。今天看《STL源码剖析》到了迭代器iterator这里</p>\n</blockquote>\n<h2 id=\"什么是迭代器\"><a href=\"#什么是迭代器\" class=\"headerlink\" title=\"什么是迭代器\"></a>什么是迭代器</h2><p>在《Design Patterns》中对迭代器模式的描述如下：<font color=\"#DC143C\">提供一种方法，使之能够依序寻访某个聚合物（容器）所含的各个元素，而又无需暴露该聚合物内部表现方式</font>","keywords":null,"cover":null,"content":null,"text":"这两天在家里没有好好读书，要反思一下。今天看《STL源码剖析》到了迭代器iterator这里什么是迭代器在《Design Patterns》中对迭代器模式的描述如下：提供一种方法，使之能够依序寻访某个聚合物（容器）所含的各个元素，而又无需暴露该聚合物内部表现方式 这里小小的回忆下","link":"","raw":null,"photos":[],"categories":[{"name":"面试","slug":"面试","count":33,"path":"api/categories/面试.json"}],"tags":[{"name":"C++","slug":"C","count":25,"path":"api/tags/C.json"}]},{"title":"const和static关键字","slug":"C-面试问题准备：const和static关键字","date":"2018-01-31T01:51:41.000Z","updated":"2018-03-14T13:21:03.000Z","comments":true,"path":"api/articles/C-面试问题准备：const和static关键字.json","excerpt":"<h2 id=\"常量-（const）\"><a href=\"#常量-（const）\" class=\"headerlink\" title=\"常量 （const）\"></a>常量 （const）</h2><ul>\n<li><p>const类型值不能被修改，这里指的是const修饰的内容不能被修改，且const修饰的常量在超出其作用域之后会被释放","keywords":null,"cover":null,"content":null,"text":"常量 （const）const类型值不能被修改，这里指的是const修饰的内容不能被修改，且const修饰的常量在超出其作用域之后会被释放 在类中：const数据成员只在某个对象生存期是常量，而类可以创建很多的对象，所以不同对象类的const数据成员是可以不同的.在类中：cons","link":"","raw":null,"photos":[],"categories":[{"name":"面试","slug":"面试","count":33,"path":"api/categories/面试.json"}],"tags":[{"name":"C++","slug":"C","count":25,"path":"api/tags/C.json"}]},{"title":"i++是否原子操作，为什么","slug":"C-面试问题准备：i-是否原子操作，为什么","date":"2018-02-17T06:48:38.000Z","updated":"2018-03-14T13:21:03.000Z","comments":true,"path":"api/articles/C-面试问题准备：i-是否原子操作，为什么.json","excerpt":"<h2 id=\"什么是操作系统原子操作\"><a href=\"#什么是操作系统原子操作\" class=\"headerlink\" title=\"什么是操作系统原子操作\"></a>什么是操作系统原子操作</h2><p><strong>原子操作是不可分割的，在执行完毕之前不会被任何其他事物或者事件中断，分为以下两种情况：</strong></p>\n<ul>\n<li>在单线程中， 能够在单条指令中完成的操作都可以认为是” 原子操作”，因为中断只能发生于指令之间</li>\n<li>在多线程中，不能被其它进程（线程）打断的操作就叫原子操作","keywords":null,"cover":null,"content":null,"text":"什么是操作系统原子操作原子操作是不可分割的，在执行完毕之前不会被任何其他事物或者事件中断，分为以下两种情况：在单线程中， 能够在单条指令中完成的操作都可以认为是” 原子操作”，因为中断只能发生于指令之间在多线程中，不能被其它进程（线程）打断的操作就叫原子操作 i++分为三个阶段内","link":"","raw":null,"photos":[],"categories":[{"name":"面试","slug":"面试","count":33,"path":"api/categories/面试.json"}],"tags":[{"name":"C++","slug":"C","count":25,"path":"api/tags/C.json"}]},{"title":"strcpy和strncpy以及memcpy函数","slug":"C-面试问题准备：strcpy和strncpy以及memcpy函数","date":"2018-03-06T02:46:32.000Z","updated":"2018-03-14T13:21:03.000Z","comments":true,"path":"api/articles/C-面试问题准备：strcpy和strncpy以及memcpy函数.json","excerpt":"<h2 id=\"strcpy函数以及strncpy函数\"><a href=\"#strcpy函数以及strncpy函数\" class=\"headerlink\" title=\"strcpy函数以及strncpy函数\"></a>strcpy函数以及strncpy函数</h2><blockquote>\n<p>这两个函数都是字符串拷贝函数</p>\n</blockquote>\n<p>函数原型：</p>\n<p><code>char * strcpy(char * destStr,char * srcStr);</code></p>\n<p><code>cahr * strncpy(char * destStr,char * srcStr,int num);</code></p>","keywords":null,"cover":null,"content":null,"text":"strcpy函数以及strncpy函数这两个函数都是字符串拷贝函数函数原型：char * strcpy(char * destStr,char * srcStr);cahr * strncpy(char * destStr,char * srcStr,int num);很明显可以","link":"","raw":null,"photos":[],"categories":[{"name":"面试","slug":"面试","count":33,"path":"api/categories/面试.json"}],"tags":[{"name":"C++","slug":"C","count":25,"path":"api/tags/C.json"}]},{"title":"什么函数不能作为虚函数","slug":"C-面试问题准备：什么函数不能作为虚函数","date":"2018-03-11T07:22:28.000Z","updated":"2018-03-14T13:21:03.000Z","comments":true,"path":"api/articles/C-面试问题准备：什么函数不能作为虚函数.json","excerpt":"<p><strong><font color=\"#DC143C\">虚函数</font></strong></p>\n<p>虚函数必须是类的非静态成员，即在类的成员函数生命中前面关键字为<code>virtual</code>的是虚函数。虚函数是为了实现的面向对象的多态（动态绑定）机制而提出来的。<br>即在程序运行过程中，进行对象所属类型的匹配，也是父类对象访问子类成员的方式。本质上还是为了实现代码复用以及项目的鲁棒性。","keywords":null,"cover":null,"content":null,"text":"虚函数虚函数必须是类的非静态成员，即在类的成员函数生命中前面关键字为virtual的是虚函数。虚函数是为了实现的面向对象的多态（动态绑定）机制而提出来的。<br>即在程序运行过程中，进行对象所属类型的匹配，也是父类对象访问子类成员的方式。本质上还是为了实现代码复用以及项目的鲁棒性","link":"","raw":null,"photos":[],"categories":[{"name":"面试","slug":"面试","count":33,"path":"api/categories/面试.json"}],"tags":[{"name":"C++","slug":"C","count":25,"path":"api/tags/C.json"}]},{"title":"内存分配的方式","slug":"C-面试问题准备：内存分配的方式","date":"2018-01-30T12:16:57.000Z","updated":"2018-03-14T13:21:03.000Z","comments":true,"path":"api/articles/C-面试问题准备：内存分配的方式.json","excerpt":"<h3 id=\"C-中常见内存分配及其存储区域有以下几种\"><a href=\"#C-中常见内存分配及其存储区域有以下几种\" class=\"headerlink\" title=\"C++ 中常见内存分配及其存储区域有以下几种\"></a>C++ 中常见内存分配及其存储区域有以下几种</h3><ul>\n<li>堆分配</li>\n<li>栈分配</li>\n<li>自由存储区</li>\n<li>静态存储区</li>\n<li>常量存储区","keywords":null,"cover":null,"content":null,"text":"C++ 中常见内存分配及其存储区域有以下几种堆分配栈分配自由存储区静态存储区常量存储区这里首先描述以下除了堆和栈的三种存储方式：自由存储区这个存储区是单独为C++ 中new运算符提出来的，该存储区是new和delete动态分配和释放对象的抽象概念。在《STL 源码剖析中》自由存储","link":"","raw":null,"photos":[],"categories":[{"name":"面试","slug":"面试","count":33,"path":"api/categories/面试.json"}],"tags":[{"name":"C++","slug":"C","count":25,"path":"api/tags/C.json"}]},{"title":"剑指 offer--链表中倒数第k个结点和合并反转链表","slug":"C-面试问题准备：剑指 offer-链表中倒数第k个结点和合并反转链表","date":"2018-03-07T11:07:47.000Z","updated":"2018-03-14T13:21:03.000Z","comments":true,"path":"api/articles/C-面试问题准备：剑指 offer-链表中倒数第k个结点和合并反转链表.json","excerpt":"<h2 id=\"链表中倒数第K个结点\"><a href=\"#链表中倒数第K个结点\" class=\"headerlink\" title=\"链表中倒数第K个结点\"></a>链表中倒数第K个结点</h2><blockquote>\n<p>问题描述：输入一个链表，输出该链表中倒数第K个结点。例如一个链表有6个结点，从头结点开始它们的值依次是1，2，3，4，5，6。这个链表的倒数第三个结点值为4。<br>","keywords":null,"cover":"/images/linkList.jpeg","content":null,"text":"链表中倒数第K个结点问题描述：输入一个链表，输出该链表中倒数第K个结点。例如一个链表有6个结点，从头结点开始它们的值依次是1，2，3，4，5，6。这个链表的倒数第三个结点值为4。<br>为了得到我们想要的结果，我们会很自然的想到假设这个链表有n个结点，那么倒数第k个结点就是从头结","link":"","raw":null,"photos":[],"categories":[{"name":"面试","slug":"面试","count":33,"path":"api/categories/面试.json"}],"tags":[{"name":"C++","slug":"C","count":25,"path":"api/tags/C.json"}]},{"title":"剑指 offer--丑数和两个链表的第一个公共结点","slug":"C-面试问题准备：剑指-offer-丑数和两个链表的第一个公共结点","date":"2018-03-12T10:01:41.000Z","updated":"2018-03-14T13:21:03.000Z","comments":true,"path":"api/articles/C-面试问题准备：剑指-offer-丑数和两个链表的第一个公共结点.json","excerpt":"<h2 id=\"两个链表的第一个公共结点\"><a href=\"#两个链表的第一个公共结点\" class=\"headerlink\" title=\"两个链表的第一个公共结点\"></a>两个链表的第一个公共结点</h2><blockquote>\n<p>问题描述：输入两个链表，找出它们的第一个公共结点。</p>\n</blockquote>\n<p>这道题第一次很容易想到，在第一个链表上遍历每个结点的时候再在第二个链表顺序遍历所有的结点，如果第二个链表上有一个结点和第一个链表上的结点一样，则返回该结点。但是这样的遍历方式会导致时间复杂度为O(mn);","keywords":null,"cover":null,"content":null,"text":"两个链表的第一个公共结点问题描述：输入两个链表，找出它们的第一个公共结点。这道题第一次很容易想到，在第一个链表上遍历每个结点的时候再在第二个链表顺序遍历所有的结点，如果第二个链表上有一个结点和第一个链表上的结点一样，则返回该结点。但是这样的遍历方式会导致时间复杂度为O(mn);这","link":"","raw":null,"photos":[],"categories":[{"name":"面试","slug":"面试","count":33,"path":"api/categories/面试.json"}],"tags":[{"name":"C++","slug":"C","count":25,"path":"api/tags/C.json"}]},{"title":"剑指 offer--二叉树的镜像和顺时针打印矩阵","slug":"C-面试问题准备：剑指-offer-二叉树的镜像和顺时针打印矩阵","date":"2018-02-08T09:31:05.000Z","updated":"2018-03-14T13:21:03.000Z","comments":true,"path":"api/articles/C-面试问题准备：剑指-offer-二叉树的镜像和顺时针打印矩阵.json","excerpt":"<h2 id=\"二叉树的镜像\"><a href=\"#二叉树的镜像\" class=\"headerlink\" title=\"二叉树的镜像\"></a>二叉树的镜像</h2><blockquote>\n<p>题目描述：完成一个函数，输入一个二叉树，该函数输出它的镜像</p>\n</blockquote>\n<p>如图：</p>\n<p><img src=\"/images/treeMirror.jpg\" alt=\"二叉树镜像\">","keywords":null,"cover":"/images/treeMirror.jpg","content":null,"text":"二叉树的镜像题目描述：完成一个函数，输入一个二叉树，该函数输出它的镜像如图： [Figure] 具体测试实现这里就不多说了，相信大家读懂思路之后代码就是顺手拈来！","link":"","raw":null,"photos":[],"categories":[{"name":"面试","slug":"面试","count":33,"path":"api/categories/面试.json"}],"tags":[{"name":"C++","slug":"C","count":25,"path":"api/tags/C.json"}]},{"title":"剑指 offer--从上往下打印和二叉搜索树的后序遍历序列","slug":"C-面试问题准备：剑指-offer-从上往下打印和二叉搜索树的后序遍历序列","date":"2018-03-08T12:20:51.000Z","updated":"2018-03-14T13:21:03.000Z","comments":true,"path":"api/articles/C-面试问题准备：剑指-offer-从上往下打印和二叉搜索树的后序遍历序列.json","excerpt":"<h2 id=\"从上往下打印二叉树\"><a href=\"#从上往下打印二叉树\" class=\"headerlink\" title=\"从上往下打印二叉树\"></a>从上往下打印二叉树</h2><blockquote>\n<p>题目描述：从上往下打印出二叉树的每个结点，同一层的结点按照从左到右的顺序打印。</p>\n</blockquote>\n<p>因为按层打印的顺序决定应该先打印根节点，所以我们从树的根节点开始分析。","keywords":null,"cover":"/images/printTree.jpg","content":null,"text":"从上往下打印二叉树题目描述：从上往下打印出二叉树的每个结点，同一层的结点按照从左到右的顺序打印。因为按层打印的顺序决定应该先打印根节点，所以我们从树的根节点开始分析。  [Figure] ","link":"","raw":null,"photos":[],"categories":[{"name":"面试","slug":"面试","count":33,"path":"api/categories/面试.json"}],"tags":[{"name":"C++","slug":"C","count":25,"path":"api/tags/C.json"}]},{"title":"剑指 offer-包含min函数的栈和栈的压入和弹出","slug":"C-面试问题准备：剑指-offer-包含min函数的栈和栈的压入和弹出","date":"2018-02-27T16:12:54.000Z","updated":"2018-03-14T13:21:45.000Z","comments":true,"path":"api/articles/C-面试问题准备：剑指-offer-包含min函数的栈和栈的压入和弹出.json","excerpt":"<h2 id=\"包含min函数的栈\"><a href=\"#包含min函数的栈\" class=\"headerlink\" title=\"包含min函数的栈\"></a>包含min函数的栈</h2><blockquote>\n<p>题目描述：定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的min函数，且在该栈中调用min,push以及pop的时间复杂度都是O(1)","keywords":null,"cover":"/images/minStack.png","content":null,"text":"包含min函数的栈题目描述：定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的min函数，且在该栈中调用min,push以及pop的时间复杂度都是O(1)看到这个问题我们会想到每一次将元素压入栈的时候对栈内所有的元素进行排序，将最小的元素放到栈顶，这样可以在O(1)时间","link":"","raw":null,"photos":[],"categories":[{"name":"面试","slug":"面试","count":33,"path":"api/categories/面试.json"}],"tags":[{"name":"C++","slug":"C","count":25,"path":"api/tags/C.json"}]},{"title":"剑指-offer--合并两个排序链表和树的子结构","slug":"C-面试问题准备：剑指-offer-合并两个排序链表和树的子结构","date":"2018-03-07T11:59:45.000Z","updated":"2018-03-14T13:22:32.000Z","comments":true,"path":"api/articles/C-面试问题准备：剑指-offer-合并两个排序链表和树的子结构.json","excerpt":"<h2 id=\"合并两个排序链表\"><a href=\"#合并两个排序链表\" class=\"headerlink\" title=\"合并两个排序链表\"></a>合并两个排序链表</h2><blockquote>\n<p>输入两个递增排序的链表，合并这两个链表并使新链表中的结点仍然使按照递增排序的。</p>\n</blockquote>\n<p>常见问题：</p>\n<ul>\n<li>写代码之前没有对合并过程想清楚，最终合并出来的链表要么中间断开，要么没有做到递增排序</li>\n<li>代码的鲁棒性存在问题，程序有特殊输入会崩溃（输入空链表）","keywords":null,"cover":"/images/mergeList.png","content":null,"text":"合并两个排序链表输入两个递增排序的链表，合并这两个链表并使新链表中的结点仍然使按照递增排序的。常见问题：写代码之前没有对合并过程想清楚，最终合并出来的链表要么中间断开，要么没有做到递增排序代码的鲁棒性存在问题，程序有特殊输入会崩溃（输入空链表） [Figure] ","link":"","raw":null,"photos":[],"categories":[{"name":"面试","slug":"面试","count":33,"path":"api/categories/面试.json"}],"tags":[{"name":"C++","slug":"C","count":25,"path":"api/tags/C.json"}]},{"title":"剑指 offer--在O(1)时间删除链表结点和打印1到最大的n位数","slug":"C-面试问题准备：剑指-offer-在O-1-时间删除链表结点和打印1到最大的n位数","date":"2018-03-10T05:12:36.000Z","updated":"2018-03-14T13:23:16.000Z","comments":true,"path":"api/articles/C-面试问题准备：剑指-offer-在O-1-时间删除链表结点和打印1到最大的n位数.json","excerpt":"<h2 id=\"在O-1-时间内删除链表结点\"><a href=\"#在O-1-时间内删除链表结点\" class=\"headerlink\" title=\"在O(1)时间内删除链表结点\"></a>在O(1)时间内删除链表结点</h2><blockquote>\n<p>题目描述：给定单向链表的头指针和一个结点指针，定义一个函数在O(1)时间删除该结点</p>\n</blockquote>\n<p>在单向链表中删除一个结点最常规的做法无疑是从链表的头结点开始，顺序遍历查找要删除的结点，并在链表中删除该结点。","keywords":null,"cover":"/images/deleteList.jpg","content":null,"text":"在O(1)时间内删除链表结点题目描述：给定单向链表的头指针和一个结点指针，定义一个函数在O(1)时间删除该结点在单向链表中删除一个结点最常规的做法无疑是从链表的头结点开始，顺序遍历查找要删除的结点，并在链表中删除该结点。但是这种删除方式需要遍历整个链表，时间复杂度为O（n）.为了","link":"","raw":null,"photos":[],"categories":[{"name":"面试","slug":"面试","count":33,"path":"api/categories/面试.json"}],"tags":[{"name":"C++","slug":"C","count":25,"path":"api/tags/C.json"}]},{"title":"剑指 offer--第一个只出现一次的字符和数组中的逆序对","slug":"C-面试问题准备：剑指-offer-第一个只出现一次的字符和数组中的逆序对","date":"2018-03-10T06:53:12.000Z","updated":"2018-03-14T13:23:16.000Z","comments":true,"path":"api/articles/C-面试问题准备：剑指-offer-第一个只出现一次的字符和数组中的逆序对.json","excerpt":"<h2 id=\"第一个只出现一次的字符\"><a href=\"#第一个只出现一次的字符\" class=\"headerlink\" title=\"第一个只出现一次的字符\"></a>第一个只出现一次的字符</h2><blockquote>\n<p>题目描述：在字符中找出第一个只出现一次的字符。例如输入”abaccdeff”,则输出”b”;</p>\n</blockquote>\n<p>看到这个题目我们最直接的想法是从头到尾扫描这个字符串，当访问到某个字符时拿这个字符和后面的每个字符进行比较，如果在后面没有出现该字符，那么这个字符就是所要求的。但是每个字符都要与后面O(n)个字符进行比较，这样时间复制度就为o(n^2);","keywords":null,"cover":"/images/nixu01.jpg","content":null,"text":"第一个只出现一次的字符题目描述：在字符中找出第一个只出现一次的字符。例如输入”abaccdeff”,则输出”b”;看到这个题目我们最直接的想法是从头到尾扫描这个字符串，当访问到某个字符时拿这个字符和后面的每个字符进行比较，如果在后面没有出现该字符，那么这个字符就是所要求的。但是每","link":"","raw":null,"photos":[],"categories":[{"name":"面试","slug":"面试","count":33,"path":"api/categories/面试.json"}],"tags":[{"name":"C++","slug":"C","count":25,"path":"api/tags/C.json"}]},{"title":"进程、线程、死锁、多线程还是多进程的选择以及区别","slug":"C-面试问题准备：多线程还是多进程的选择以及区别","date":"2018-03-04T12:27:20.000Z","updated":"2018-03-14T13:23:16.000Z","comments":true,"path":"api/articles/C-面试问题准备：多线程还是多进程的选择以及区别.json","excerpt":"<h2 id=\"进程和线程的区别\"><a href=\"#进程和线程的区别\" class=\"headerlink\" title=\"进程和线程的区别\"></a>进程和线程的区别</h2><ul>\n<li>一个进程由一个或多个线程组成，线程是一个进程中代码的不同执行路线；</li>\n<li>进程之间相互独立，但同一进程下的各个线程之间共享程序的内存空间(包括代码段、数据集、堆等)及一些进程级的资源(如打开文件和信号)，某进程内的线程在其它进程不可见</li>\n<li>调度和切换：线程上下文切换比进程上下文切换要快得多","keywords":null,"cover":"/images/deadLock.jpg","content":null,"text":"进程和线程的区别一个进程由一个或多个线程组成，线程是一个进程中代码的不同执行路线；进程之间相互独立，但同一进程下的各个线程之间共享程序的内存空间(包括代码段、数据集、堆等)及一些进程级的资源(如打开文件和信号)，某进程内的线程在其它进程不可见调度和切换：线程上下文切换比进程上下文","link":"","raw":null,"photos":[],"categories":[{"name":"面试","slug":"面试","count":33,"path":"api/categories/面试.json"}],"tags":[{"name":"C++","slug":"C","count":25,"path":"api/tags/C.json"}]},{"title":"辨认大小端以及系统位数","slug":"C-面试问题准备：辨认大小端以及系统位数","date":"2018-02-17T08:33:17.000Z","updated":"2018-03-14T13:23:16.000Z","comments":true,"path":"api/articles/C-面试问题准备：辨认大小端以及系统位数.json","excerpt":"<h2 id=\"什么是大小端-big-endian和small-endian\"><a href=\"#什么是大小端-big-endian和small-endian\" class=\"headerlink\" title=\"什么是大小端(big-endian和small-endian)\"></a>什么是大小端(big-endian和small-endian)</h2><p>即最高有效位(most significant)在低地址位就是大端，最低有效位(least significant)在低地址就是小端。<br>大概意思就是：我们取数据a = 0x12ff，那么最高有效位指的就是数字的0x12数据，最低有效位指的是0xff。<br>","keywords":null,"cover":null,"content":null,"text":"什么是大小端(big-endian和small-endian)即最高有效位(most significant)在低地址位就是大端，最低有效位(least significant)在低地址就是小端。<br>大概意思就是：我们取数据a = 0x12ff，那么最高有效位指的就是数字的0","link":"","raw":null,"photos":[],"categories":[{"name":"面试","slug":"面试","count":33,"path":"api/categories/面试.json"}],"tags":[{"name":"C++","slug":"C","count":25,"path":"api/tags/C.json"},{"name":"OS","slug":"OS","count":4,"path":"api/tags/OS.json"}]},{"title":"面向对象的基本原则","slug":"C-面试问题准备：面向对象的基本原则","date":"2018-02-04T13:47:31.000Z","updated":"2018-03-14T13:24:36.000Z","comments":true,"path":"api/articles/C-面试问题准备：面向对象的基本原则.json","excerpt":"<p>关于面向对象的五个基本原则：</p>\n<ul>\n<li>单一职责原则</li>\n<li>开放封闭原则</li>\n<li>Liskov替换原则</li>\n<li>依赖导致原则</li>\n<li>接口隔离原则","keywords":null,"cover":null,"content":null,"text":"关于面向对象的五个基本原则：单一职责原则开放封闭原则Liskov替换原则依赖导致原则接口隔离原则单一职责原则（Single-Resposibility Principle）一个类应该仅有一个引起它变化的原因(最简单，最容易理解却最不容易做到的一个设计原则)单一职责原则可以看做是低","link":"","raw":null,"photos":[],"categories":[{"name":"面试","slug":"面试","count":33,"path":"api/categories/面试.json"}],"tags":[{"name":"C++","slug":"C","count":25,"path":"api/tags/C.json"}]},{"title":"指针和引用的区别以及extern C的作用","slug":"C-面试问题总结：指针和引用的区别","date":"2018-03-04T05:50:38.000Z","updated":"2018-03-14T13:24:36.000Z","comments":true,"path":"api/articles/C-面试问题总结：指针和引用的区别.json","excerpt":"<h3 id=\"指针和引用的区别\"><a href=\"#指针和引用的区别\" class=\"headerlink\" title=\"指针和引用的区别\"></a>指针和引用的区别</h3><blockquote>\n<p>指针和引用都代表的是地址</p>\n</blockquote>\n<ul>\n<li><strong>引用</strong>需要指向某些对象，但是你可以声明指针变量为空，然后将引用指向该指针变量。</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">char</span> <span class=\"meta\">*pc</span> <span class=\"string\">=</span> <span class=\"literal\">NULL</span><span class=\"string\">;</span></span><br><span class=\"line\"><span class=\"string\">char</span> <span class=\"meta\">&amp;rc</span> <span class=\"string\">=</span> <span class=\"string\">*pc;</span></span><br></pre></td></tr></table></figure>","keywords":null,"cover":null,"content":null,"text":"指针和引用的区别指针和引用都代表的是地址引用需要指向某些对象，但是你可以声明指针变量为空，然后将引用指向该指针变量。1<br>2<br>char *pc = NULL;<br>char &amp;rc = *pc;<br>因为引用肯定会指向一个对象，因此必须初始化，其实和１是一回","link":"","raw":null,"photos":[],"categories":[{"name":"面试","slug":"面试","count":33,"path":"api/categories/面试.json"}],"tags":[{"name":"C++","slug":"C","count":25,"path":"api/tags/C.json"}]}]}