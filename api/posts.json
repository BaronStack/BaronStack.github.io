{"total":70,"pageSize":10,"pageCount":7,"data":[{"title":"项目问题总结","slug":"项目问题总结","date":"2018-03-13T15:29:42.000Z","updated":"2018-03-14T09:52:15.000Z","comments":true,"path":"api/articles/项目问题总结.json","excerpt":"<h2 id=\"问题一：主机间通信断开链接后重新连接失败，显示接受（C端）端口被占用\"><a href=\"#问题一：主机间通信断开链接后重新连接失败，显示接受（C端）端口被占用\" class=\"headerlink\" title=\"问题一：主机间通信断开链接后重新连接失败，显示接受（C端）端口被占用\"></a>问题一：主机间通信断开链接后重新连接失败，显示接受（C端）端口被占用</h2><h3 id=\"分析：\"><a href=\"#分析：\" class=\"headerlink\" title=\"分析：\"></a><font color=\"#DC143C\">分析：</font></h3><p>主机之间建立的链接属于TCP链接，断开的时候会发生TCP四次挥手，过程中C端会进入TIME_WAIT状态，有时S端主动断开链接的时候也会导致S端进入TIME_WAIT状态。即我们断开TCP链接的时候并没有完全断开，此时S端还处于TIME_WAIT，导致通信端口被占用，无法创建新的链接。","keywords":null,"cover":"/images/time_wait.png","content":null,"text":"问题一：主机间通信断开链接后重新连接失败，显示接受（C端）端口被占用分析：主机之间建立的链接属于TCP链接，断开的时候会发生TCP四次挥手，过程中C端会进入TIME_WAIT状态，有时S端主动断开链接的时候也会导致S端进入TIME_WAIT状态。即我们断开TCP链接的时候并没有完","link":"","raw":null,"photos":[],"categories":[{"name":"面试","slug":"面试","count":32,"path":"api/categories/面试.json"}],"tags":[]},{"title":"Base64编码方式及实现代码","slug":"C-面试问题准备：Base64编码方式及实现代码","date":"2018-03-13T13:39:21.000Z","updated":"2018-03-14T13:21:03.000Z","comments":true,"path":"api/articles/C-面试问题准备：Base64编码方式及实现代码.json","excerpt":"","keywords":null,"cover":"/images/base64.png","content":"<blockquote>\n<p>之前根本就没有听过base64编码，可能还是对网络这里了解不够，参加了北京柠檬微趣的现场笔试，看到了这个题目，当时想的太简单了，其实本来思路想好之后就不会很难，可惜先入为主了，导致没有参加面试机会，可惜可惜！！！<br>特总结base64编码实现如下：</p>\n</blockquote>\n<h2 id=\"Base64编码\"><a href=\"#Base64编码\" class=\"headerlink\" title=\"Base64编码\"></a>Base64编码</h2><p>是一种基于64个可打印字符来表示二进制数据的表示方法!它是一种将二进制编码转换为可打印字符一种。<br>它是MIME编码里面非常常见一种可逆转换二进制方法！现常用于电子邮件中，邮件类型声明如：Content-Transfer-Encoding: base64 。</p>\n<h2 id=\"编码原理\"><a href=\"#编码原理\" class=\"headerlink\" title=\"编码原理\"></a>编码原理</h2><p>我们知道三个字节有24个位元，就可以刚好对应于4个Base64单元，即3个字节需要用4个Base64的可打印字符来表示。在Base64中的可打印字符包括字母A-Z、a-z、数字0-9 ，这样共有62个字符，此外两个可打印符号在不同的系统中一般有所不同。但是，我们经常所说的Base64另外2个字符是：“+/”。这64个字符，所对应表如下。<br><img src=\"/images/base64.png\" alt=\"\"></p>\n<p>转换的时候按照如下方法:</p>\n<p><font color=\"#DC143C\">将输入数据流每次取6 bit，用此6 bit的值(0-63)作为索引去查表，输出相应字符。这样，每3个字节将编码为4个字符(3×8 → 4×6)；不满4个字符的以’=’填充</font><br>如下图：</p>\n<p><img src=\"/images/base.png\" alt=\"\"></p>\n<p>主要是通过位运算符将6bit的数据提取出来，并且对最后不足6位的bit进行补位。</p>\n<p>代码如下:</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">char</span> EnBase64Tab[] = <span class=\"string\">\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> CBase64::EncodeBase64(<span class=\"keyword\">const</span> <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span>* pSrc, <span class=\"keyword\">char</span>* pDst, <span class=\"keyword\">int</span> nSrcLen, <span class=\"keyword\">int</span> nMaxLineLen)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> c1, c2, c3;    <span class=\"comment\">// 输入缓冲区读出3个字节</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> nDstLen = <span class=\"number\">0</span>;             <span class=\"comment\">// 输出的字符计数</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> nLineLen = <span class=\"number\">0</span>;            <span class=\"comment\">// 输出的行长度计数</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> nDiv = nSrcLen / <span class=\"number\">3</span>;      <span class=\"comment\">// 输入数据长度除以3得到的倍数</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> nMod = nSrcLen % <span class=\"number\">3</span>;      <span class=\"comment\">// 输入数据长度除以3得到的余数</span></span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"comment\">// 每次取3个字节，编码成4个字符</span></span><br><span class=\"line\">    <span class=\"built_in\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nDiv; i ++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 取3个字节</span></span><br><span class=\"line\">        c1 = *pSrc++;</span><br><span class=\"line\">        c2 = *pSrc++;</span><br><span class=\"line\">        c3 = *pSrc++;</span><br><span class=\"line\"> </span><br><span class=\"line\">        <span class=\"comment\">// 编码成4个字符</span></span><br><span class=\"line\">        *pDst++ = EnBase64Tab[c1 &gt;&gt; <span class=\"number\">2</span>];</span><br><span class=\"line\">        *pDst++ = EnBase64Tab[((c1 &lt;&lt; <span class=\"number\">4</span>) | (c2 &gt;&gt; <span class=\"number\">4</span>)) &amp; <span class=\"number\">0x3f</span>];</span><br><span class=\"line\">        *pDst++ = EnBase64Tab[((c2 &lt;&lt; <span class=\"number\">2</span>) | (c3 &gt;&gt; <span class=\"number\">6</span>)) &amp; <span class=\"number\">0x3f</span>];</span><br><span class=\"line\">        *pDst++ = EnBase64Tab[c3 &amp; <span class=\"number\">0x3f</span>];</span><br><span class=\"line\">        nLineLen += <span class=\"number\">4</span>;</span><br><span class=\"line\">        nDstLen += <span class=\"number\">4</span>;</span><br><span class=\"line\"> </span><br><span class=\"line\">        <span class=\"comment\">// 是否输出换行？</span></span><br><span class=\"line\">        <span class=\"built_in\">if</span> (nLineLen &gt; nMaxLineLen - <span class=\"number\">4</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            *pDst++ = <span class=\"string\">'/r'</span>;</span><br><span class=\"line\">            *pDst++ = <span class=\"string\">'/n'</span>;</span><br><span class=\"line\">            nLineLen = <span class=\"number\">0</span>;</span><br><span class=\"line\">            nDstLen += <span class=\"number\">2</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"comment\">// 编码余下的字节</span></span><br><span class=\"line\">    <span class=\"built_in\">if</span> (nMod == <span class=\"number\">1</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        c1 = *pSrc++;</span><br><span class=\"line\">        *pDst++ = EnBase64Tab[(c1 &amp; <span class=\"number\">0xfc</span>) &gt;&gt; <span class=\"number\">2</span>];</span><br><span class=\"line\">        *pDst++ = EnBase64Tab[((c1 &amp; <span class=\"number\">0x03</span>) &lt;&lt; <span class=\"number\">4</span>)];</span><br><span class=\"line\">        *pDst++ = <span class=\"string\">'='</span>;</span><br><span class=\"line\">        *pDst++ = <span class=\"string\">'='</span>;</span><br><span class=\"line\">        nLineLen += <span class=\"number\">4</span>;</span><br><span class=\"line\">        nDstLen += <span class=\"number\">4</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">else</span> <span class=\"built_in\">if</span> (nMod == <span class=\"number\">2</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        c1 = *pSrc++;</span><br><span class=\"line\">        c2 = *pSrc++;</span><br><span class=\"line\">        *pDst++ = EnBase64Tab[(c1 &amp; <span class=\"number\">0xfc</span>) &gt;&gt; <span class=\"number\">2</span>];</span><br><span class=\"line\">        *pDst++ = EnBase64Tab[((c1 &amp; <span class=\"number\">0x03</span>) &lt;&lt; <span class=\"number\">4</span>) | ((c2 &amp; <span class=\"number\">0xf0</span>) &gt;&gt; <span class=\"number\">4</span>)];</span><br><span class=\"line\">        *pDst++ = EnBase64Tab[((c2 &amp; <span class=\"number\">0x0f</span>) &lt;&lt; <span class=\"number\">2</span>)];</span><br><span class=\"line\">        *pDst++ = <span class=\"string\">'='</span>;</span><br><span class=\"line\">        nDstLen += <span class=\"number\">4</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"comment\">// 输出加个结束符</span></span><br><span class=\"line\">    *pDst = <span class=\"string\">'/0'</span>;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"built_in\">return</span> nDstLen;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","text":"之前根本就没有听过base64编码，可能还是对网络这里了解不够，参加了北京柠檬微趣的现场笔试，看到了这个题目，当时想的太简单了，其实本来思路想好之后就不会很难，可惜先入为主了，导致没有参加面试机会，可惜可惜！！！<br>特总结base64编码实现如下：Base64编码是一种基于6","link":"","raw":null,"photos":[],"categories":[{"name":"面试","slug":"面试","count":32,"path":"api/categories/面试.json"}],"tags":[{"name":"C++","slug":"C","count":25,"path":"api/tags/C.json"}]},{"title":"实现String类","slug":"C-面试问题准备-实现String类","date":"2018-03-13T10:04:21.000Z","updated":"2018-03-14T13:33:59.000Z","comments":true,"path":"api/articles/C-面试问题准备-实现String类.json","excerpt":"<h2 id=\"String-类\"><a href=\"#String-类\" class=\"headerlink\" title=\"String 类\"></a>String 类</h2><p>原型如下：</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class <span class=\"keyword\">String</span></span><br><span class=\"line\">&#123; </span><br><span class=\"line\"> <span class=\"keyword\">public</span>: </span><br><span class=\"line\"> <span class=\"keyword\">String</span>(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *str = NULL); <span class=\"comment\">// 普通构造函数 </span></span><br><span class=\"line\"> <span class=\"keyword\">String</span>(<span class=\"keyword\">const</span> <span class=\"keyword\">String</span> &amp;other); <span class=\"comment\">// 拷贝构造函数 </span></span><br><span class=\"line\"> ~ <span class=\"keyword\">String</span>(<span class=\"keyword\">void</span>); <span class=\"comment\">// 析构函数 </span></span><br><span class=\"line\"> <span class=\"keyword\">String</span> &amp; <span class=\"keyword\">operator</span> =(<span class=\"keyword\">const</span> <span class=\"keyword\">String</span> &amp;other); <span class=\"comment\">// 赋值函数 </span></span><br><span class=\"line\"> <span class=\"keyword\">private</span>: </span><br><span class=\"line\"> <span class=\"keyword\">char</span> *m_data; <span class=\"comment\">// 用于保存字符串 </span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>","keywords":null,"cover":null,"content":null,"text":"String 类原型如下：1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>class String<br>&#123; <br> public: <br> String(const char *str = NULL); // ","link":"","raw":null,"photos":[],"categories":[{"name":"面试","slug":"面试","count":32,"path":"api/categories/面试.json"}],"tags":[{"name":"C++","slug":"C","count":25,"path":"api/tags/C.json"}]},{"title":"KMP算法","slug":"C-面试问题准备：KMP算法","date":"2018-03-12T16:35:13.000Z","updated":"2018-03-14T13:21:03.000Z","comments":true,"path":"api/articles/C-面试问题准备：KMP算法.json","excerpt":"<blockquote>\n<p>在说KMP算法之前先说一下普通的模式匹配算法</p>\n</blockquote>\n<h2 id=\"BF蛮力算法–字符串匹配\"><a href=\"#BF蛮力算法–字符串匹配\" class=\"headerlink\" title=\"BF蛮力算法–字符串匹配\"></a>BF蛮力算法–字符串匹配</h2><font size=\"5\">算法思想：</font><br><font color=\"#DC143C\">从目标串T的的第一个字符起与模式串P的第一个字符比较<br>若相等，则继续对字符进行后续的比较<br>否则目标串从第二个字符起与模式串的第一个字符重新比较<br>直至模式串中的每个字符依次和目标串中的一个连续的字符序列相等为止，此时称为匹配成功，否则匹配失败</font>","keywords":null,"cover":null,"content":null,"text":"在说KMP算法之前先说一下普通的模式匹配算法BF蛮力算法–字符串匹配算法思想：<br>从目标串T的的第一个字符起与模式串P的第一个字符比较<br>若相等，则继续对字符进行后续的比较<br>否则目标串从第二个字符起与模式串的第一个字符重新比较<br>直至模式串中的每个字符依次和目标","link":"","raw":null,"photos":[],"categories":[{"name":"面试","slug":"面试","count":32,"path":"api/categories/面试.json"}],"tags":[{"name":"C++","slug":"C","count":25,"path":"api/tags/C.json"}]},{"title":"剑指 offer--丑数和两个链表的第一个公共结点","slug":"C-面试问题准备：剑指-offer-丑数和两个链表的第一个公共结点","date":"2018-03-12T10:01:41.000Z","updated":"2018-03-14T13:21:03.000Z","comments":true,"path":"api/articles/C-面试问题准备：剑指-offer-丑数和两个链表的第一个公共结点.json","excerpt":"<h2 id=\"两个链表的第一个公共结点\"><a href=\"#两个链表的第一个公共结点\" class=\"headerlink\" title=\"两个链表的第一个公共结点\"></a>两个链表的第一个公共结点</h2><blockquote>\n<p>问题描述：输入两个链表，找出它们的第一个公共结点。</p>\n</blockquote>\n<p>这道题第一次很容易想到，在第一个链表上遍历每个结点的时候再在第二个链表顺序遍历所有的结点，如果第二个链表上有一个结点和第一个链表上的结点一样，则返回该结点。但是这样的遍历方式会导致时间复杂度为O(mn);","keywords":null,"cover":null,"content":null,"text":"两个链表的第一个公共结点问题描述：输入两个链表，找出它们的第一个公共结点。这道题第一次很容易想到，在第一个链表上遍历每个结点的时候再在第二个链表顺序遍历所有的结点，如果第二个链表上有一个结点和第一个链表上的结点一样，则返回该结点。但是这样的遍历方式会导致时间复杂度为O(mn);这","link":"","raw":null,"photos":[],"categories":[{"name":"面试","slug":"面试","count":32,"path":"api/categories/面试.json"}],"tags":[{"name":"C++","slug":"C","count":25,"path":"api/tags/C.json"}]},{"title":"2018-03-11","slug":"2018-03-11","date":"2018-03-11T15:33:03.000Z","updated":"2018-03-12T01:36:58.000Z","comments":true,"path":"api/articles/2018-03-11.json","excerpt":"<p>今天是喜欢糖永永同学的第60天，在这60天里我知道了她的很多故事和经历。看到了她的各种表情，生气、难过、开心、犹豫、纠结、茫然、撒娇。。。我知道了她是一个非常非常感性的姑娘。","keywords":null,"cover":null,"content":null,"text":"今天是喜欢糖永永同学的第60天，在这60天里我知道了她的很多故事和经历。看到了她的各种表情，生气、难过、开心、犹豫、纠结、茫然、撒娇。。。我知道了她是一个非常非常感性的姑娘。有人说，真正的爱是不会计算的。从来没有全心全意爱过一个人，从来没有想过一个人可以让我无时无刻不充满动力，又","link":"","raw":null,"photos":[],"categories":[{"name":"日记","slug":"life","count":27,"path":"api/categories/life.json"}],"tags":[]},{"title":"如何实现守护进程","slug":"C-面试问题准备：如何实现守护进程","date":"2018-03-11T11:27:06.000Z","updated":"2018-03-14T13:23:16.000Z","comments":true,"path":"api/articles/C-面试问题准备：如何实现守护进程.json","excerpt":"<h3 id=\"守护进程\"><a href=\"#守护进程\" class=\"headerlink\" title=\"守护进程\"></a>守护进程</h3><p>守护进程也称精灵进程(Daemon)，是运行在后台的一种特殊进程。它独立于控制终端并且周期性的执行某种任务或等待处理某些发送的事件。Linux上的大多数服务器就是用守护进程实现的。","keywords":null,"cover":"/images/linuxImages/deamon.png","content":null,"text":"守护进程守护进程也称精灵进程(Daemon)，是运行在后台的一种特殊进程。它独立于控制终端并且周期性的执行某种任务或等待处理某些发送的事件。Linux上的大多数服务器就是用守护进程实现的。 守护进程可以解决产生死锁的一个必要条件，资源独占问题。即可以实现间接线程资源共享，对于打印","link":"","raw":null,"photos":[],"categories":[{"name":"面试","slug":"面试","count":32,"path":"api/categories/面试.json"}],"tags":[{"name":"OS","slug":"OS","count":3,"path":"api/tags/OS.json"}]},{"title":"什么函数不能作为虚函数","slug":"C-面试问题准备：什么函数不能作为虚函数","date":"2018-03-11T07:22:28.000Z","updated":"2018-03-14T13:21:03.000Z","comments":true,"path":"api/articles/C-面试问题准备：什么函数不能作为虚函数.json","excerpt":"<p><strong><font color=\"#DC143C\">虚函数</font></strong></p>\n<p>虚函数必须是类的非静态成员，即在类的成员函数生命中前面关键字为<code>virtual</code>的是虚函数。虚函数是为了实现的面向对象的多态（动态绑定）机制而提出来的。<br>即在程序运行过程中，进行对象所属类型的匹配，也是父类对象访问子类成员的方式。本质上还是为了实现代码复用以及项目的鲁棒性。","keywords":null,"cover":null,"content":null,"text":"虚函数虚函数必须是类的非静态成员，即在类的成员函数生命中前面关键字为virtual的是虚函数。虚函数是为了实现的面向对象的多态（动态绑定）机制而提出来的。<br>即在程序运行过程中，进行对象所属类型的匹配，也是父类对象访问子类成员的方式。本质上还是为了实现代码复用以及项目的鲁棒性","link":"","raw":null,"photos":[],"categories":[{"name":"面试","slug":"面试","count":32,"path":"api/categories/面试.json"}],"tags":[{"name":"C++","slug":"C","count":25,"path":"api/tags/C.json"}]},{"title":"sizeof(class)的大小","slug":"C-面试问题准备-C-类的大小-sizeof-class","date":"2018-03-11T06:18:40.000Z","updated":"2018-03-14T13:33:27.000Z","comments":true,"path":"api/articles/C-面试问题准备-C-类的大小-sizeof-class.json","excerpt":"<h3 id=\"空类的大小\"><a href=\"#空类的大小\" class=\"headerlink\" title=\"空类的大小\"></a>空类的大小</h3><p><img src=\"/images/emptyClass.png\" alt=\"\"></p>\n<p>为什么空的什么都没有是1呢？","keywords":null,"cover":"/images/emptyClass.png","content":null,"text":"空类的大小 [Figure] 看到添加了静态变量的显示结果是和上一个显示的结果一样的。因为static变量对于整个类只有一份拷贝，且静态成员被编译器放在内存空间的全局存储区，但是在类实例化的时候只为类中的成员变量分配存储空间，所以它不会影响类的大小。","link":"","raw":null,"photos":[],"categories":[{"name":"面试","slug":"面试","count":32,"path":"api/categories/面试.json"}],"tags":[{"name":"C++","slug":"C","count":25,"path":"api/tags/C.json"}]},{"title":"tcp/udp通信过程以及局域网内非阻塞的通信","slug":"C-面试问题准备：tcp-udp通信过程以及局域网内非阻塞的通信","date":"2018-03-11T04:52:45.000Z","updated":"2018-03-14T13:21:03.000Z","comments":true,"path":"api/articles/C-面试问题准备：tcp-udp通信过程以及局域网内非阻塞的通信.json","excerpt":"<h2 id=\"TCP和UDP协议的特点\"><a href=\"#TCP和UDP协议的特点\" class=\"headerlink\" title=\"TCP和UDP协议的特点\"></a>TCP和UDP协议的特点</h2><p><strong><font color=\"#DC143C\">TCP</font></strong></p>\n<ul>\n<li>支持面向链接的传输服务（相当于人们打电话，需要先建立一个用来传输双方信息的链接）</li>\n<li>支持字节流的传输（流模式 stream socket）</li>\n<li>支持全双工通信（允许通信双方的应用程序在任何时候都可以发送数据）</li>\n<li>支持建立多个并发的TCP链接</li>\n<li>支持可靠的传输服务（提供确认／重传与拥塞控制功能）","keywords":null,"cover":"/images/tcp.png","content":null,"text":"TCP和UDP协议的特点TCP支持面向链接的传输服务（相当于人们打电话，需要先建立一个用来传输双方信息的链接）支持字节流的传输（流模式 stream socket）支持全双工通信（允许通信双方的应用程序在任何时候都可以发送数据）支持建立多个并发的TCP链接支持可靠的传输服务（提供","link":"","raw":null,"photos":[],"categories":[{"name":"面试","slug":"面试","count":32,"path":"api/categories/面试.json"}],"tags":[{"name":"网络通信","slug":"网络通信","count":1,"path":"api/tags/网络通信.json"}]}]}