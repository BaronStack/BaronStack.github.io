{"total":73,"pageSize":10,"pageCount":8,"data":[{"title":"西山居：开发工程师面经","slug":"西山居：开发工程师面经","date":"2018-03-16T03:20:41.000Z","updated":"2018-03-16T04:05:25.000Z","comments":true,"path":"api/articles/西山居：开发工程师面经.json","excerpt":"<p>当我写下这篇博客的时候其实已经知道我此次面试已经没戏了，但是我还是想要反思自我实力以及对网上所谓西山居面经的吐槽（网上的面经太简单了）。  </p>\n<p>昨晚收到面试通知，我是C／C++方向，之后就一直在具体准备，先是网上的面经，就是一些较为基础的问题：","keywords":null,"cover":null,"content":null,"text":"当我写下这篇博客的时候其实已经知道我此次面试已经没戏了，但是我还是想要反思自我实力以及对网上所谓西山居面经的吐槽（网上的面经太简单了）。  昨晚收到面试通知，我是C／C++方向，之后就一直在具体准备，先是网上的面经，就是一些较为基础的问题：  堆和栈的区别静态库和动态库的区别，什","link":"","raw":null,"photos":[],"categories":[{"name":"面试","slug":"面试","count":35,"path":"api/categories/面试.json"}],"tags":[]},{"title":"Linux常用信号","slug":"Linux常用信号","date":"2018-03-15T03:43:58.000Z","updated":"2018-03-16T04:05:25.000Z","comments":true,"path":"api/articles/Linux常用信号.json","excerpt":"","keywords":null,"cover":"/images/kill.png","content":"<h2 id=\"常用Linux信号\"><a href=\"#常用Linux信号\" class=\"headerlink\" title=\"常用Linux信号\"></a>常用Linux信号</h2><p><img src=\"/images/kill.png\" alt=\"\"></p>\n<blockquote>\n<p>Linux系统下有很多信号，按照可靠性可以分为可靠信号和非可靠信号，按时间分为实时信号和非实时信号。</p>\n</blockquote>\n<p>Linux有三种方式来处理收到的信号：</p>\n<ul>\n<li>忽略信号：即对信号不作处理（除了SIGKILL和SIGSTOP）</li>\n<li>捕捉信号：定义信号处理函数，当信号发生时，执行相应的处理函数</li>\n<li>执行缺省操作，Linux对每种信号都规定了默认操作</li>\n</ul>\n<p>常用信号如下：</p>\n<ol>\n<li><strong><font color=\"#DC143C\">SIGHUP</font></strong> 和控制台操作相关，当控制台被关闭的时候系统会向拥有控制台sessionID的进程发送HUP信号，默认HUP信号执行的action是exit,如果远程登启动某个服务进程，并在程序运行时关闭某个链接的会话导致服务进程退出，所以服务程序一般都会用nohup工具启动（该命令就是让系统忽略该信号），或者写一个daemon<a href=\"\">守护进程</a>(利用setsid进行)。</li>\n<li><strong><font color=\"#DC143C\">SIGINT</font></strong> 终止进程，通常我们的ctrl+c就发送这个消息</li>\n<li><strong><font color=\"#DC143C\">SIGQUIT</font></strong> 和SIGINT类似, 但由QUIT字符(通常是Ctrl- / )来控制. 进程收到该消息退出时会产生core文件。</li>\n<li><strong><font color=\"#DC143C\">SIGKILL</font></strong> 消息编号为9，我们经常用kill -9来杀死进程,发送的就是这个消息，程序收到这个消息立即终止，这个消息不能被捕获，封锁或忽略，所以是杀死进程的终极武器。</li>\n<li><strong><font color=\"#DC143C\">SIGTERM</font></strong> 不带参数时kill默认发送的信号，默认是杀死进程</li>\n<li><strong><font color=\"#DC143C\">SIGSTOP</font></strong> 停止进程的执行，同SIGKILL一样不可以被应用程序所处理，注意它和terminate以及interrupt的区别:该进程还未结束, 只是暂停执行</li>\n</ol>\n","text":"常用Linux信号 [Figure] Linux系统下有很多信号，按照可靠性可以分为可靠信号和非可靠信号，按时间分为实时信号和非实时信号。Linux有三种方式来处理收到的信号：忽略信号：即对信号不作处理（除了SIGKILL和SIGSTOP）捕捉信号：定义信号处理函数，当信号发生时","link":"","raw":null,"photos":[],"categories":[{"name":"面试","slug":"面试","count":35,"path":"api/categories/面试.json"}],"tags":[{"name":"linux","slug":"linux","count":7,"path":"api/tags/linux.json"}]},{"title":"系统调用与函数调用","slug":"系统调用与函数调用","date":"2018-03-15T02:33:24.000Z","updated":"2018-03-15T03:40:31.000Z","comments":true,"path":"api/articles/系统调用与函数调用.json","excerpt":"<blockquote>\n<p>Linux下对文件的操作有两种方式：系统调用（system call）和库函数调用（Library Functions）</p>\n</blockquote>\n<h3 id=\"系统调用（system-call）\"><a href=\"#系统调用（system-call）\" class=\"headerlink\" title=\"系统调用（system call）\"></a>系统调用（system call）</h3><blockquote>\n<p>指运行在<font color=\"#DC143C\">用户空间</font>的<font color=\"#DC143C\">应用程序</font>向<font color=\"#DC143C\">操作系统内核</font>请求某些服务的过程。系统调用提供了用户程序与操作系统之间的接口。一般来说系统调用都是在内核态执行，由于系统调用不考虑平台差异性，它是由内核直接提供，因而移植性较差（几乎没有移植性）。","keywords":null,"cover":"/images/syscall.png","content":null,"text":"Linux下对文件的操作有两种方式：系统调用（system call）和库函数调用（Library Functions）系统调用（system call）指运行在用户空间的应用程序向操作系统内核请求某些服务的过程。系统调用提供了用户程序与操作系统之间的接口。一般来说系统调用都是在","link":"","raw":null,"photos":[],"categories":[{"name":"面试","slug":"面试","count":35,"path":"api/categories/面试.json"}],"tags":[{"name":"OS","slug":"OS","count":4,"path":"api/tags/OS.json"}]},{"title":"项目问题总结","slug":"项目问题总结","date":"2018-03-13T15:29:42.000Z","updated":"2018-03-14T09:52:15.000Z","comments":true,"path":"api/articles/项目问题总结.json","excerpt":"<h2 id=\"问题一：主机间通信断开链接后重新连接失败，显示接受（C端）端口被占用\"><a href=\"#问题一：主机间通信断开链接后重新连接失败，显示接受（C端）端口被占用\" class=\"headerlink\" title=\"问题一：主机间通信断开链接后重新连接失败，显示接受（C端）端口被占用\"></a>问题一：主机间通信断开链接后重新连接失败，显示接受（C端）端口被占用</h2><h3 id=\"分析：\"><a href=\"#分析：\" class=\"headerlink\" title=\"分析：\"></a><font color=\"#DC143C\">分析：</font></h3><p>主机之间建立的链接属于TCP链接，断开的时候会发生TCP四次挥手，过程中C端会进入TIME_WAIT状态，有时S端主动断开链接的时候也会导致S端进入TIME_WAIT状态。即我们断开TCP链接的时候并没有完全断开，此时S端还处于TIME_WAIT，导致通信端口被占用，无法创建新的链接。","keywords":null,"cover":"/images/time_wait.png","content":null,"text":"问题一：主机间通信断开链接后重新连接失败，显示接受（C端）端口被占用分析：主机之间建立的链接属于TCP链接，断开的时候会发生TCP四次挥手，过程中C端会进入TIME_WAIT状态，有时S端主动断开链接的时候也会导致S端进入TIME_WAIT状态。即我们断开TCP链接的时候并没有完","link":"","raw":null,"photos":[],"categories":[{"name":"面试","slug":"面试","count":35,"path":"api/categories/面试.json"}],"tags":[]},{"title":"Base64编码方式及实现代码","slug":"C-面试问题准备：Base64编码方式及实现代码","date":"2018-03-13T13:39:21.000Z","updated":"2018-03-14T13:59:20.000Z","comments":true,"path":"api/articles/C-面试问题准备：Base64编码方式及实现代码.json","excerpt":"<blockquote>\n<p>之前根本就没有听过base64编码，可能还是对网络这里了解不够，参加了北京柠檬微趣的现场笔试，看到了这个题目，当时想的太简单了，其实本来思路想好之后就不会很难，可惜先入为主了，导致没有参加面试机会，可惜可惜！！！<br>特总结base64编码实现如下：<br>","keywords":null,"cover":"/images/base64.png","content":null,"text":"之前根本就没有听过base64编码，可能还是对网络这里了解不够，参加了北京柠檬微趣的现场笔试，看到了这个题目，当时想的太简单了，其实本来思路想好之后就不会很难，可惜先入为主了，导致没有参加面试机会，可惜可惜！！！<br>特总结base64编码实现如下：<br>Base64编码是一","link":"","raw":null,"photos":[],"categories":[{"name":"面试","slug":"面试","count":35,"path":"api/categories/面试.json"}],"tags":[{"name":"C++","slug":"C","count":25,"path":"api/tags/C.json"}]},{"title":"实现String类","slug":"C-面试问题准备-实现String类","date":"2018-03-13T10:04:21.000Z","updated":"2018-03-14T13:33:59.000Z","comments":true,"path":"api/articles/C-面试问题准备-实现String类.json","excerpt":"<h2 id=\"String-类\"><a href=\"#String-类\" class=\"headerlink\" title=\"String 类\"></a>String 类</h2><p>原型如下：</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class <span class=\"keyword\">String</span></span><br><span class=\"line\">&#123; </span><br><span class=\"line\"> <span class=\"keyword\">public</span>: </span><br><span class=\"line\"> <span class=\"keyword\">String</span>(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *str = NULL); <span class=\"comment\">// 普通构造函数 </span></span><br><span class=\"line\"> <span class=\"keyword\">String</span>(<span class=\"keyword\">const</span> <span class=\"keyword\">String</span> &amp;other); <span class=\"comment\">// 拷贝构造函数 </span></span><br><span class=\"line\"> ~ <span class=\"keyword\">String</span>(<span class=\"keyword\">void</span>); <span class=\"comment\">// 析构函数 </span></span><br><span class=\"line\"> <span class=\"keyword\">String</span> &amp; <span class=\"keyword\">operator</span> =(<span class=\"keyword\">const</span> <span class=\"keyword\">String</span> &amp;other); <span class=\"comment\">// 赋值函数 </span></span><br><span class=\"line\"> <span class=\"keyword\">private</span>: </span><br><span class=\"line\"> <span class=\"keyword\">char</span> *m_data; <span class=\"comment\">// 用于保存字符串 </span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>","keywords":null,"cover":null,"content":null,"text":"String 类原型如下：1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>class String<br>&#123; <br> public: <br> String(const char *str = NULL); // ","link":"","raw":null,"photos":[],"categories":[{"name":"面试","slug":"面试","count":35,"path":"api/categories/面试.json"}],"tags":[{"name":"C++","slug":"C","count":25,"path":"api/tags/C.json"}]},{"title":"KMP算法","slug":"C-面试问题准备：KMP算法","date":"2018-03-12T16:35:13.000Z","updated":"2018-03-14T13:21:03.000Z","comments":true,"path":"api/articles/C-面试问题准备：KMP算法.json","excerpt":"<blockquote>\n<p>在说KMP算法之前先说一下普通的模式匹配算法</p>\n</blockquote>\n<h2 id=\"BF蛮力算法–字符串匹配\"><a href=\"#BF蛮力算法–字符串匹配\" class=\"headerlink\" title=\"BF蛮力算法–字符串匹配\"></a>BF蛮力算法–字符串匹配</h2><font size=\"5\">算法思想：</font><br><font color=\"#DC143C\">从目标串T的的第一个字符起与模式串P的第一个字符比较<br>若相等，则继续对字符进行后续的比较<br>否则目标串从第二个字符起与模式串的第一个字符重新比较<br>直至模式串中的每个字符依次和目标串中的一个连续的字符序列相等为止，此时称为匹配成功，否则匹配失败</font>","keywords":null,"cover":null,"content":null,"text":"在说KMP算法之前先说一下普通的模式匹配算法BF蛮力算法–字符串匹配算法思想：<br>从目标串T的的第一个字符起与模式串P的第一个字符比较<br>若相等，则继续对字符进行后续的比较<br>否则目标串从第二个字符起与模式串的第一个字符重新比较<br>直至模式串中的每个字符依次和目标","link":"","raw":null,"photos":[],"categories":[{"name":"面试","slug":"面试","count":35,"path":"api/categories/面试.json"}],"tags":[{"name":"C++","slug":"C","count":25,"path":"api/tags/C.json"}]},{"title":"剑指 offer--丑数和两个链表的第一个公共结点","slug":"C-面试问题准备：剑指-offer-丑数和两个链表的第一个公共结点","date":"2018-03-12T10:01:41.000Z","updated":"2018-03-14T13:21:03.000Z","comments":true,"path":"api/articles/C-面试问题准备：剑指-offer-丑数和两个链表的第一个公共结点.json","excerpt":"<h2 id=\"两个链表的第一个公共结点\"><a href=\"#两个链表的第一个公共结点\" class=\"headerlink\" title=\"两个链表的第一个公共结点\"></a>两个链表的第一个公共结点</h2><blockquote>\n<p>问题描述：输入两个链表，找出它们的第一个公共结点。</p>\n</blockquote>\n<p>这道题第一次很容易想到，在第一个链表上遍历每个结点的时候再在第二个链表顺序遍历所有的结点，如果第二个链表上有一个结点和第一个链表上的结点一样，则返回该结点。但是这样的遍历方式会导致时间复杂度为O(mn);","keywords":null,"cover":null,"content":null,"text":"两个链表的第一个公共结点问题描述：输入两个链表，找出它们的第一个公共结点。这道题第一次很容易想到，在第一个链表上遍历每个结点的时候再在第二个链表顺序遍历所有的结点，如果第二个链表上有一个结点和第一个链表上的结点一样，则返回该结点。但是这样的遍历方式会导致时间复杂度为O(mn);这","link":"","raw":null,"photos":[],"categories":[{"name":"面试","slug":"面试","count":35,"path":"api/categories/面试.json"}],"tags":[{"name":"C++","slug":"C","count":25,"path":"api/tags/C.json"}]},{"title":"2018-03-11","slug":"2018-03-11","date":"2018-03-11T15:33:03.000Z","updated":"2018-03-12T01:36:58.000Z","comments":true,"path":"api/articles/2018-03-11.json","excerpt":"<p>今天是喜欢糖永永同学的第60天，在这60天里我知道了她的很多故事和经历。看到了她的各种表情，生气、难过、开心、犹豫、纠结、茫然、撒娇。。。我知道了她是一个非常非常感性的姑娘。","keywords":null,"cover":null,"content":null,"text":"今天是喜欢糖永永同学的第60天，在这60天里我知道了她的很多故事和经历。看到了她的各种表情，生气、难过、开心、犹豫、纠结、茫然、撒娇。。。我知道了她是一个非常非常感性的姑娘。有人说，真正的爱是不会计算的。从来没有全心全意爱过一个人，从来没有想过一个人可以让我无时无刻不充满动力，又","link":"","raw":null,"photos":[],"categories":[{"name":"日记","slug":"life","count":27,"path":"api/categories/life.json"}],"tags":[]},{"title":"如何实现守护进程","slug":"C-面试问题准备：如何实现守护进程","date":"2018-03-11T11:27:06.000Z","updated":"2018-03-14T13:23:16.000Z","comments":true,"path":"api/articles/C-面试问题准备：如何实现守护进程.json","excerpt":"<h3 id=\"守护进程\"><a href=\"#守护进程\" class=\"headerlink\" title=\"守护进程\"></a>守护进程</h3><p>守护进程也称精灵进程(Daemon)，是运行在后台的一种特殊进程。它独立于控制终端并且周期性的执行某种任务或等待处理某些发送的事件。Linux上的大多数服务器就是用守护进程实现的。","keywords":null,"cover":"/images/linuxImages/deamon.png","content":null,"text":"守护进程守护进程也称精灵进程(Daemon)，是运行在后台的一种特殊进程。它独立于控制终端并且周期性的执行某种任务或等待处理某些发送的事件。Linux上的大多数服务器就是用守护进程实现的。 守护进程可以解决产生死锁的一个必要条件，资源独占问题。即可以实现间接线程资源共享，对于打印","link":"","raw":null,"photos":[],"categories":[{"name":"面试","slug":"面试","count":35,"path":"api/categories/面试.json"}],"tags":[{"name":"OS","slug":"OS","count":4,"path":"api/tags/OS.json"}]}]}