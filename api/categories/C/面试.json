{"name":"面试","slug":"C/面试","count":3,"postlist":[{"title":"C++面试问题准备：STL--allocator","slug":"C-开发面试准备：STL-allocator","date":"2018-01-27T15:02:40.000Z","updated":"2018-02-11T12:54:16.000Z","comments":true,"path":"api/articles/C-开发面试准备：STL-allocator.json","excerpt":"<blockquote>\n<p>最近在读侯捷老师的《STL源码剖析》，写写总结。他的STL主要是SGI 版本的，也就是我们常用的GCC编译器支持","keywords":null,"cover":null,"content":null,"text":"最近在读侯捷老师的《STL源码剖析》，写写总结。他的STL主要是SGI 版本的，也就是我们常用的GCC编译器支持 什么是allocator相信对C++感兴趣的伙伴肯定对STL这个模版库情有独钟，但是当站在STL的角度来看这些容器的实现那么第一个需要知道的就是allocatoral","link":"","raw":null,"photos":[],"categories":[{"name":"C++","slug":"C","count":3,"path":"api/categories/C.json"},{"name":"面试","slug":"C/面试","count":3,"path":"api/categories/C/面试.json"}],"tags":[{"name":"C++","slug":"C","count":8,"path":"api/tags/C.json"}]},{"title":"C++面试问题准备：STL-iterator","slug":"C-面试问题准备：STL-iterator","date":"2018-02-11T12:53:12.000Z","updated":"2018-02-11T13:37:14.000Z","comments":true,"path":"api/articles/C-面试问题准备：STL-iterator.json","excerpt":"","keywords":null,"cover":null,"content":"<blockquote>\n<p>这两天在家里没有好好读书，要反思一下。今天看《STL源码剖析》到了迭代器iterator这里</p>\n</blockquote>\n<h2 id=\"什么是迭代器\"><a href=\"#什么是迭代器\" class=\"headerlink\" title=\"什么是迭代器\"></a>什么是迭代器</h2><p>在《Design Patterns》中对迭代器模式的描述如下：<font color=\"#DC143C\">提供一种方法，使之能够依序寻访某个聚合物（容器）所含的各个元素，而又无需暴露该聚合物内部表现方式</font></p>\n<blockquote>\n<p>这里小小的回忆下我们复习过的面向对象五大原则，显然该设计模式满足单一职责原则(<strong>对于迭代器来说只有元素地址能够引起它的变化</strong>)以及接口隔离(<strong>迭代器的设计就是为了访问数据元素，即访问接口</strong>)原则。详细请看<a href=\"https://baronstack.github.io/#/posts/C-面试问题准备：面向对象的基本原则\" target=\"_blank\" rel=\"noopener\">面向对象基本原则</a></p>\n</blockquote>\n<p>观察如下代码：</p>\n<figure class=\"highlight applescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;<span class=\"built_in\">class</span> InputIterator,<span class=\"built_in\">class</span> T&gt;</span><br><span class=\"line\">InputIterator find (InputIterator <span class=\"keyword\">first</span>,InputIterator <span class=\"keyword\">last</span>,const T&amp; value) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"keyword\">first</span> != <span class=\"keyword\">last</span> &amp;&amp; *<span class=\"keyword\">first</span> != value)</span><br><span class=\"line\">        ++ <span class=\"keyword\">first</span>;</span><br><span class=\"line\"><span class=\"built_in\">    return</span> <span class=\"keyword\">first</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这是一段find()函数的源码，显然我们能够发现，给予不同的迭代器，find函数便能够对不同的容器进行查找操作。</p>\n","text":"这两天在家里没有好好读书，要反思一下。今天看《STL源码剖析》到了迭代器iterator这里什么是迭代器在《Design Patterns》中对迭代器模式的描述如下：提供一种方法，使之能够依序寻访某个聚合物（容器）所含的各个元素，而又无需暴露该聚合物内部表现方式这里小小的回忆下我","link":"","raw":null,"photos":[],"categories":[{"name":"C++","slug":"C","count":3,"path":"api/categories/C.json"},{"name":"面试","slug":"C/面试","count":3,"path":"api/categories/C/面试.json"}],"tags":[{"name":"C++","slug":"C","count":8,"path":"api/tags/C.json"}]},{"title":"C++面试问题准备：const和static关键字","slug":"C-面试问题准备：const和static关键字","date":"2018-01-31T01:51:41.000Z","updated":"2018-02-11T12:54:16.000Z","comments":true,"path":"api/articles/C-面试问题准备：const和static关键字.json","excerpt":"<h2 id=\"常量-（const）\"><a href=\"#常量-（const）\" class=\"headerlink\" title=\"常量 （const）\"></a>常量 （const）</h2><ul>\n<li><p>const类型值不能被修改，这里指的是const修饰的内容不能被修改，且const修饰的常量在超出其作用域之后会被释放","keywords":null,"cover":null,"content":null,"text":"常量 （const）const类型值不能被修改，这里指的是const修饰的内容不能被修改，且const修饰的常量在超出其作用域之后会被释放 在类中：const数据成员只在某个对象生存期是常量，而类可以创建很多的对象，所以不同对象类的const数据成员是可以不同的.在类中：cons","link":"","raw":null,"photos":[],"categories":[{"name":"C++","slug":"C","count":3,"path":"api/categories/C.json"},{"name":"面试","slug":"C/面试","count":3,"path":"api/categories/C/面试.json"}],"tags":[{"name":"C++","slug":"C","count":8,"path":"api/tags/C.json"}]}]}