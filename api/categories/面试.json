{"name":"面试","slug":"面试","count":18,"postlist":[{"title":"C++面试问题准备：STL--allocator","slug":"C-开发面试准备：STL-allocator","date":"2018-01-27T15:02:40.000Z","updated":"2018-02-26T12:57:55.000Z","comments":true,"path":"api/articles/C-开发面试准备：STL-allocator.json","excerpt":"<blockquote>\n<p>最近在读侯捷老师的《STL源码剖析》，写写总结。他的STL主要是SGI 版本的，也就是我们常用的GCC编译器支持","keywords":null,"cover":null,"content":null,"text":"最近在读侯捷老师的《STL源码剖析》，写写总结。他的STL主要是SGI 版本的，也就是我们常用的GCC编译器支持 什么是allocator相信对C++感兴趣的伙伴肯定对STL这个模版库情有独钟，但是当站在STL的角度来看这些容器的实现那么第一个需要知道的就是allocatoral","link":"","raw":null,"photos":[],"categories":[{"name":"面试","slug":"面试","count":18,"path":"api/categories/面试.json"}],"tags":[{"name":"C++","slug":"C","count":16,"path":"api/tags/C.json"}]},{"title":"C++开发面试问题","slug":"C-开发面试问题","date":"2018-01-26T14:47:27.000Z","updated":"2018-02-22T12:54:00.000Z","comments":true,"path":"api/articles/C-开发面试问题.json","excerpt":"<h4 id=\"语言基础\"><a href=\"#语言基础\" class=\"headerlink\" title=\"语言基础\"></a>语言基础</h4><ul>\n<li>OOP（封装、继承、多态） + V func 的实现，V table 的原理</li>\n<li>const static的各种情况，分清const pointer 和pointer to const以及两者合体的形式","keywords":null,"cover":null,"content":null,"text":"语言基础OOP（封装、继承、多态） + V func 的实现，V table 的原理const static的各种情况，分清const pointer 和pointer to const以及两者合体的形式内存泄漏 三条规则。注意exception safe和smart point","link":"","raw":null,"photos":[],"categories":[{"name":"面试","slug":"面试","count":18,"path":"api/categories/面试.json"}],"tags":[{"name":"C++","slug":"C","count":16,"path":"api/tags/C.json"}]},{"title":"C++开发面试问题准备：源程序编译过程以及静态链接和动态链接的区别","slug":"C-开发面试问题准备：静态链接和动态链接","date":"2018-02-07T04:44:33.000Z","updated":"2018-03-05T06:39:13.000Z","comments":true,"path":"api/articles/C-开发面试问题准备：静态链接和动态链接.json","excerpt":"<p>在Linux下我们用GCC对源码进行编译，编译的过程中有一个步骤是链接。这里我们先了解一下编译的过程，我在xmind中画的一个图如下，对软件不够熟悉，所以画得比较丑。</p>\n<p><img src=\"/images/Compile&amp;&amp;Linking.png\" alt=\"编译过程\"></p>\n<p>大体分为一下几个步骤：</p>\n<ul>\n<li>预处理（Preprocess）</li>\n<li>编译(Complication)</li>\n<li>汇编(Assembly)</li>\n<li>链接(Linking)</li>\n<li>执行(Execute)","keywords":null,"cover":"/images/Compile&amp;&amp;Linking.png","content":null,"text":"在Linux下我们用GCC对源码进行编译，编译的过程中有一个步骤是链接。这里我们先了解一下编译的过程，我在xmind中画的一个图如下，对软件不够熟悉，所以画得比较丑。 [Figure] 一些功能代码经过编译连接后的可执行形式静态lib将导出声明和实现都放在lib中。编译后所有代码","link":"","raw":null,"photos":[],"categories":[{"name":"面试","slug":"面试","count":18,"path":"api/categories/面试.json"}],"tags":[{"name":"C++","slug":"C","count":16,"path":"api/tags/C.json"}]},{"title":"C++面试问题准备：STL-iterator","slug":"C-面试问题准备：STL-iterator","date":"2018-02-11T12:53:12.000Z","updated":"2018-02-22T12:54:00.000Z","comments":true,"path":"api/articles/C-面试问题准备：STL-iterator.json","excerpt":"<blockquote>\n<p>这两天在家里没有好好读书，要反思一下。今天看《STL源码剖析》到了迭代器iterator这里</p>\n</blockquote>\n<h2 id=\"什么是迭代器\"><a href=\"#什么是迭代器\" class=\"headerlink\" title=\"什么是迭代器\"></a>什么是迭代器</h2><p>在《Design Patterns》中对迭代器模式的描述如下：<font color=\"#DC143C\">提供一种方法，使之能够依序寻访某个聚合物（容器）所含的各个元素，而又无需暴露该聚合物内部表现方式</font>","keywords":null,"cover":null,"content":null,"text":"这两天在家里没有好好读书，要反思一下。今天看《STL源码剖析》到了迭代器iterator这里什么是迭代器在《Design Patterns》中对迭代器模式的描述如下：提供一种方法，使之能够依序寻访某个聚合物（容器）所含的各个元素，而又无需暴露该聚合物内部表现方式 这里小小的回忆下","link":"","raw":null,"photos":[],"categories":[{"name":"面试","slug":"面试","count":18,"path":"api/categories/面试.json"}],"tags":[{"name":"C++","slug":"C","count":16,"path":"api/tags/C.json"}]},{"title":"C++面试问题准备：const和static关键字","slug":"C-面试问题准备：const和static关键字","date":"2018-01-31T01:51:41.000Z","updated":"2018-03-05T04:32:39.000Z","comments":true,"path":"api/articles/C-面试问题准备：const和static关键字.json","excerpt":"<h2 id=\"常量-（const）\"><a href=\"#常量-（const）\" class=\"headerlink\" title=\"常量 （const）\"></a>常量 （const）</h2><ul>\n<li><p>const类型值不能被修改，这里指的是const修饰的内容不能被修改，且const修饰的常量在超出其作用域之后会被释放","keywords":null,"cover":null,"content":null,"text":"常量 （const）const类型值不能被修改，这里指的是const修饰的内容不能被修改，且const修饰的常量在超出其作用域之后会被释放 在类中：const数据成员只在某个对象生存期是常量，而类可以创建很多的对象，所以不同对象类的const数据成员是可以不同的.在类中：cons","link":"","raw":null,"photos":[],"categories":[{"name":"面试","slug":"面试","count":18,"path":"api/categories/面试.json"}],"tags":[{"name":"C++","slug":"C","count":16,"path":"api/tags/C.json"}]},{"title":"C++面试问题准备：i++是否原子操作，为什么","slug":"C-面试问题准备：i-是否原子操作，为什么","date":"2018-02-17T06:48:38.000Z","updated":"2018-02-22T12:54:00.000Z","comments":true,"path":"api/articles/C-面试问题准备：i-是否原子操作，为什么.json","excerpt":"<h2 id=\"什么是操作系统原子操作\"><a href=\"#什么是操作系统原子操作\" class=\"headerlink\" title=\"什么是操作系统原子操作\"></a>什么是操作系统原子操作</h2><p><strong>原子操作是不可分割的，在执行完毕之前不会被任何其他事物或者事件中断，分为以下两种情况：</strong></p>\n<ul>\n<li>在单线程中， 能够在单条指令中完成的操作都可以认为是” 原子操作”，因为中断只能发生于指令之间</li>\n<li>在多线程中，不能被其它进程（线程）打断的操作就叫原子操作","keywords":null,"cover":null,"content":null,"text":"什么是操作系统原子操作原子操作是不可分割的，在执行完毕之前不会被任何其他事物或者事件中断，分为以下两种情况：在单线程中， 能够在单条指令中完成的操作都可以认为是” 原子操作”，因为中断只能发生于指令之间在多线程中，不能被其它进程（线程）打断的操作就叫原子操作 i++分为三个阶段内","link":"","raw":null,"photos":[],"categories":[{"name":"面试","slug":"面试","count":18,"path":"api/categories/面试.json"}],"tags":[{"name":"C++","slug":"C","count":16,"path":"api/tags/C.json"}]},{"title":"C++面试问题准备：linux cpu、系统性能调试相关命令","slug":"C-面试问题准备：linux-cpu、系统性能调试相关命令","date":"2018-02-26T13:07:17.000Z","updated":"2018-02-26T16:07:24.000Z","comments":true,"path":"api/articles/C-面试问题准备：linux-cpu、系统性能调试相关命令.json","excerpt":"<h2 id=\"Linux下查看内存和CPU占用情况\"><a href=\"#Linux下查看内存和CPU占用情况\" class=\"headerlink\" title=\"Linux下查看内存和CPU占用情况\"></a>Linux下查看内存和CPU占用情况</h2><h3 id=\"ps-将某个时间点的进程运行情况选取下来\"><a href=\"#ps-将某个时间点的进程运行情况选取下来\" class=\"headerlink\" title=\"ps:将某个时间点的进程运行情况选取下来\"></a><strong><code>ps</code>:将某个时间点的进程运行情况选取下来</strong></h3><figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">ps</span> aux  &lt;== 查看系统所有进程数据</span><br><span class=\"line\"><span class=\"keyword\">ps</span> -lA &lt;== 也是能够查看所有系统的数据</span><br><span class=\"line\"><span class=\"keyword\">ps</span> axjf &lt;== 连同部分进程树状态</span><br></pre></td></tr></table></figure>","keywords":null,"cover":"/images/linuxImages/ps_l.png","content":null,"text":"Linux下查看内存和CPU占用情况ps:将某个时间点的进程运行情况选取下来1<br>2<br>3<br>ps aux  &lt;== 查看系统所有进程数据<br>ps -lA &lt;== 也是能够查看所有系统的数据<br>ps axjf &lt;== 连同部分进程树状态<br","link":"","raw":null,"photos":[],"categories":[{"name":"面试","slug":"面试","count":18,"path":"api/categories/面试.json"}],"tags":[{"name":"linux","slug":"linux","count":5,"path":"api/tags/linux.json"}]},{"title":"C++面试问题准备：strcpy和strncpy以及memcpy函数","slug":"C-面试问题准备：strcpy和strncpy以及memcpy函数","date":"2018-03-06T02:46:32.000Z","updated":"2018-03-07T13:43:33.000Z","comments":true,"path":"api/articles/C-面试问题准备：strcpy和strncpy以及memcpy函数.json","excerpt":"<h2 id=\"strcpy函数以及strncpy函数\"><a href=\"#strcpy函数以及strncpy函数\" class=\"headerlink\" title=\"strcpy函数以及strncpy函数\"></a>strcpy函数以及strncpy函数</h2><blockquote>\n<p>这两个函数都是字符串拷贝函数</p>\n</blockquote>\n<p>函数原型：</p>\n<p><code>char * strcpy(char * destStr,char * srcStr);</code></p>\n<p><code>cahr * strncpy(char * destStr,char * srcStr,int num);</code></p>","keywords":null,"cover":null,"content":null,"text":"strcpy函数以及strncpy函数这两个函数都是字符串拷贝函数函数原型：char * strcpy(char * destStr,char * srcStr);cahr * strncpy(char * destStr,char * srcStr,int num);很明显可以","link":"","raw":null,"photos":[],"categories":[{"name":"面试","slug":"面试","count":18,"path":"api/categories/面试.json"}],"tags":[{"name":"C++","slug":"C","count":16,"path":"api/tags/C.json"}]},{"title":"C++面试问题准备：关于命令--netstat tcpdump ipcs ipcrm的使用","slug":"C-面试问题准备：关于命令-netstat-tcpdump-ipcs-ipcrm的使用","date":"2018-02-26T05:34:33.000Z","updated":"2018-02-26T08:44:45.000Z","comments":true,"path":"api/articles/C-面试问题准备：关于命令-netstat-tcpdump-ipcs-ipcrm的使用.json","excerpt":"<h2 id=\"网络通信命令–netstat-tcpdump\"><a href=\"#网络通信命令–netstat-tcpdump\" class=\"headerlink\" title=\"网络通信命令–netstat tcpdump\"></a>网络通信命令–netstat tcpdump</h2><h3 id=\"netstat：查看网络连接状态\"><a href=\"#netstat：查看网络连接状态\" class=\"headerlink\" title=\"netstat：查看网络连接状态\"></a><strong>netstat：查看网络连接状态</strong></h3><blockquote>\n<p>如果某一个网络服务已经启动，但是就是无法进行连接，这个时候就需要查询一下网络接口所监听的端口（port），来看看是否真的已经启动，因为有的时候屏幕上显示的OK并不一定真的就是”OK”。","keywords":null,"cover":"/images/linuxImages/net_rn.png","content":null,"text":"网络通信命令–netstat tcpdumpnetstat：查看网络连接状态如果某一个网络服务已经启动，但是就是无法进行连接，这个时候就需要查询一下网络接口所监听的端口（port），来看看是否真的已经启动，因为有的时候屏幕上显示的OK并不一定真的就是”OK”。关于netstat的","link":"","raw":null,"photos":[],"categories":[{"name":"面试","slug":"面试","count":18,"path":"api/categories/面试.json"}],"tags":[{"name":"Linux","slug":"Linux","count":1,"path":"api/tags/Linux.json"}]},{"title":"C++ 面试问题准备：内存分配的方式","slug":"C-面试问题准备：内存分配的方式","date":"2018-01-30T12:16:57.000Z","updated":"2018-02-22T12:54:00.000Z","comments":true,"path":"api/articles/C-面试问题准备：内存分配的方式.json","excerpt":"<h3 id=\"C-中常见内存分配及其存储区域有以下几种\"><a href=\"#C-中常见内存分配及其存储区域有以下几种\" class=\"headerlink\" title=\"C++ 中常见内存分配及其存储区域有以下几种\"></a>C++ 中常见内存分配及其存储区域有以下几种</h3><ul>\n<li>堆分配</li>\n<li>栈分配</li>\n<li>自由存储区</li>\n<li>静态存储区</li>\n<li>常量存储区","keywords":null,"cover":null,"content":null,"text":"C++ 中常见内存分配及其存储区域有以下几种堆分配栈分配自由存储区静态存储区常量存储区这里首先描述以下除了堆和栈的三种存储方式：自由存储区这个存储区是单独为C++ 中new运算符提出来的，该存储区是new和delete动态分配和释放对象的抽象概念。在《STL 源码剖析中》自由存储","link":"","raw":null,"photos":[],"categories":[{"name":"面试","slug":"面试","count":18,"path":"api/categories/面试.json"}],"tags":[{"name":"C++","slug":"C","count":16,"path":"api/tags/C.json"}]},{"title":"C++面试问题准备：剑指 offer--链表中倒数第k个结点和合并反转链表","slug":"C-面试问题准备：剑指 offer-链表中倒数第k个结点和合并反转链表","date":"2018-03-07T11:07:47.000Z","updated":"2018-03-07T13:43:33.000Z","comments":true,"path":"api/articles/C-面试问题准备：剑指 offer-链表中倒数第k个结点和合并反转链表.json","excerpt":"<h2 id=\"链表中倒数第K个结点\"><a href=\"#链表中倒数第K个结点\" class=\"headerlink\" title=\"链表中倒数第K个结点\"></a>链表中倒数第K个结点</h2><blockquote>\n<p>问题描述：输入一个链表，输出该链表中倒数第K个结点。例如一个链表有6个结点，从头结点开始它们的值依次是1，2，3，4，5，6。这个链表的倒数第三个结点值为4。<br>","keywords":null,"cover":"/images/linkList.jpeg","content":null,"text":"链表中倒数第K个结点问题描述：输入一个链表，输出该链表中倒数第K个结点。例如一个链表有6个结点，从头结点开始它们的值依次是1，2，3，4，5，6。这个链表的倒数第三个结点值为4。<br>为了得到我们想要的结果，我们会很自然的想到假设这个链表有n个结点，那么倒数第k个结点就是从头结","link":"","raw":null,"photos":[],"categories":[{"name":"面试","slug":"面试","count":18,"path":"api/categories/面试.json"}],"tags":[{"name":"C++","slug":"C","count":16,"path":"api/tags/C.json"}]},{"title":"C++开发面试问题准备：剑指 offer--二叉树的镜像和顺时针打印矩阵","slug":"C-面试问题准备：剑指-offer-二叉树的镜像和顺时针打印矩阵","date":"2018-02-08T09:31:05.000Z","updated":"2018-02-22T12:54:00.000Z","comments":true,"path":"api/articles/C-面试问题准备：剑指-offer-二叉树的镜像和顺时针打印矩阵.json","excerpt":"<h2 id=\"二叉树的镜像\"><a href=\"#二叉树的镜像\" class=\"headerlink\" title=\"二叉树的镜像\"></a>二叉树的镜像</h2><blockquote>\n<p>题目描述：完成一个函数，输入一个二叉树，该函数输出它的镜像</p>\n</blockquote>\n<p>如图：</p>\n<p><img src=\"/images/treeMirror.jpg\" alt=\"二叉树镜像\">","keywords":null,"cover":"/images/treeMirror.jpg","content":null,"text":"二叉树的镜像题目描述：完成一个函数，输入一个二叉树，该函数输出它的镜像如图： [Figure] 具体测试实现这里就不多说了，相信大家读懂思路之后代码就是顺手拈来！","link":"","raw":null,"photos":[],"categories":[{"name":"面试","slug":"面试","count":18,"path":"api/categories/面试.json"}],"tags":[{"name":"C++","slug":"C","count":16,"path":"api/tags/C.json"}]},{"title":"C++面试问题准备：剑指 offer-包含min函数的栈和栈的压入和弹出","slug":"C-面试问题准备：剑指-offer-包含min函数的栈和栈的压入和弹出","date":"2018-02-27T16:12:54.000Z","updated":"2018-03-03T07:27:32.000Z","comments":true,"path":"api/articles/C-面试问题准备：剑指-offer-包含min函数的栈和栈的压入和弹出.json","excerpt":"<h2 id=\"包含min函数的栈\"><a href=\"#包含min函数的栈\" class=\"headerlink\" title=\"包含min函数的栈\"></a>包含min函数的栈</h2><blockquote>\n<p>题目描述：定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的min函数，且在该栈中调用min,push以及pop的时间复杂度都是O(1)","keywords":null,"cover":"/images/minStack.png","content":null,"text":"包含min函数的栈题目描述：定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的min函数，且在该栈中调用min,push以及pop的时间复杂度都是O(1)看到这个问题我们会想到每一次将元素压入栈的时候对栈内所有的元素进行排序，将最小的元素放到栈顶，这样可以在O(1)时间","link":"","raw":null,"photos":[],"categories":[{"name":"面试","slug":"面试","count":18,"path":"api/categories/面试.json"}],"tags":[{"name":"C++","slug":"C","count":16,"path":"api/tags/C.json"}]},{"title":"C++面试问题准备：剑指-offer--合并两个排序链表和树的子结构","slug":"C-面试问题准备：剑指-offer-合并两个排序链表和树的子结构","date":"2018-03-07T11:59:45.000Z","updated":"2018-03-07T13:43:47.000Z","comments":true,"path":"api/articles/C-面试问题准备：剑指-offer-合并两个排序链表和树的子结构.json","excerpt":"<h2 id=\"合并两个排序链表\"><a href=\"#合并两个排序链表\" class=\"headerlink\" title=\"合并两个排序链表\"></a>合并两个排序链表</h2><blockquote>\n<p>输入两个递增排序的链表，合并这两个链表并使新链表中的结点仍然使按照递增排序的。</p>\n</blockquote>\n<p>常见问题：</p>\n<ul>\n<li>写代码之前没有对合并过程想清楚，最终合并出来的链表要么中间断开，要么没有做到递增排序</li>\n<li>代码的鲁棒性存在问题，程序有特殊输入会崩溃（输入空链表）","keywords":null,"cover":"/images/mergeList.png","content":null,"text":"合并两个排序链表输入两个递增排序的链表，合并这两个链表并使新链表中的结点仍然使按照递增排序的。常见问题：写代码之前没有对合并过程想清楚，最终合并出来的链表要么中间断开，要么没有做到递增排序代码的鲁棒性存在问题，程序有特殊输入会崩溃（输入空链表） [Figure] 要查找第一棵树中","link":"","raw":null,"photos":[],"categories":[{"name":"面试","slug":"面试","count":18,"path":"api/categories/面试.json"}],"tags":[{"name":"C++","slug":"C","count":16,"path":"api/tags/C.json"}]},{"title":"C++面试问题准备：多线程还是多进程的选择以及区别","slug":"C-面试问题准备：多线程还是多进程的选择以及区别","date":"2018-03-04T12:27:20.000Z","updated":"2018-03-05T09:42:35.000Z","comments":true,"path":"api/articles/C-面试问题准备：多线程还是多进程的选择以及区别.json","excerpt":"<h2 id=\"进程和线程的区别\"><a href=\"#进程和线程的区别\" class=\"headerlink\" title=\"进程和线程的区别\"></a>进程和线程的区别</h2><ul>\n<li>一个进程由一个或多个线程组成，线程是一个进程中代码的不同执行路线；</li>\n<li>进程之间相互独立，但同一进程下的各个线程之间共享程序的内存空间(包括代码段、数据集、堆等)及一些进程级的资源(如打开文件和信号)，某进程内的线程在其它进程不可见</li>\n<li>调度和切换：线程上下文切换比进程上下文切换要快得多","keywords":null,"cover":"/images/moreIPC.png","content":null,"text":"进程和线程的区别一个进程由一个或多个线程组成，线程是一个进程中代码的不同执行路线；进程之间相互独立，但同一进程下的各个线程之间共享程序的内存空间(包括代码段、数据集、堆等)及一些进程级的资源(如打开文件和信号)，某进程内的线程在其它进程不可见调度和切换：线程上下文切换比进程上下文","link":"","raw":null,"photos":[],"categories":[{"name":"面试","slug":"面试","count":18,"path":"api/categories/面试.json"}],"tags":[{"name":"C++","slug":"C","count":16,"path":"api/tags/C.json"}]},{"title":"C++面试问题准备：辨认大小端以及系统位数","slug":"C-面试问题准备：辨认大小端以及系统位数","date":"2018-02-17T08:33:17.000Z","updated":"2018-02-26T05:28:07.000Z","comments":true,"path":"api/articles/C-面试问题准备：辨认大小端以及系统位数.json","excerpt":"<h2 id=\"什么是大小端-big-endian和small-endian\"><a href=\"#什么是大小端-big-endian和small-endian\" class=\"headerlink\" title=\"什么是大小端(big-endian和small-endian)\"></a>什么是大小端(big-endian和small-endian)</h2><p>即最高有效位(most significant)在低地址位就是大端，最低有效位(least significant)在低地址就是小端。<br>大概意思就是：我们取数据a = 0x12ff，那么最高有效位指的就是数字的0x12数据，最低有效位指的是0xff。<br>","keywords":null,"cover":null,"content":null,"text":"什么是大小端(big-endian和small-endian)即最高有效位(most significant)在低地址位就是大端，最低有效位(least significant)在低地址就是小端。<br>大概意思就是：我们取数据a = 0x12ff，那么最高有效位指的就是数字的0","link":"","raw":null,"photos":[],"categories":[{"name":"面试","slug":"面试","count":18,"path":"api/categories/面试.json"}],"tags":[{"name":"C++","slug":"C","count":16,"path":"api/tags/C.json"},{"name":"OS","slug":"OS","count":1,"path":"api/tags/OS.json"}]},{"title":"C++面试问题准备：面向对象的基本原则","slug":"C-面试问题准备：面向对象的基本原则","date":"2018-02-04T13:47:31.000Z","updated":"2018-02-22T12:54:00.000Z","comments":true,"path":"api/articles/C-面试问题准备：面向对象的基本原则.json","excerpt":"<p>关于面向对象的五个基本原则：</p>\n<ul>\n<li>单一职责原则</li>\n<li>开放封闭原则</li>\n<li>Liskov替换原则</li>\n<li>依赖导致原则</li>\n<li>接口隔离原则","keywords":null,"cover":null,"content":null,"text":"关于面向对象的五个基本原则：单一职责原则开放封闭原则Liskov替换原则依赖导致原则接口隔离原则单一职责原则（Single-Resposibility Principle）一个类应该仅有一个引起它变化的原因(最简单，最容易理解却最不容易做到的一个设计原则)单一职责原则可以看做是低","link":"","raw":null,"photos":[],"categories":[{"name":"面试","slug":"面试","count":18,"path":"api/categories/面试.json"}],"tags":[{"name":"C++","slug":"C","count":16,"path":"api/tags/C.json"}]},{"title":"C++面试问题总结：指针和引用的区别以及extern C的作用","slug":"C-面试问题总结：指针和引用的区别","date":"2018-03-04T05:50:38.000Z","updated":"2018-03-04T10:40:12.000Z","comments":true,"path":"api/articles/C-面试问题总结：指针和引用的区别.json","excerpt":"<h3 id=\"指针和引用的区别\"><a href=\"#指针和引用的区别\" class=\"headerlink\" title=\"指针和引用的区别\"></a>指针和引用的区别</h3><blockquote>\n<p>指针和引用都代表的是地址</p>\n</blockquote>\n<ul>\n<li><strong>引用</strong>需要指向某些对象，但是你可以声明指针变量为空，然后将引用指向该指针变量。</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">char</span> <span class=\"meta\">*pc</span> <span class=\"string\">=</span> <span class=\"literal\">NULL</span><span class=\"string\">;</span></span><br><span class=\"line\"><span class=\"string\">char</span> <span class=\"meta\">&amp;rc</span> <span class=\"string\">=</span> <span class=\"string\">*pc;</span></span><br></pre></td></tr></table></figure>","keywords":null,"cover":null,"content":null,"text":"指针和引用的区别指针和引用都代表的是地址引用需要指向某些对象，但是你可以声明指针变量为空，然后将引用指向该指针变量。1<br>2<br>char *pc = NULL;<br>char &amp;rc = *pc;<br>因为引用肯定会指向一个对象，因此必须初始化，其实和１是一回","link":"","raw":null,"photos":[],"categories":[{"name":"面试","slug":"面试","count":18,"path":"api/categories/面试.json"}],"tags":[{"name":"C++","slug":"C","count":16,"path":"api/tags/C.json"}]}]}