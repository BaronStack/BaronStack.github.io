{"name":"面试","slug":"面试","count":8,"postlist":[{"title":"C++开发面试问题","slug":"C-开发面试问题","date":"2018-01-26T14:47:27.000Z","updated":"2018-01-30T12:17:30.000Z","comments":true,"path":"api/articles/C-开发面试问题.json","excerpt":"<h4 id=\"语言基础\"><a href=\"#语言基础\" class=\"headerlink\" title=\"语言基础\"></a>语言基础</h4><ul>\n<li>OOP（封装、继承、多态） + V func 的实现，V table 的原理</li>\n<li>const static的各种情况，分清const pointer 和pointer to const以及两者合体的形式","keywords":null,"cover":null,"content":null,"text":"语言基础OOP（封装、继承、多态） + V func 的实现，V table 的原理const static的各种情况，分清const pointer 和pointer to const以及两者合体的形式内存泄漏 三条规则。注意exception safe和smart point","link":"","raw":null,"photos":[],"categories":[{"name":"面试","slug":"面试","count":8,"path":"api/categories/面试.json"}],"tags":[{"name":"C++","slug":"C","count":10,"path":"api/tags/C.json"}]},{"title":"C++面试问题准备：STL-iterator","slug":"C-面试问题准备：STL-iterator","date":"2018-02-11T12:53:12.000Z","updated":"2018-02-17T05:18:50.000Z","comments":true,"path":"api/articles/C-面试问题准备：STL-iterator.json","excerpt":"<blockquote>\n<p>这两天在家里没有好好读书，要反思一下。今天看《STL源码剖析》到了迭代器iterator这里</p>\n</blockquote>\n<h2 id=\"什么是迭代器\"><a href=\"#什么是迭代器\" class=\"headerlink\" title=\"什么是迭代器\"></a>什么是迭代器</h2><p>在《Design Patterns》中对迭代器模式的描述如下：<font color=\"#DC143C\">提供一种方法，使之能够依序寻访某个聚合物（容器）所含的各个元素，而又无需暴露该聚合物内部表现方式</font>","keywords":null,"cover":null,"content":null,"text":"这两天在家里没有好好读书，要反思一下。今天看《STL源码剖析》到了迭代器iterator这里什么是迭代器在《Design Patterns》中对迭代器模式的描述如下：提供一种方法，使之能够依序寻访某个聚合物（容器）所含的各个元素，而又无需暴露该聚合物内部表现方式 这里小小的回忆下","link":"","raw":null,"photos":[],"categories":[{"name":"面试","slug":"面试","count":8,"path":"api/categories/面试.json"}],"tags":[{"name":"C++","slug":"C","count":10,"path":"api/tags/C.json"}]},{"title":"C++开发面试问题准备：源程序编译过程以及静态链接和动态链接的区别","slug":"C-开发面试问题准备：静态链接和动态链接","date":"2018-02-07T04:44:33.000Z","updated":"2018-02-07T09:36:27.000Z","comments":true,"path":"api/articles/C-开发面试问题准备：静态链接和动态链接.json","excerpt":"<p>在Linux下我们用GCC对源码进行编译，编译的过程中有一个步骤是链接。这里我们先了解一下编译的过程，我在xmind中画的一个图如下，对软件不够熟悉，所以画得比较丑。</p>\n<p><img src=\"/images/Compile&amp;&amp;Linking.png\" alt=\"编译过程\"></p>\n<p>大体分为一下几个步骤：</p>\n<ul>\n<li>预处理（Preprocess）</li>\n<li>编译(Complication)</li>\n<li>汇编(Assembly)</li>\n<li>链接(Linking)</li>\n<li>执行(Execute)","keywords":null,"cover":"/images/Compile&amp;&amp;Linking.png","content":null,"text":"在Linux下我们用GCC对源码进行编译，编译的过程中有一个步骤是链接。这里我们先了解一下编译的过程，我在xmind中画的一个图如下，对软件不够熟悉，所以画得比较丑。 [Figure] 一些功能代码经过编译连接后的可执行形式静态lib将导出声明和实现都放在lib中。编译后所有代码","link":"","raw":null,"photos":[],"categories":[{"name":"面试","slug":"面试","count":8,"path":"api/categories/面试.json"}],"tags":[{"name":"C++","slug":"C","count":10,"path":"api/tags/C.json"}]},{"title":"C++面试问题准备：i++是否原子操作，为什么","slug":"C-面试问题准备：i-是否原子操作，为什么","date":"2018-02-17T06:48:38.000Z","updated":"2018-02-17T07:18:54.000Z","comments":true,"path":"api/articles/C-面试问题准备：i-是否原子操作，为什么.json","excerpt":"<h2 id=\"什么是操作系统原子操作\"><a href=\"#什么是操作系统原子操作\" class=\"headerlink\" title=\"什么是操作系统原子操作\"></a>什么是操作系统原子操作</h2><p><strong>原子操作是不可分割的，在执行完毕之前不会被任何其他事物或者事件中断，分为以下两种情况：</strong></p>\n<ul>\n<li>在单线程中， 能够在单条指令中完成的操作都可以认为是” 原子操作”，因为中断只能发生于指令之间</li>\n<li>在多线程中，不能被其它进程（线程）打断的操作就叫原子操作","keywords":null,"cover":null,"content":null,"text":"什么是操作系统原子操作原子操作是不可分割的，在执行完毕之前不会被任何其他事物或者事件中断，分为以下两种情况：在单线程中， 能够在单条指令中完成的操作都可以认为是” 原子操作”，因为中断只能发生于指令之间在多线程中，不能被其它进程（线程）打断的操作就叫原子操作 i++分为三个阶段内","link":"","raw":null,"photos":[],"categories":[{"name":"面试","slug":"面试","count":8,"path":"api/categories/面试.json"}],"tags":[{"name":"C++","slug":"C","count":10,"path":"api/tags/C.json"}]},{"title":"C++ 面试问题准备：内存分配的方式","slug":"C-面试问题准备：内存分配的方式","date":"2018-01-30T12:16:57.000Z","updated":"2018-01-30T13:36:01.000Z","comments":true,"path":"api/articles/C-面试问题准备：内存分配的方式.json","excerpt":"<h3 id=\"C-中常见内存分配及其存储区域有以下几种\"><a href=\"#C-中常见内存分配及其存储区域有以下几种\" class=\"headerlink\" title=\"C++ 中常见内存分配及其存储区域有以下几种\"></a>C++ 中常见内存分配及其存储区域有以下几种</h3><ul>\n<li>堆分配</li>\n<li>栈分配</li>\n<li>自由存储区</li>\n<li>静态存储区</li>\n<li>常量存储区","keywords":null,"cover":null,"content":null,"text":"C++ 中常见内存分配及其存储区域有以下几种堆分配栈分配自由存储区静态存储区常量存储区这里首先描述以下除了堆和栈的三种存储方式：自由存储区这个存储区是单独为C++ 中new运算符提出来的，该存储区是new和delete动态分配和释放对象的抽象概念。在《STL 源码剖析中》自由存储","link":"","raw":null,"photos":[],"categories":[{"name":"面试","slug":"面试","count":8,"path":"api/categories/面试.json"}],"tags":[{"name":"C++","slug":"C","count":10,"path":"api/tags/C.json"}]},{"title":"C++开发面试问题准备：剑指 offer--二叉树的镜像和顺时针打印矩阵","slug":"C-面试问题准备：剑指-offer-二叉树的镜像和顺时针打印矩阵","date":"2018-02-08T09:31:05.000Z","updated":"2018-02-08T11:24:22.000Z","comments":true,"path":"api/articles/C-面试问题准备：剑指-offer-二叉树的镜像和顺时针打印矩阵.json","excerpt":"<h2 id=\"二叉树的镜像\"><a href=\"#二叉树的镜像\" class=\"headerlink\" title=\"二叉树的镜像\"></a>二叉树的镜像</h2><blockquote>\n<p>题目描述：完成一个函数，输入一个二叉树，该函数输出它的镜像</p>\n</blockquote>\n<p>如图：</p>\n<p><img src=\"/images/treeMirror.jpg\" alt=\"二叉树镜像\">","keywords":null,"cover":"/images/treeMirror.jpg","content":null,"text":"二叉树的镜像题目描述：完成一个函数，输入一个二叉树，该函数输出它的镜像如图： [Figure] 具体测试实现这里就不多说了，相信大家读懂思路之后代码就是顺手拈来！","link":"","raw":null,"photos":[],"categories":[{"name":"面试","slug":"面试","count":8,"path":"api/categories/面试.json"}],"tags":[{"name":"C++","slug":"C","count":10,"path":"api/tags/C.json"}]},{"title":"C++面试问题准备：辨认大小端以及系统位数","slug":"C-面试问题准备：辨认大小端以及系统位数","date":"2018-02-17T08:33:17.000Z","updated":"2018-02-17T09:18:14.000Z","comments":true,"path":"api/articles/C-面试问题准备：辨认大小端以及系统位数.json","excerpt":"","keywords":null,"cover":null,"content":"<h2 id=\"什么是大小端-big-endian和small-endian\"><a href=\"#什么是大小端-big-endian和small-endian\" class=\"headerlink\" title=\"什么是大小端(big-endian和small-endian)\"></a>什么是大小端(big-endian和small-endian)</h2><p>即最高有效位(most significant)在低地址位就是大端，最低有效位(least significant)在低地址就是小端。<br>大概意思就是：我们取数据a = 0x12ff，那么最高有效位指的就是数字的0x12数据，最低有效位指的是0xff。</p>\n<blockquote>\n<p>即如果数据的最高有效位的数据0x12存放在内存中的低地址，那么该计算机存储的方式就是大端存储。相反就是小端存储。</p>\n</blockquote>\n<h2 id=\"如何用程序分辨大小端\"><a href=\"#如何用程序分辨大小端\" class=\"headerlink\" title=\"如何用程序分辨大小端\"></a>如何用程序分辨大小端</h2><p>根据上面大小端的定义，我们可以写出如下代码：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span>  <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> <span class=\"keyword\">const</span> *argv[])</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">short</span> num1 = <span class=\"number\">0x12FF</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">char</span> * address = (<span class=\"keyword\">char</span> *)&amp;num1;</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"low bytes is %x , high bytes is %x\"</span>,*address &amp; <span class=\"number\">0xFF</span>,  *(address + <span class=\"number\">1</span>) &amp; <span class=\"number\">0xFF</span> );</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">output:</span><br><span class=\"line\">low bytes is ff , high bytes is <span class=\"number\">12</span></span><br></pre></td></tr></table></figure>\n<p>即数据<code>num1 = 0x12FF</code>的最高有效位<code>0x12</code>存储在存放该数据内存块较低的位置，该程序可以做为验证计算机系统存储数据是大端还是小端。</p>\n<h2 id=\"如何分辨计算机系统是32位还是64位\"><a href=\"#如何分辨计算机系统是32位还是64位\" class=\"headerlink\" title=\"如何分辨计算机系统是32位还是64位\"></a>如何分辨计算机系统是32位还是64位</h2><p>在32位系统中<code>int</code> 和 <code>long int</code>是4 字节，而64位系统中则变为8字</p>\n<p>所以在以上代码中添加如下一行程序即可查看系统位数</p>\n<figure class=\"highlight perl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> a = <span class=\"number\">0x80000000</span>;</span><br><span class=\"line\"><span class=\"keyword\">printf</span>(<span class=\"string\">\"\\nos is%ld\\t%ld\\n\"</span>,a,sizeof(<span class=\"keyword\">int</span>));</span><br></pre></td></tr></table></figure>\n","text":"什么是大小端(big-endian和small-endian)即最高有效位(most significant)在低地址位就是大端，最低有效位(least significant)在低地址就是小端。<br>大概意思就是：我们取数据a = 0x12ff，那么最高有效位指的就是数字的0","link":"","raw":null,"photos":[],"categories":[{"name":"面试","slug":"面试","count":8,"path":"api/categories/面试.json"}],"tags":[{"name":"C++","slug":"C","count":10,"path":"api/tags/C.json"},{"name":"OS","slug":"OS","count":1,"path":"api/tags/OS.json"}]},{"title":"C++面试问题准备：面向对象的基本原则","slug":"C-面试问题准备：面向对象的基本原则","date":"2018-02-04T13:47:31.000Z","updated":"2018-02-06T15:15:01.000Z","comments":true,"path":"api/articles/C-面试问题准备：面向对象的基本原则.json","excerpt":"<p>关于面向对象的五个基本原则：</p>\n<ul>\n<li>单一职责原则</li>\n<li>开放封闭原则</li>\n<li>Liskov替换原则</li>\n<li>依赖导致原则</li>\n<li>接口隔离原则","keywords":null,"cover":null,"content":null,"text":"关于面向对象的五个基本原则：单一职责原则开放封闭原则Liskov替换原则依赖导致原则接口隔离原则单一职责原则（Single-Resposibility Principle）一个类应该仅有一个引起它变化的原因(最简单，最容易理解却最不容易做到的一个设计原则)单一职责原则可以看做是低","link":"","raw":null,"photos":[],"categories":[{"name":"面试","slug":"面试","count":8,"path":"api/categories/面试.json"}],"tags":[{"name":"C++","slug":"C","count":10,"path":"api/tags/C.json"}]}]}